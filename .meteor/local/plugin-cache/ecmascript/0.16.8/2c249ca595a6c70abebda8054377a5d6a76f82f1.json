{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"D:\\mergerware\\loan-management-app\\packages\\blaze\\materializer.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/blaze/materializer.js","filename":"D:\\mergerware\\loan-management-app\\packages\\blaze\\materializer.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"D:\\mergerware\\loan-management-app","root":"D:\\mergerware\\loan-management-app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"D:\\mergerware\\loan-management-app\\packages\\blaze\\materializer.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/blaze/materializer.js"}},"code":"// Turns HTMLjs into DOM nodes and DOMRanges.\n//\n// - `htmljs`: the value to materialize, which may be any of the htmljs\n//   types (Tag, CharRef, Comment, Raw, array, string, boolean, number,\n//   null, or undefined) or a View or Template (which will be used to\n//   construct a View).\n// - `intoArray`: the array of DOM nodes and DOMRanges to push the output\n//   into (required)\n// - `parentView`: the View we are materializing content for (optional)\n// - `_existingWorkStack`: optional argument, only used for recursive\n//   calls when there is some other _materializeDOM on the call stack.\n//   If _materializeDOM called your function and passed in a workStack,\n//   pass it back when you call _materializeDOM (such as from a workStack\n//   task).\n//\n// Returns `intoArray`, which is especially useful if you pass in `[]`.\nBlaze._materializeDOM = function (htmljs, intoArray, parentView, _existingWorkStack) {\n  // In order to use fewer stack frames, materializeDOMInner can push\n  // tasks onto `workStack`, and they will be popped off\n  // and run, last first, after materializeDOMInner returns.  The\n  // reason we use a stack instead of a queue is so that we recurse\n  // depth-first, doing newer tasks first.\n  var workStack = _existingWorkStack || [];\n  materializeDOMInner(htmljs, intoArray, parentView, workStack);\n  if (!_existingWorkStack) {\n    // We created the work stack, so we are responsible for finishing\n    // the work.  Call each \"task\" function, starting with the top\n    // of the stack.\n    while (workStack.length) {\n      // Note that running task() may push new items onto workStack.\n      var task = workStack.pop();\n      task();\n    }\n  }\n  return intoArray;\n};\nvar materializeDOMInner = function (htmljs, intoArray, parentView, workStack) {\n  if (htmljs == null) {\n    // null or undefined\n    return;\n  }\n  switch (typeof htmljs) {\n    case 'string':\n    case 'boolean':\n    case 'number':\n      intoArray.push(document.createTextNode(String(htmljs)));\n      return;\n    case 'object':\n      if (htmljs.htmljsType) {\n        switch (htmljs.htmljsType) {\n          case HTML.Tag.htmljsType:\n            intoArray.push(materializeTag(htmljs, parentView, workStack));\n            return;\n          case HTML.CharRef.htmljsType:\n            intoArray.push(document.createTextNode(htmljs.str));\n            return;\n          case HTML.Comment.htmljsType:\n            intoArray.push(document.createComment(htmljs.sanitizedValue));\n            return;\n          case HTML.Raw.htmljsType:\n            // Get an array of DOM nodes by using the browser's HTML parser\n            // (like innerHTML).\n            var nodes = Blaze._DOMBackend.parseHTML(htmljs.value);\n            for (var i = 0; i < nodes.length; i++) intoArray.push(nodes[i]);\n            return;\n        }\n      } else if (HTML.isArray(htmljs)) {\n        for (var i = htmljs.length - 1; i >= 0; i--) {\n          workStack.push(Blaze._bind(Blaze._materializeDOM, null, htmljs[i], intoArray, parentView, workStack));\n        }\n        return;\n      } else {\n        if (htmljs instanceof Blaze.Template) {\n          htmljs = htmljs.constructView();\n          // fall through to Blaze.View case below\n        }\n        if (htmljs instanceof Blaze.View) {\n          Blaze._materializeView(htmljs, parentView, workStack, intoArray);\n          return;\n        }\n      }\n  }\n  throw new Error(\"Unexpected object in htmljs: \" + htmljs);\n};\nvar materializeTag = function (tag, parentView, workStack) {\n  var tagName = tag.tagName;\n  var elem;\n  if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag)) && document.createElementNS) {\n    // inline SVG\n    elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n  } else {\n    // normal elements\n    elem = document.createElement(tagName);\n  }\n  var rawAttrs = tag.attrs;\n  var children = tag.children;\n  if (tagName === 'textarea' && tag.children.length && !(rawAttrs && 'value' in rawAttrs)) {\n    // Provide very limited support for TEXTAREA tags with children\n    // rather than a \"value\" attribute.\n    // Reactivity in the form of Views nested in the tag's children\n    // won't work.  Compilers should compile textarea contents into\n    // the \"value\" attribute of the tag, wrapped in a function if there\n    // is reactivity.\n    if (typeof rawAttrs === 'function' || HTML.isArray(rawAttrs)) {\n      throw new Error(\"Can't have reactive children of TEXTAREA node; \" + \"use the 'value' attribute instead.\");\n    }\n    rawAttrs = Object.assign({}, rawAttrs || null);\n    rawAttrs.value = Blaze._expand(children, parentView);\n    children = [];\n  }\n  if (rawAttrs) {\n    var attrUpdater = new ElementAttributesUpdater(elem);\n    var updateAttributes = function () {\n      var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);\n      var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);\n      var stringAttrs = {};\n      for (var attrName in flattenedAttrs) {\n        // map `null`, `undefined`, and `false` to null, which is important\n        // so that attributes with nully values are considered absent.\n        // stringify anything else (e.g. strings, booleans, numbers including 0).\n        if (flattenedAttrs[attrName] == null || flattenedAttrs[attrName] === false) stringAttrs[attrName] = null;else stringAttrs[attrName] = Blaze._toText(flattenedAttrs[attrName], parentView, HTML.TEXTMODE.STRING);\n      }\n      attrUpdater.update(stringAttrs);\n    };\n    var updaterComputation;\n    if (parentView) {\n      updaterComputation = parentView.autorun(updateAttributes, undefined, 'updater');\n    } else {\n      updaterComputation = Tracker.nonreactive(function () {\n        return Tracker.autorun(function () {\n          Tracker._withCurrentView(parentView, updateAttributes);\n        });\n      });\n    }\n    Blaze._DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {\n      updaterComputation.stop();\n    });\n  }\n  if (children.length) {\n    var childNodesAndRanges = [];\n    // push this function first so that it's done last\n    workStack.push(function () {\n      for (var i = 0; i < childNodesAndRanges.length; i++) {\n        var x = childNodesAndRanges[i];\n        if (x instanceof Blaze._DOMRange) x.attach(elem);else elem.appendChild(x);\n      }\n    });\n    // now push the task that calculates childNodesAndRanges\n    workStack.push(Blaze._bind(Blaze._materializeDOM, null, children, childNodesAndRanges, parentView, workStack));\n  }\n  return elem;\n};\nvar isSVGAnchor = function (node) {\n  // We generally aren't able to detect SVG <a> elements because\n  // if \"A\" were in our list of known svg element names, then all\n  // <a> nodes would be created using\n  // `document.createElementNS`. But in the special case of <a\n  // xlink:href=\"...\">, we can at least detect that attribute and\n  // create an SVG <a> tag in that case.\n  //\n  // However, we still have a general problem of knowing when to\n  // use document.createElementNS and when to use\n  // document.createElement; for example, font tags will always\n  // be created as SVG elements which can cause other\n  // problems. #1977\n  return node.tagName === \"a\" && node.attrs && node.attrs[\"xlink:href\"] !== undefined;\n};","map":{"version":3,"names":["Blaze","_materializeDOM","htmljs","intoArray","parentView","_existingWorkStack","workStack","materializeDOMInner","length","task","pop","push","document","createTextNode","String","htmljsType","HTML","Tag","materializeTag","CharRef","str","Comment","createComment","sanitizedValue","Raw","nodes","_DOMBackend","parseHTML","value","i","isArray","_bind","Template","constructView","View","_materializeView","Error","tag","tagName","elem","isKnownSVGElement","isSVGAnchor","createElementNS","createElement","rawAttrs","attrs","children","Object","assign","_expand","attrUpdater","ElementAttributesUpdater","updateAttributes","expandedAttrs","_expandAttributes","flattenedAttrs","flattenAttributes","stringAttrs","attrName","_toText","TEXTMODE","STRING","update","updaterComputation","autorun","undefined","Tracker","nonreactive","_withCurrentView","Teardown","onElementTeardown","attrTeardown","stop","childNodesAndRanges","x","_DOMRange","attach","appendChild","node"],"sources":["packages/blaze/materializer.js"],"sourcesContent":["// Turns HTMLjs into DOM nodes and DOMRanges.\n//\n// - `htmljs`: the value to materialize, which may be any of the htmljs\n//   types (Tag, CharRef, Comment, Raw, array, string, boolean, number,\n//   null, or undefined) or a View or Template (which will be used to\n//   construct a View).\n// - `intoArray`: the array of DOM nodes and DOMRanges to push the output\n//   into (required)\n// - `parentView`: the View we are materializing content for (optional)\n// - `_existingWorkStack`: optional argument, only used for recursive\n//   calls when there is some other _materializeDOM on the call stack.\n//   If _materializeDOM called your function and passed in a workStack,\n//   pass it back when you call _materializeDOM (such as from a workStack\n//   task).\n//\n// Returns `intoArray`, which is especially useful if you pass in `[]`.\nBlaze._materializeDOM = function (htmljs, intoArray, parentView,\n                                  _existingWorkStack) {\n  // In order to use fewer stack frames, materializeDOMInner can push\n  // tasks onto `workStack`, and they will be popped off\n  // and run, last first, after materializeDOMInner returns.  The\n  // reason we use a stack instead of a queue is so that we recurse\n  // depth-first, doing newer tasks first.\n  var workStack = (_existingWorkStack || []);\n  materializeDOMInner(htmljs, intoArray, parentView, workStack);\n\n  if (! _existingWorkStack) {\n    // We created the work stack, so we are responsible for finishing\n    // the work.  Call each \"task\" function, starting with the top\n    // of the stack.\n    while (workStack.length) {\n      // Note that running task() may push new items onto workStack.\n      var task = workStack.pop();\n      task();\n    }\n  }\n\n  return intoArray;\n};\n\nvar materializeDOMInner = function (htmljs, intoArray, parentView, workStack) {\n  if (htmljs == null) {\n    // null or undefined\n    return;\n  }\n\n  switch (typeof htmljs) {\n  case 'string': case 'boolean': case 'number':\n    intoArray.push(document.createTextNode(String(htmljs)));\n    return;\n  case 'object':\n    if (htmljs.htmljsType) {\n      switch (htmljs.htmljsType) {\n      case HTML.Tag.htmljsType:\n        intoArray.push(materializeTag(htmljs, parentView, workStack));\n        return;\n      case HTML.CharRef.htmljsType:\n        intoArray.push(document.createTextNode(htmljs.str));\n        return;\n      case HTML.Comment.htmljsType:\n        intoArray.push(document.createComment(htmljs.sanitizedValue));\n        return;\n      case HTML.Raw.htmljsType:\n        // Get an array of DOM nodes by using the browser's HTML parser\n        // (like innerHTML).\n        var nodes = Blaze._DOMBackend.parseHTML(htmljs.value);\n        for (var i = 0; i < nodes.length; i++)\n          intoArray.push(nodes[i]);\n        return;\n      }\n    } else if (HTML.isArray(htmljs)) {\n      for (var i = htmljs.length-1; i >= 0; i--) {\n        workStack.push(Blaze._bind(Blaze._materializeDOM, null,\n                              htmljs[i], intoArray, parentView, workStack));\n      }\n      return;\n    } else {\n      if (htmljs instanceof Blaze.Template) {\n        htmljs = htmljs.constructView();\n        // fall through to Blaze.View case below\n      }\n      if (htmljs instanceof Blaze.View) {\n        Blaze._materializeView(htmljs, parentView, workStack, intoArray);\n        return;\n      }\n    }\n  }\n\n  throw new Error(\"Unexpected object in htmljs: \" + htmljs);\n};\n\nvar materializeTag = function (tag, parentView, workStack) {\n  var tagName = tag.tagName;\n  var elem;\n  if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag))\n      && document.createElementNS) {\n    // inline SVG\n    elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n  } else {\n    // normal elements\n    elem = document.createElement(tagName);\n  }\n\n  var rawAttrs = tag.attrs;\n  var children = tag.children;\n  if (tagName === 'textarea' && tag.children.length &&\n      ! (rawAttrs && ('value' in rawAttrs))) {\n    // Provide very limited support for TEXTAREA tags with children\n    // rather than a \"value\" attribute.\n    // Reactivity in the form of Views nested in the tag's children\n    // won't work.  Compilers should compile textarea contents into\n    // the \"value\" attribute of the tag, wrapped in a function if there\n    // is reactivity.\n    if (typeof rawAttrs === 'function' ||\n        HTML.isArray(rawAttrs)) {\n      throw new Error(\"Can't have reactive children of TEXTAREA node; \" +\n                      \"use the 'value' attribute instead.\");\n    }\n    rawAttrs = Object.assign({}, rawAttrs || null);\n    rawAttrs.value = Blaze._expand(children, parentView);\n    children = [];\n  }\n\n  if (rawAttrs) {\n    var attrUpdater = new ElementAttributesUpdater(elem);\n    var updateAttributes = function () {\n      var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);\n      var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);\n      var stringAttrs = {};\n      for (var attrName in flattenedAttrs) {\n        // map `null`, `undefined`, and `false` to null, which is important\n        // so that attributes with nully values are considered absent.\n        // stringify anything else (e.g. strings, booleans, numbers including 0).\n        if (flattenedAttrs[attrName] == null || flattenedAttrs[attrName] === false)\n          stringAttrs[attrName] = null;\n        else\n          stringAttrs[attrName] = Blaze._toText(flattenedAttrs[attrName],\n                                                parentView,\n                                                HTML.TEXTMODE.STRING);\n      }\n      attrUpdater.update(stringAttrs);\n    };\n    var updaterComputation;\n    if (parentView) {\n      updaterComputation =\n        parentView.autorun(updateAttributes, undefined, 'updater');\n    } else {\n      updaterComputation = Tracker.nonreactive(function () {\n        return Tracker.autorun(function () {\n          Tracker._withCurrentView(parentView, updateAttributes);\n        });\n      });\n    }\n    Blaze._DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {\n      updaterComputation.stop();\n    });\n  }\n\n  if (children.length) {\n    var childNodesAndRanges = [];\n    // push this function first so that it's done last\n    workStack.push(function () {\n      for (var i = 0; i < childNodesAndRanges.length; i++) {\n        var x = childNodesAndRanges[i];\n        if (x instanceof Blaze._DOMRange)\n          x.attach(elem);\n        else\n          elem.appendChild(x);\n      }\n    });\n    // now push the task that calculates childNodesAndRanges\n    workStack.push(Blaze._bind(Blaze._materializeDOM, null,\n                          children, childNodesAndRanges, parentView,\n                          workStack));\n  }\n\n  return elem;\n};\n\n\nvar isSVGAnchor = function (node) {\n  // We generally aren't able to detect SVG <a> elements because\n  // if \"A\" were in our list of known svg element names, then all\n  // <a> nodes would be created using\n  // `document.createElementNS`. But in the special case of <a\n  // xlink:href=\"...\">, we can at least detect that attribute and\n  // create an SVG <a> tag in that case.\n  //\n  // However, we still have a general problem of knowing when to\n  // use document.createElementNS and when to use\n  // document.createElement; for example, font tags will always\n  // be created as SVG elements which can cause other\n  // problems. #1977\n  return (node.tagName === \"a\" &&\n          node.attrs &&\n          node.attrs[\"xlink:href\"] !== undefined);\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,KAAK,CAACC,eAAe,GAAG,UAAUC,MAAM,EAAEC,SAAS,EAAEC,UAAU,EAC7BC,kBAAkB,EAAE;EACpD;EACA;EACA;EACA;EACA;EACA,IAAIC,SAAS,GAAID,kBAAkB,IAAI,EAAG;EAC1CE,mBAAmB,CAACL,MAAM,EAAEC,SAAS,EAAEC,UAAU,EAAEE,SAAS,CAAC;EAE7D,IAAI,CAAED,kBAAkB,EAAE;IACxB;IACA;IACA;IACA,OAAOC,SAAS,CAACE,MAAM,EAAE;MACvB;MACA,IAAIC,IAAI,GAAGH,SAAS,CAACI,GAAG,CAAC,CAAC;MAC1BD,IAAI,CAAC,CAAC;IACR;EACF;EAEA,OAAON,SAAS;AAClB,CAAC;AAED,IAAII,mBAAmB,GAAG,SAAAA,CAAUL,MAAM,EAAEC,SAAS,EAAEC,UAAU,EAAEE,SAAS,EAAE;EAC5E,IAAIJ,MAAM,IAAI,IAAI,EAAE;IAClB;IACA;EACF;EAEA,QAAQ,OAAOA,MAAM;IACrB,KAAK,QAAQ;IAAE,KAAK,SAAS;IAAE,KAAK,QAAQ;MAC1CC,SAAS,CAACQ,IAAI,CAACC,QAAQ,CAACC,cAAc,CAACC,MAAM,CAACZ,MAAM,CAAC,CAAC,CAAC;MACvD;IACF,KAAK,QAAQ;MACX,IAAIA,MAAM,CAACa,UAAU,EAAE;QACrB,QAAQb,MAAM,CAACa,UAAU;UACzB,KAAKC,IAAI,CAACC,GAAG,CAACF,UAAU;YACtBZ,SAAS,CAACQ,IAAI,CAACO,cAAc,CAAChB,MAAM,EAAEE,UAAU,EAAEE,SAAS,CAAC,CAAC;YAC7D;UACF,KAAKU,IAAI,CAACG,OAAO,CAACJ,UAAU;YAC1BZ,SAAS,CAACQ,IAAI,CAACC,QAAQ,CAACC,cAAc,CAACX,MAAM,CAACkB,GAAG,CAAC,CAAC;YACnD;UACF,KAAKJ,IAAI,CAACK,OAAO,CAACN,UAAU;YAC1BZ,SAAS,CAACQ,IAAI,CAACC,QAAQ,CAACU,aAAa,CAACpB,MAAM,CAACqB,cAAc,CAAC,CAAC;YAC7D;UACF,KAAKP,IAAI,CAACQ,GAAG,CAACT,UAAU;YACtB;YACA;YACA,IAAIU,KAAK,GAAGzB,KAAK,CAAC0B,WAAW,CAACC,SAAS,CAACzB,MAAM,CAAC0B,KAAK,CAAC;YACrD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACjB,MAAM,EAAEqB,CAAC,EAAE,EACnC1B,SAAS,CAACQ,IAAI,CAACc,KAAK,CAACI,CAAC,CAAC,CAAC;YAC1B;QACF;MACF,CAAC,MAAM,IAAIb,IAAI,CAACc,OAAO,CAAC5B,MAAM,CAAC,EAAE;QAC/B,KAAK,IAAI2B,CAAC,GAAG3B,MAAM,CAACM,MAAM,GAAC,CAAC,EAAEqB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACzCvB,SAAS,CAACK,IAAI,CAACX,KAAK,CAAC+B,KAAK,CAAC/B,KAAK,CAACC,eAAe,EAAE,IAAI,EAChCC,MAAM,CAAC2B,CAAC,CAAC,EAAE1B,SAAS,EAAEC,UAAU,EAAEE,SAAS,CAAC,CAAC;QACrE;QACA;MACF,CAAC,MAAM;QACL,IAAIJ,MAAM,YAAYF,KAAK,CAACgC,QAAQ,EAAE;UACpC9B,MAAM,GAAGA,MAAM,CAAC+B,aAAa,CAAC,CAAC;UAC/B;QACF;QACA,IAAI/B,MAAM,YAAYF,KAAK,CAACkC,IAAI,EAAE;UAChClC,KAAK,CAACmC,gBAAgB,CAACjC,MAAM,EAAEE,UAAU,EAAEE,SAAS,EAAEH,SAAS,CAAC;UAChE;QACF;MACF;EACF;EAEA,MAAM,IAAIiC,KAAK,CAAC,+BAA+B,GAAGlC,MAAM,CAAC;AAC3D,CAAC;AAED,IAAIgB,cAAc,GAAG,SAAAA,CAAUmB,GAAG,EAAEjC,UAAU,EAAEE,SAAS,EAAE;EACzD,IAAIgC,OAAO,GAAGD,GAAG,CAACC,OAAO;EACzB,IAAIC,IAAI;EACR,IAAI,CAACvB,IAAI,CAACwB,iBAAiB,CAACF,OAAO,CAAC,IAAIG,WAAW,CAACJ,GAAG,CAAC,KACjDzB,QAAQ,CAAC8B,eAAe,EAAE;IAC/B;IACAH,IAAI,GAAG3B,QAAQ,CAAC8B,eAAe,CAAC,4BAA4B,EAAEJ,OAAO,CAAC;EACxE,CAAC,MAAM;IACL;IACAC,IAAI,GAAG3B,QAAQ,CAAC+B,aAAa,CAACL,OAAO,CAAC;EACxC;EAEA,IAAIM,QAAQ,GAAGP,GAAG,CAACQ,KAAK;EACxB,IAAIC,QAAQ,GAAGT,GAAG,CAACS,QAAQ;EAC3B,IAAIR,OAAO,KAAK,UAAU,IAAID,GAAG,CAACS,QAAQ,CAACtC,MAAM,IAC7C,EAAGoC,QAAQ,IAAK,OAAO,IAAIA,QAAS,CAAC,EAAE;IACzC;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,OAAOA,QAAQ,KAAK,UAAU,IAC9B5B,IAAI,CAACc,OAAO,CAACc,QAAQ,CAAC,EAAE;MAC1B,MAAM,IAAIR,KAAK,CAAC,iDAAiD,GACjD,oCAAoC,CAAC;IACvD;IACAQ,QAAQ,GAAGG,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,QAAQ,IAAI,IAAI,CAAC;IAC9CA,QAAQ,CAAChB,KAAK,GAAG5B,KAAK,CAACiD,OAAO,CAACH,QAAQ,EAAE1C,UAAU,CAAC;IACpD0C,QAAQ,GAAG,EAAE;EACf;EAEA,IAAIF,QAAQ,EAAE;IACZ,IAAIM,WAAW,GAAG,IAAIC,wBAAwB,CAACZ,IAAI,CAAC;IACpD,IAAIa,gBAAgB,GAAG,SAAAA,CAAA,EAAY;MACjC,IAAIC,aAAa,GAAGrD,KAAK,CAACsD,iBAAiB,CAACV,QAAQ,EAAExC,UAAU,CAAC;MACjE,IAAImD,cAAc,GAAGvC,IAAI,CAACwC,iBAAiB,CAACH,aAAa,CAAC;MAC1D,IAAII,WAAW,GAAG,CAAC,CAAC;MACpB,KAAK,IAAIC,QAAQ,IAAIH,cAAc,EAAE;QACnC;QACA;QACA;QACA,IAAIA,cAAc,CAACG,QAAQ,CAAC,IAAI,IAAI,IAAIH,cAAc,CAACG,QAAQ,CAAC,KAAK,KAAK,EACxED,WAAW,CAACC,QAAQ,CAAC,GAAG,IAAI,CAAC,KAE7BD,WAAW,CAACC,QAAQ,CAAC,GAAG1D,KAAK,CAAC2D,OAAO,CAACJ,cAAc,CAACG,QAAQ,CAAC,EACxBtD,UAAU,EACVY,IAAI,CAAC4C,QAAQ,CAACC,MAAM,CAAC;MAC/D;MACAX,WAAW,CAACY,MAAM,CAACL,WAAW,CAAC;IACjC,CAAC;IACD,IAAIM,kBAAkB;IACtB,IAAI3D,UAAU,EAAE;MACd2D,kBAAkB,GAChB3D,UAAU,CAAC4D,OAAO,CAACZ,gBAAgB,EAAEa,SAAS,EAAE,SAAS,CAAC;IAC9D,CAAC,MAAM;MACLF,kBAAkB,GAAGG,OAAO,CAACC,WAAW,CAAC,YAAY;QACnD,OAAOD,OAAO,CAACF,OAAO,CAAC,YAAY;UACjCE,OAAO,CAACE,gBAAgB,CAAChE,UAAU,EAAEgD,gBAAgB,CAAC;QACxD,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IACApD,KAAK,CAAC0B,WAAW,CAAC2C,QAAQ,CAACC,iBAAiB,CAAC/B,IAAI,EAAE,SAASgC,YAAYA,CAAA,EAAG;MACzER,kBAAkB,CAACS,IAAI,CAAC,CAAC;IAC3B,CAAC,CAAC;EACJ;EAEA,IAAI1B,QAAQ,CAACtC,MAAM,EAAE;IACnB,IAAIiE,mBAAmB,GAAG,EAAE;IAC5B;IACAnE,SAAS,CAACK,IAAI,CAAC,YAAY;MACzB,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4C,mBAAmB,CAACjE,MAAM,EAAEqB,CAAC,EAAE,EAAE;QACnD,IAAI6C,CAAC,GAAGD,mBAAmB,CAAC5C,CAAC,CAAC;QAC9B,IAAI6C,CAAC,YAAY1E,KAAK,CAAC2E,SAAS,EAC9BD,CAAC,CAACE,MAAM,CAACrC,IAAI,CAAC,CAAC,KAEfA,IAAI,CAACsC,WAAW,CAACH,CAAC,CAAC;MACvB;IACF,CAAC,CAAC;IACF;IACApE,SAAS,CAACK,IAAI,CAACX,KAAK,CAAC+B,KAAK,CAAC/B,KAAK,CAACC,eAAe,EAAE,IAAI,EAChC6C,QAAQ,EAAE2B,mBAAmB,EAAErE,UAAU,EACzCE,SAAS,CAAC,CAAC;EACnC;EAEA,OAAOiC,IAAI;AACb,CAAC;AAGD,IAAIE,WAAW,GAAG,SAAAA,CAAUqC,IAAI,EAAE;EAChC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAQA,IAAI,CAACxC,OAAO,KAAK,GAAG,IACpBwC,IAAI,CAACjC,KAAK,IACViC,IAAI,CAACjC,KAAK,CAAC,YAAY,CAAC,KAAKoB,SAAS;AAChD,CAAC"},"sourceType":"module","externalDependencies":{},"hash":"2c249ca595a6c70abebda8054377a5d6a76f82f1"}
