{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"D:\\mergerware\\loan-management-app\\packages\\alanning:roles\\roles\\roles_common.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/alanning:roles/roles/roles_common.js","filename":"D:\\mergerware\\loan-management-app\\packages\\alanning:roles\\roles\\roles_common.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"D:\\mergerware\\loan-management-app","root":"D:\\mergerware\\loan-management-app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"MemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"D:\\mergerware\\loan-management-app\\packages\\alanning:roles\\roles\\roles_common.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/alanning:roles/roles/roles_common.js"}},"code":"!function (module1) {\n  var _typeof;\n  module1.link(\"@babel/runtime/helpers/typeof\", {\n    default: function (v) {\n      _typeof = v;\n    }\n  }, 0);\n  var _toConsumableArray;\n  module1.link(\"@babel/runtime/helpers/toConsumableArray\", {\n    default: function (v) {\n      _toConsumableArray = v;\n    }\n  }, 1);\n  /* global Meteor, Roles, Mongo */\n\n  /**\n   * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n   *\n   * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n   *  - `_id`: role name\n   *  - `children`: list of subdocuments:\n   *    - `_id`\n   *\n   * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n   *\n   * Roles can have multiple parents and can be children (subroles) of multiple roles.\n   *\n   * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n   *\n   * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n   * It's documents consist of\n   *  - `_id`: Internal MongoDB id\n   *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n   *  - `user`: A user object, usually only contains the `_id` property\n   *  - `scope`: scope name\n   *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n   *\n   * @module Roles\n   */\n  if (!Meteor.roles) {\n    Meteor.roles = new Mongo.Collection('roles');\n  }\n  if (!Meteor.roleAssignment) {\n    Meteor.roleAssignment = new Mongo.Collection('role-assignment');\n  }\n\n  /**\n   * @class Roles\n   */\n  if (typeof Roles === 'undefined') {\n    Roles = {}; // eslint-disable-line no-global-assign\n  }\n  var getGroupsForUserDeprecationWarning = false;\n  Object.assign(Roles, {\n    /**\n     * Used as a global group (now scope) name. Not used anymore.\n     *\n     * @property GLOBAL_GROUP\n     * @static\n     * @deprecated\n     */\n    GLOBAL_GROUP: null,\n    /**\n     * Create a new role.\n     *\n     * @method createRole\n     * @param {String} roleName Name of role.\n     * @param {Object} [options] Options:\n     *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n     * @return {String} ID of the new role or null.\n     * @static\n     */\n    createRole: function (roleName, options) {\n      Roles._checkRoleName(roleName);\n      options = Object.assign({\n        unlessExists: false\n      }, options);\n      var result = Meteor.roles.upsert({\n        _id: roleName\n      }, {\n        $setOnInsert: {\n          children: []\n        }\n      });\n      if (!result.insertedId) {\n        if (options.unlessExists) return null;\n        throw new Error('Role \\'' + roleName + '\\' already exists.');\n      }\n      return result.insertedId;\n    },\n    /**\n     * Delete an existing role.\n     *\n     * If the role is set for any user, it is automatically unset.\n     *\n     * @method deleteRole\n     * @param {String} roleName Name of role.\n     * @static\n     */\n    deleteRole: function (roleName) {\n      var roles;\n      var inheritedRoles;\n      Roles._checkRoleName(roleName);\n\n      // Remove all assignments\n      Meteor.roleAssignment.remove({\n        'role._id': roleName\n      });\n      do {\n        // For all roles who have it as a dependency ...\n        roles = Roles._getParentRoleNames(Meteor.roles.findOne({\n          _id: roleName\n        }));\n        Meteor.roles.find({\n          _id: {\n            $in: roles\n          }\n        }).fetch().forEach(function (r) {\n          Meteor.roles.update({\n            _id: r._id\n          }, {\n            $pull: {\n              children: {\n                _id: roleName\n              }\n            }\n          });\n          inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({\n            _id: r._id\n          }));\n          Meteor.roleAssignment.update({\n            'role._id': r._id\n          }, {\n            $set: {\n              inheritedRoles: [r._id].concat(_toConsumableArray(inheritedRoles)).map(function (r2) {\n                return {\n                  _id: r2\n                };\n              })\n            }\n          }, {\n            multi: true\n          });\n        });\n      } while (roles.length > 0);\n\n      // And finally remove the role itself\n      Meteor.roles.remove({\n        _id: roleName\n      });\n    },\n    /**\n     * Rename an existing role.\n     *\n     * @method renameRole\n     * @param {String} oldName Old name of a role.\n     * @param {String} newName New name of a role.\n     * @static\n     */\n    renameRole: function (oldName, newName) {\n      var count;\n      Roles._checkRoleName(oldName);\n      Roles._checkRoleName(newName);\n      if (oldName === newName) return;\n      var role = Meteor.roles.findOne({\n        _id: oldName\n      });\n      if (!role) {\n        throw new Error('Role \\'' + oldName + '\\' does not exist.');\n      }\n      role._id = newName;\n      Meteor.roles.insert(role);\n      do {\n        count = Meteor.roleAssignment.update({\n          'role._id': oldName\n        }, {\n          $set: {\n            'role._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      do {\n        count = Meteor.roleAssignment.update({\n          'inheritedRoles._id': oldName\n        }, {\n          $set: {\n            'inheritedRoles.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      do {\n        count = Meteor.roles.update({\n          'children._id': oldName\n        }, {\n          $set: {\n            'children.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      Meteor.roles.remove({\n        _id: oldName\n      });\n    },\n    /**\n     * Add role parent to roles.\n     *\n     * Previous parents are kept (role can have multiple parents). For users which have the\n     * parent role set, new subroles are added automatically.\n     *\n     * @method addRolesToParent\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @static\n     */\n    addRolesToParent: function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      rolesNames.forEach(function (roleName) {\n        Roles._addRoleToParent(roleName, parentName);\n      });\n    },\n    /**\n     * @method _addRoleToParent\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @private\n     * @static\n     */\n    _addRoleToParent: function (roleName, parentName) {\n      Roles._checkRoleName(roleName);\n      Roles._checkRoleName(parentName);\n\n      // query to get role's children\n      var role = Meteor.roles.findOne({\n        _id: roleName\n      });\n      if (!role) {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.');\n      }\n\n      // detect cycles\n      if (Roles._getInheritedRoleNames(role).includes(parentName)) {\n        throw new Error('Roles \\'' + roleName + '\\' and \\'' + parentName + '\\' would form a cycle.');\n      }\n      var count = Meteor.roles.update({\n        _id: parentName,\n        'children._id': {\n          $ne: role._id\n        }\n      }, {\n        $push: {\n          children: {\n            _id: role._id\n          }\n        }\n      });\n\n      // if there was no change, parent role might not exist, or role is\n      // already a subrole; in any case we do not have anything more to do\n      if (!count) return;\n      Meteor.roleAssignment.update({\n        'inheritedRoles._id': parentName\n      }, {\n        $push: {\n          inheritedRoles: {\n            $each: [role._id].concat(_toConsumableArray(Roles._getInheritedRoleNames(role))).map(function (r) {\n              return {\n                _id: r\n              };\n            })\n          }\n        }\n      }, {\n        multi: true\n      });\n    },\n    /**\n     * Remove role parent from roles.\n     *\n     * Other parents are kept (role can have multiple parents). For users which have the\n     * parent role set, removed subrole is removed automatically.\n     *\n     * @method removeRolesFromParent\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @static\n     */\n    removeRolesFromParent: function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      rolesNames.forEach(function (roleName) {\n        Roles._removeRoleFromParent(roleName, parentName);\n      });\n    },\n    /**\n     * @method _removeRoleFromParent\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @private\n     * @static\n     */\n    _removeRoleFromParent: function (roleName, parentName) {\n      Roles._checkRoleName(roleName);\n      Roles._checkRoleName(parentName);\n\n      // check for role existence\n      // this would not really be needed, but we are trying to match addRolesToParent\n      var role = Meteor.roles.findOne({\n        _id: roleName\n      }, {\n        fields: {\n          _id: 1\n        }\n      });\n      if (!role) {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.');\n      }\n      var count = Meteor.roles.update({\n        _id: parentName\n      }, {\n        $pull: {\n          children: {\n            _id: role._id\n          }\n        }\n      });\n\n      // if there was no change, parent role might not exist, or role was\n      // already not a subrole; in any case we do not have anything more to do\n      if (!count) return;\n\n      // For all roles who have had it as a dependency ...\n      var roles = [].concat(_toConsumableArray(Roles._getParentRoleNames(Meteor.roles.findOne({\n        _id: parentName\n      }))), [parentName]);\n      Meteor.roles.find({\n        _id: {\n          $in: roles\n        }\n      }).fetch().forEach(function (r) {\n        var inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({\n          _id: r._id\n        }));\n        Meteor.roleAssignment.update({\n          'role._id': r._id,\n          'inheritedRoles._id': role._id\n        }, {\n          $set: {\n            inheritedRoles: [r._id].concat(_toConsumableArray(inheritedRoles)).map(function (r2) {\n              return {\n                _id: r2\n              };\n            })\n          }\n        }, {\n          multi: true\n        });\n      });\n    },\n    /**\n     * Add users to roles.\n     *\n     * Adds roles to existing roles for each user.\n     *\n     * @example\n     *     Roles.addUsersToRoles(userId, 'admin')\n     *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n     *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n     *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method addUsersToRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    addUsersToRoles: function (users, roles, options) {\n      var id;\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        ifExists: false\n      }, options);\n      users.forEach(function (user) {\n        if (_typeof(user) === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        roles.forEach(function (role) {\n          Roles._addUserToRole(id, role, options);\n        });\n      });\n    },\n    /**\n     * Set users' roles.\n     *\n     * Replaces all existing roles with a new set of roles.\n     *\n     * @example\n     *     Roles.setUserRoles(userId, 'admin')\n     *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n     *     Roles.setUserRoles([user1, user2], ['user','editor'])\n     *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method setUserRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    setUserRoles: function (users, roles, options) {\n      var id;\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        ifExists: false,\n        anyScope: false\n      }, options);\n      users.forEach(function (user) {\n        if (_typeof(user) === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        // we first clear all roles for the user\n        var selector = {\n          'user._id': id\n        };\n        if (!options.anyScope) {\n          selector.scope = options.scope;\n        }\n        Meteor.roleAssignment.remove(selector);\n\n        // and then add all\n        roles.forEach(function (role) {\n          Roles._addUserToRole(id, role, options);\n        });\n      });\n    },\n    /**\n     * Add one user to one role.\n     *\n     * @method _addUserToRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @private\n     * @static\n     */\n    _addUserToRole: function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n      Roles._checkScopeName(options.scope);\n      if (!userId) {\n        return;\n      }\n      var role = Meteor.roles.findOne({\n        _id: roleName\n      }, {\n        fields: {\n          children: 1\n        }\n      });\n      if (!role) {\n        if (options.ifExists) {\n          return [];\n        } else {\n          throw new Error('Role \\'' + roleName + '\\' does not exist.');\n        }\n      }\n\n      // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n      var res = Meteor.roleAssignment.upsert({\n        'user._id': userId,\n        'role._id': roleName,\n        scope: options.scope\n      }, {\n        $setOnInsert: {\n          user: {\n            _id: userId\n          },\n          role: {\n            _id: roleName\n          },\n          scope: options.scope\n        }\n      });\n      if (res.insertedId) {\n        Meteor.roleAssignment.update({\n          _id: res.insertedId\n        }, {\n          $set: {\n            inheritedRoles: [roleName].concat(_toConsumableArray(Roles._getInheritedRoleNames(role))).map(function (r) {\n              return {\n                _id: r\n              };\n            })\n          }\n        });\n      }\n      return res;\n    },\n    /**\n     * Returns an array of role names the given role name is a child of.\n     *\n     * @example\n     *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getParentRoleNames\n     * @param {object} role The role object\n     * @private\n     * @static\n     */\n    _getParentRoleNames: function (role) {\n      if (!role) {\n        return [];\n      }\n      var parentRoles = new Set([role._id]);\n      parentRoles.forEach(function (roleName) {\n        Meteor.roles.find({\n          'children._id': roleName\n        }).fetch().forEach(function (parentRole) {\n          parentRoles.add(parentRole._id);\n        });\n      });\n      parentRoles.delete(role._id);\n      return _toConsumableArray(parentRoles);\n    },\n    /**\n     * Returns an array of role names the given role name is a parent of.\n     *\n     * @example\n     *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getInheritedRoleNames\n     * @param {object} role The role object\n     * @private\n     * @static\n     */\n    _getInheritedRoleNames: function (role) {\n      var inheritedRoles = new Set();\n      var nestedRoles = new Set([role]);\n      nestedRoles.forEach(function (r) {\n        var roles = Meteor.roles.find({\n          _id: {\n            $in: r.children.map(function (r) {\n              return r._id;\n            })\n          }\n        }, {\n          fields: {\n            children: 1\n          }\n        }).fetch();\n        roles.forEach(function (r2) {\n          inheritedRoles.add(r2._id);\n          nestedRoles.add(r2);\n        });\n      });\n      return _toConsumableArray(inheritedRoles);\n    },\n    /**\n     * Remove users from assigned roles.\n     *\n     * @example\n     *     Roles.removeUsersFromRoles(userId, 'admin')\n     *     Roles.removeUsersFromRoles([userId, user2], ['editor'])\n     *     Roles.removeUsersFromRoles(userId, ['user'], 'group1')\n     *\n     * @method removeUsersFromRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    removeUsersFromRoles: function (users, roles, options) {\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      users.forEach(function (user) {\n        if (!user) return;\n        roles.forEach(function (role) {\n          var id;\n          if (_typeof(user) === 'object') {\n            id = user._id;\n          } else {\n            id = user;\n          }\n          Roles._removeUserFromRole(id, role, options);\n        });\n      });\n    },\n    /**\n     * Remove one user from one role.\n     *\n     * @method _removeUserFromRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @private\n     * @static\n     */\n    _removeUserFromRole: function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n      Roles._checkScopeName(options.scope);\n      if (!userId) return;\n      var selector = {\n        'user._id': userId,\n        'role._id': roleName\n      };\n      if (!options.anyScope) {\n        selector.scope = options.scope;\n      }\n      Meteor.roleAssignment.remove(selector);\n    },\n    /**\n     * Check if user has specified roles.\n     *\n     * @example\n     *     // global roles\n     *     Roles.userIsInRole(user, 'admin')\n     *     Roles.userIsInRole(user, ['admin','editor'])\n     *     Roles.userIsInRole(userId, 'admin')\n     *     Roles.userIsInRole(userId, ['admin','editor'])\n     *\n     *     // scope roles (global roles are still checked)\n     *     Roles.userIsInRole(user, 'admin', 'group1')\n     *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n     *     Roles.userIsInRole(userId, ['admin','editor'], {scope: 'group1'})\n     *\n     * @method userIsInRole\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n     *                             will return `true` if user is in _any_ role.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope; if supplied, limits check to just that scope\n     *     the user's global roles will always be checked whether scope is specified or not\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Boolean} `true` if user is in _any_ of the target roles\n     * @static\n     */\n    userIsInRole: function (user, roles, options) {\n      var id;\n      options = Roles._normalizeOptions(options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      roles = roles.filter(function (r) {\n        return r != null;\n      });\n      if (!roles.length) return false;\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        anyScope: false\n      }, options);\n      if (user && _typeof(user) === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return false;\n      if (typeof id !== 'string') return false;\n      var selector = {\n        'user._id': id\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope, null]\n        };\n      }\n      return roles.some(function (roleName) {\n        selector['inheritedRoles._id'] = roleName;\n        return Meteor.roleAssignment.find(selector, {\n          limit: 1\n        }).count() > 0;\n      });\n    },\n    /**\n     * Retrieve user's roles.\n     *\n     * @method getRolesForUser\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n     *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n     *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n     *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n     *     result strongly dependent on the internal data structure of this plugin.\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Array} Array of user's roles, unsorted.\n     * @static\n     */\n    getRolesForUser: function (user, options) {\n      var id;\n      options = Roles._normalizeOptions(options);\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        fullObjects: false,\n        onlyAssigned: false,\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n      if (user && _typeof(user) === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return [];\n      var selector = {\n        'user._id': id\n      };\n      var filter = {\n        fields: {\n          'inheritedRoles._id': 1\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      if (options.onlyAssigned) {\n        delete filter.fields['inheritedRoles._id'];\n        filter.fields['role._id'] = 1;\n      }\n      if (options.fullObjects) {\n        delete filter.fields;\n      }\n      var roles = Meteor.roleAssignment.find(selector, filter).fetch();\n      if (options.fullObjects) {\n        return roles;\n      }\n      return _toConsumableArray(new Set(roles.reduce(function (rev, current) {\n        if (current.inheritedRoles) {\n          return rev.concat(current.inheritedRoles.map(function (r) {\n            return r._id;\n          }));\n        } else if (current.role) {\n          rev.push(current.role._id);\n        }\n        return rev;\n      }, [])));\n    },\n    /**\n     * Retrieve cursor of all existing roles.\n     *\n     * @method getAllRoles\n     * @param {Object} queryOptions Options which are passed directly\n     *                                through to `Meteor.roles.find(query, options)`.\n     * @return {Cursor} Cursor of existing roles.\n     * @static\n     */\n    getAllRoles: function (queryOptions) {\n      queryOptions = queryOptions || {\n        sort: {\n          _id: 1\n        }\n      };\n      return Meteor.roles.find({}, queryOptions);\n    },\n    /**\n     * Retrieve all users who are in target role.\n     *\n     * Options:\n     *\n     * @method getUsersInRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.users.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.users.find(query, options)`\n     * @return {Cursor} Cursor of users in roles.\n     * @static\n     */\n    getUsersInRole: function (roles, options, queryOptions) {\n      var ids = Roles.getUserAssignmentsForRole(roles, options).fetch().map(function (a) {\n        return a.user._id;\n      });\n      return Meteor.users.find({\n        _id: {\n          $in: ids\n        }\n      }, options && options.queryOptions || queryOptions || {});\n    },\n    /**\n     * Retrieve all assignments of a user which are for the target role.\n     *\n     * Options:\n     *\n     * @method getUserAssignmentsForRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.roleAssignment.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Cursor} Cursor of user assignments for roles.\n     * @static\n     */\n    getUserAssignmentsForRole: function (roles, options) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        queryOptions: {}\n      }, options);\n      return Roles._getUsersInRoleCursor(roles, options, options.queryOptions);\n    },\n    /**\n     * @method _getUsersInRoleCursor\n     * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n     *                             returned which have at least one of the roles\n     *                             assigned but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [filter] Options which are passed directly\n     *                                through to `Meteor.roleAssignment.find(query, options)`\n     * @return {Object} Cursor to the assignment documents\n     * @private\n     * @static\n     */\n    _getUsersInRoleCursor: function (roles, options, filter) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      filter = Object.assign({\n        fields: {\n          'user._id': 1\n        }\n      }, filter);\n      var selector = {\n        'inheritedRoles._id': {\n          $in: roles\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      return Meteor.roleAssignment.find(selector, filter);\n    },\n    /**\n     * Deprecated. Use `getScopesForUser` instead.\n     *\n     * @method getGroupsForUser\n     * @static\n     * @deprecated\n     */\n    getGroupsForUser: function () {\n      var _Roles;\n      if (!getGroupsForUserDeprecationWarning) {\n        getGroupsForUserDeprecationWarning = true;\n        console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.');\n      }\n      return (_Roles = Roles).getScopesForUser.apply(_Roles, arguments);\n    },\n    /**\n     * Retrieve users scopes, if any.\n     *\n     * @method getScopesForUser\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} [roles] Name of roles to restrict scopes to.\n     *\n     * @return {Array} Array of user's scopes, unsorted.\n     * @static\n     */\n    getScopesForUser: function (user, roles) {\n      var id;\n      if (roles && !Array.isArray(roles)) roles = [roles];\n      if (user && _typeof(user) === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return [];\n      var selector = {\n        'user._id': id,\n        scope: {\n          $ne: null\n        }\n      };\n      if (roles) {\n        selector['inheritedRoles._id'] = {\n          $in: roles\n        };\n      }\n      var scopes = Meteor.roleAssignment.find(selector, {\n        fields: {\n          scope: 1\n        }\n      }).fetch().map(function (obi) {\n        return obi.scope;\n      });\n      return _toConsumableArray(new Set(scopes));\n    },\n    /**\n     * Rename a scope.\n     *\n     * Roles assigned with a given scope are changed to be under the new scope.\n     *\n     * @method renameScope\n     * @param {String} oldName Old name of a scope.\n     * @param {String} newName New name of a scope.\n     * @static\n     */\n    renameScope: function (oldName, newName) {\n      var count;\n      Roles._checkScopeName(oldName);\n      Roles._checkScopeName(newName);\n      if (oldName === newName) return;\n      do {\n        count = Meteor.roleAssignment.update({\n          scope: oldName\n        }, {\n          $set: {\n            scope: newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n    },\n    /**\n     * Remove a scope.\n     *\n     * Roles assigned with a given scope are removed.\n     *\n     * @method removeScope\n     * @param {String} name The name of a scope.\n     * @static\n     */\n    removeScope: function (name) {\n      Roles._checkScopeName(name);\n      Meteor.roleAssignment.remove({\n        scope: name\n      });\n    },\n    /**\n     * Throw an exception if `roleName` is an invalid role name.\n     *\n     * @method _checkRoleName\n     * @param {String} roleName A role name to match against.\n     * @private\n     * @static\n     */\n    _checkRoleName: function (roleName) {\n      if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n        throw new Error('Invalid role name \\'' + roleName + '\\'.');\n      }\n    },\n    /**\n     * Find out if a role is an ancestor of another role.\n     *\n     * WARNING: If you check this on the client, please make sure all roles are published.\n     *\n     * @method isParentOf\n     * @param {String} parentRoleName The role you want to research.\n     * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n     * @static\n     */\n    isParentOf: function (parentRoleName, childRoleName) {\n      if (parentRoleName === childRoleName) {\n        return true;\n      }\n      if (parentRoleName == null || childRoleName == null) {\n        return false;\n      }\n      Roles._checkRoleName(parentRoleName);\n      Roles._checkRoleName(childRoleName);\n      var rolesToCheck = [parentRoleName];\n      while (rolesToCheck.length !== 0) {\n        var roleName = rolesToCheck.pop();\n        if (roleName === childRoleName) {\n          return true;\n        }\n        var role = Meteor.roles.findOne({\n          _id: roleName\n        });\n\n        // This should not happen, but this is a problem to address at some other time.\n        if (!role) continue;\n        rolesToCheck = rolesToCheck.concat(role.children.map(function (r) {\n          return r._id;\n        }));\n      }\n      return false;\n    },\n    /**\n     * Normalize options.\n     *\n     * @method _normalizeOptions\n     * @param {Object} options Options to normalize.\n     * @return {Object} Normalized options.\n     * @private\n     * @static\n     */\n    _normalizeOptions: function (options) {\n      options = options === undefined ? {} : options;\n      if (options === null || typeof options === 'string') {\n        options = {\n          scope: options\n        };\n      }\n      options.scope = Roles._normalizeScopeName(options.scope);\n      return options;\n    },\n    /**\n     * Normalize scope name.\n     *\n     * @method _normalizeScopeName\n     * @param {String} scopeName A scope name to normalize.\n     * @return {String} Normalized scope name.\n     * @private\n     * @static\n     */\n    _normalizeScopeName: function (scopeName) {\n      // map undefined and null to null\n      if (scopeName == null) {\n        return null;\n      } else {\n        return scopeName;\n      }\n    },\n    /**\n     * Throw an exception if `scopeName` is an invalid scope name.\n     *\n     * @method _checkRoleName\n     * @param {String} scopeName A scope name to match against.\n     * @private\n     * @static\n     */\n    _checkScopeName: function (scopeName) {\n      if (scopeName === null) return;\n      if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n        throw new Error('Invalid scope name \\'' + scopeName + '\\'.');\n      }\n    }\n  });\n}.call(this, module);","map":{"version":3,"names":["_typeof","module1","link","default","v","_toConsumableArray","Meteor","roles","Mongo","Collection","roleAssignment","Roles","getGroupsForUserDeprecationWarning","Object","assign","GLOBAL_GROUP","createRole","roleName","options","_checkRoleName","unlessExists","result","upsert","_id","$setOnInsert","children","insertedId","Error","deleteRole","inheritedRoles","remove","_getParentRoleNames","findOne","find","$in","fetch","forEach","r","update","$pull","_getInheritedRoleNames","$set","concat","map","r2","multi","length","renameRole","oldName","newName","count","role","insert","addRolesToParent","rolesNames","parentName","Array","isArray","_addRoleToParent","includes","$ne","$push","$each","removeRolesFromParent","_removeRoleFromParent","fields","addUsersToRoles","users","id","_normalizeOptions","_checkScopeName","scope","ifExists","user","_addUserToRole","setUserRoles","anyScope","selector","userId","res","parentRoles","Set","parentRole","add","delete","nestedRoles","removeUsersFromRoles","_removeUserFromRole","userIsInRole","filter","some","limit","getRolesForUser","fullObjects","onlyAssigned","onlyScoped","push","reduce","rev","current","getAllRoles","queryOptions","sort","getUsersInRole","ids","getUserAssignmentsForRole","a","_getUsersInRoleCursor","getGroupsForUser","_Roles","console","warn","getScopesForUser","apply","arguments","scopes","obi","renameScope","removeScope","name","trim","isParentOf","parentRoleName","childRoleName","rolesToCheck","pop","undefined","_normalizeScopeName","scopeName","call","module"],"sources":["packages/alanning:roles/roles/roles_common.js"],"sourcesContent":["/* global Meteor, Roles, Mongo */\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n *  - `_id`: role name\n *  - `children`: list of subdocuments:\n *    - `_id`\n *\n * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n *\n * Roles can have multiple parents and can be children (subroles) of multiple roles.\n *\n * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n *\n * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n * It's documents consist of\n *  - `_id`: Internal MongoDB id\n *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n *  - `user`: A user object, usually only contains the `_id` property\n *  - `scope`: scope name\n *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n *\n * @module Roles\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Mongo.Collection('roles')\n}\n\nif (!Meteor.roleAssignment) {\n  Meteor.roleAssignment = new Mongo.Collection('role-assignment')\n}\n\n/**\n * @class Roles\n */\nif (typeof Roles === 'undefined') {\n  Roles = {} // eslint-disable-line no-global-assign\n}\n\nlet getGroupsForUserDeprecationWarning = false\n\nObject.assign(Roles, {\n\n  /**\n   * Used as a global group (now scope) name. Not used anymore.\n   *\n   * @property GLOBAL_GROUP\n   * @static\n   * @deprecated\n   */\n  GLOBAL_GROUP: null,\n\n  /**\n   * Create a new role.\n   *\n   * @method createRole\n   * @param {String} roleName Name of role.\n   * @param {Object} [options] Options:\n   *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n   * @return {String} ID of the new role or null.\n   * @static\n   */\n  createRole: function (roleName, options) {\n    Roles._checkRoleName(roleName)\n\n    options = Object.assign({\n      unlessExists: false\n    }, options)\n\n    const result = Meteor.roles.upsert({ _id: roleName }, { $setOnInsert: { children: [] } })\n\n    if (!result.insertedId) {\n      if (options.unlessExists) return null\n      throw new Error('Role \\'' + roleName + '\\' already exists.')\n    }\n\n    return result.insertedId\n  },\n\n  /**\n   * Delete an existing role.\n   *\n   * If the role is set for any user, it is automatically unset.\n   *\n   * @method deleteRole\n   * @param {String} roleName Name of role.\n   * @static\n   */\n  deleteRole: function (roleName) {\n    let roles\n    let inheritedRoles\n\n    Roles._checkRoleName(roleName)\n\n    // Remove all assignments\n    Meteor.roleAssignment.remove({\n      'role._id': roleName\n    })\n\n    do {\n      // For all roles who have it as a dependency ...\n      roles = Roles._getParentRoleNames(Meteor.roles.findOne({ _id: roleName }))\n\n      Meteor.roles.find({ _id: { $in: roles } }).fetch().forEach(r => {\n        Meteor.roles.update({\n          _id: r._id\n        }, {\n          $pull: {\n            children: {\n              _id: roleName\n            }\n          }\n        })\n\n        inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({ _id: r._id }))\n        Meteor.roleAssignment.update({\n          'role._id': r._id\n        }, {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({ _id: r2 }))\n          }\n        }, { multi: true })\n      })\n    } while (roles.length > 0)\n\n    // And finally remove the role itself\n    Meteor.roles.remove({ _id: roleName })\n  },\n\n  /**\n   * Rename an existing role.\n   *\n   * @method renameRole\n   * @param {String} oldName Old name of a role.\n   * @param {String} newName New name of a role.\n   * @static\n   */\n  renameRole: function (oldName, newName) {\n    let count\n\n    Roles._checkRoleName(oldName)\n    Roles._checkRoleName(newName)\n\n    if (oldName === newName) return\n\n    const role = Meteor.roles.findOne({ _id: oldName })\n\n    if (!role) {\n      throw new Error('Role \\'' + oldName + '\\' does not exist.')\n    }\n\n    role._id = newName\n\n    Meteor.roles.insert(role)\n\n    do {\n      count = Meteor.roleAssignment.update({\n        'role._id': oldName\n      }, {\n        $set: {\n          'role._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    do {\n      count = Meteor.roleAssignment.update({\n        'inheritedRoles._id': oldName\n      }, {\n        $set: {\n          'inheritedRoles.$._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    do {\n      count = Meteor.roles.update({\n        'children._id': oldName\n      }, {\n        $set: {\n          'children.$._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    Meteor.roles.remove({ _id: oldName })\n  },\n\n  /**\n   * Add role parent to roles.\n   *\n   * Previous parents are kept (role can have multiple parents). For users which have the\n   * parent role set, new subroles are added automatically.\n   *\n   * @method addRolesToParent\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @static\n   */\n  addRolesToParent: function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    rolesNames.forEach(function (roleName) {\n      Roles._addRoleToParent(roleName, parentName)\n    })\n  },\n\n  /**\n   * @method _addRoleToParent\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @private\n   * @static\n   */\n  _addRoleToParent: function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // query to get role's children\n    const role = Meteor.roles.findOne({ _id: roleName })\n\n    if (!role) {\n      throw new Error('Role \\'' + roleName + '\\' does not exist.')\n    }\n\n    // detect cycles\n    if (Roles._getInheritedRoleNames(role).includes(parentName)) {\n      throw new Error('Roles \\'' + roleName + '\\' and \\'' + parentName + '\\' would form a cycle.')\n    }\n\n    const count = Meteor.roles.update({\n      _id: parentName,\n      'children._id': {\n        $ne: role._id\n      }\n    }, {\n      $push: {\n        children: {\n          _id: role._id\n        }\n      }\n    })\n\n    // if there was no change, parent role might not exist, or role is\n    // already a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    Meteor.roleAssignment.update({\n      'inheritedRoles._id': parentName\n    }, {\n      $push: {\n        inheritedRoles: { $each: [role._id, ...Roles._getInheritedRoleNames(role)].map(r => ({ _id: r })) }\n      }\n    }, { multi: true })\n  },\n\n  /**\n   * Remove role parent from roles.\n   *\n   * Other parents are kept (role can have multiple parents). For users which have the\n   * parent role set, removed subrole is removed automatically.\n   *\n   * @method removeRolesFromParent\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @static\n   */\n  removeRolesFromParent: function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    rolesNames.forEach(function (roleName) {\n      Roles._removeRoleFromParent(roleName, parentName)\n    })\n  },\n\n  /**\n   * @method _removeRoleFromParent\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @private\n   * @static\n   */\n  _removeRoleFromParent: function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // check for role existence\n    // this would not really be needed, but we are trying to match addRolesToParent\n    const role = Meteor.roles.findOne({ _id: roleName }, { fields: { _id: 1 } })\n\n    if (!role) {\n      throw new Error('Role \\'' + roleName + '\\' does not exist.')\n    }\n\n    const count = Meteor.roles.update({\n      _id: parentName\n    }, {\n      $pull: {\n        children: {\n          _id: role._id\n        }\n      }\n    })\n\n    // if there was no change, parent role might not exist, or role was\n    // already not a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    // For all roles who have had it as a dependency ...\n    const roles = [...Roles._getParentRoleNames(Meteor.roles.findOne({ _id: parentName })), parentName]\n\n    Meteor.roles.find({ _id: { $in: roles } }).fetch().forEach(r => {\n      const inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({ _id: r._id }))\n      Meteor.roleAssignment.update({\n        'role._id': r._id,\n        'inheritedRoles._id': role._id\n      }, {\n        $set: {\n          inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({ _id: r2 }))\n        }\n      }, { multi: true })\n    })\n  },\n\n  /**\n   * Add users to roles.\n   *\n   * Adds roles to existing roles for each user.\n   *\n   * @example\n   *     Roles.addUsersToRoles(userId, 'admin')\n   *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method addUsersToRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  addUsersToRoles: function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      ifExists: false\n    }, options)\n\n    users.forEach(function (user) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n\n      roles.forEach(function (role) {\n        Roles._addUserToRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Set users' roles.\n   *\n   * Replaces all existing roles with a new set of roles.\n   *\n   * @example\n   *     Roles.setUserRoles(userId, 'admin')\n   *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.setUserRoles([user1, user2], ['user','editor'])\n   *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method setUserRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  setUserRoles: function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      ifExists: false,\n      anyScope: false\n    }, options)\n\n    users.forEach(function (user) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n      // we first clear all roles for the user\n      const selector = { 'user._id': id }\n      if (!options.anyScope) {\n        selector.scope = options.scope\n      }\n\n      Meteor.roleAssignment.remove(selector)\n\n      // and then add all\n      roles.forEach(function (role) {\n        Roles._addUserToRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Add one user to one role.\n   *\n   * @method _addUserToRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @private\n   * @static\n   */\n  _addUserToRole: function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) {\n      return\n    }\n\n    const role = Meteor.roles.findOne({ _id: roleName }, { fields: { children: 1 } })\n\n    if (!role) {\n      if (options.ifExists) {\n        return []\n      } else {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.')\n      }\n    }\n\n    // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n    const res = Meteor.roleAssignment.upsert({\n      'user._id': userId,\n      'role._id': roleName,\n      scope: options.scope\n    }, {\n      $setOnInsert: {\n        user: { _id: userId },\n        role: { _id: roleName },\n        scope: options.scope\n      }\n    })\n\n    if (res.insertedId) {\n      Meteor.roleAssignment.update({ _id: res.insertedId }, {\n        $set: {\n          inheritedRoles: [roleName, ...Roles._getInheritedRoleNames(role)].map(r => ({ _id: r }))\n        }\n      })\n    }\n\n    return res\n  },\n\n  /**\n   * Returns an array of role names the given role name is a child of.\n   *\n   * @example\n   *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getParentRoleNames\n   * @param {object} role The role object\n   * @private\n   * @static\n   */\n  _getParentRoleNames: function (role) {\n    if (!role) {\n      return []\n    }\n\n    const parentRoles = new Set([role._id])\n\n    parentRoles.forEach(roleName => {\n      Meteor.roles.find({ 'children._id': roleName }).fetch().forEach(parentRole => {\n        parentRoles.add(parentRole._id)\n      })\n    })\n\n    parentRoles.delete(role._id)\n\n    return [...parentRoles]\n  },\n\n  /**\n   * Returns an array of role names the given role name is a parent of.\n   *\n   * @example\n   *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getInheritedRoleNames\n   * @param {object} role The role object\n   * @private\n   * @static\n   */\n  _getInheritedRoleNames: function (role) {\n    const inheritedRoles = new Set()\n    const nestedRoles = new Set([role])\n\n    nestedRoles.forEach(r => {\n      const roles = Meteor.roles.find({ _id: { $in: r.children.map(r => r._id) } }, { fields: { children: 1 } }).fetch()\n\n      roles.forEach(r2 => {\n        inheritedRoles.add(r2._id)\n        nestedRoles.add(r2)\n      })\n    })\n\n    return [...inheritedRoles]\n  },\n\n  /**\n   * Remove users from assigned roles.\n   *\n   * @example\n   *     Roles.removeUsersFromRoles(userId, 'admin')\n   *     Roles.removeUsersFromRoles([userId, user2], ['editor'])\n   *     Roles.removeUsersFromRoles(userId, ['user'], 'group1')\n   *\n   * @method removeUsersFromRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  removeUsersFromRoles: function (users, roles, options) {\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    users.forEach(function (user) {\n      if (!user) return\n\n      roles.forEach(function (role) {\n        let id\n        if (typeof user === 'object') {\n          id = user._id\n        } else {\n          id = user\n        }\n\n        Roles._removeUserFromRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Remove one user from one role.\n   *\n   * @method _removeUserFromRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @private\n   * @static\n   */\n  _removeUserFromRole: function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) return\n\n    const selector = {\n      'user._id': userId,\n      'role._id': roleName\n    }\n\n    if (!options.anyScope) {\n      selector.scope = options.scope\n    }\n\n    Meteor.roleAssignment.remove(selector)\n  },\n\n  /**\n   * Check if user has specified roles.\n   *\n   * @example\n   *     // global roles\n   *     Roles.userIsInRole(user, 'admin')\n   *     Roles.userIsInRole(user, ['admin','editor'])\n   *     Roles.userIsInRole(userId, 'admin')\n   *     Roles.userIsInRole(userId, ['admin','editor'])\n   *\n   *     // scope roles (global roles are still checked)\n   *     Roles.userIsInRole(user, 'admin', 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], {scope: 'group1'})\n   *\n   * @method userIsInRole\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n   *                             will return `true` if user is in _any_ role.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope; if supplied, limits check to just that scope\n   *     the user's global roles will always be checked whether scope is specified or not\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Boolean} `true` if user is in _any_ of the target roles\n   * @static\n   */\n  userIsInRole: function (user, roles, options) {\n    let id\n    options = Roles._normalizeOptions(options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    roles = roles.filter(r => r != null)\n\n    if (!roles.length) return false\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      anyScope: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return false\n    if (typeof id !== 'string') return false\n\n    const selector = { 'user._id': id }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope, null] }\n    }\n\n    return roles.some((roleName) => {\n      selector['inheritedRoles._id'] = roleName\n\n      return Meteor.roleAssignment.find(selector, { limit: 1 }).count() > 0\n    })\n  },\n\n  /**\n   * Retrieve user's roles.\n   *\n   * @method getRolesForUser\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n   *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n   *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n   *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n   *     result strongly dependent on the internal data structure of this plugin.\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Array} Array of user's roles, unsorted.\n   * @static\n   */\n  getRolesForUser: function (user, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      fullObjects: false,\n      onlyAssigned: false,\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = { 'user._id': id }\n    const filter = { fields: { 'inheritedRoles._id': 1 } }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    if (options.onlyAssigned) {\n      delete filter.fields['inheritedRoles._id']\n      filter.fields['role._id'] = 1\n    }\n\n    if (options.fullObjects) {\n      delete filter.fields\n    }\n\n    const roles = Meteor.roleAssignment.find(selector, filter).fetch()\n\n    if (options.fullObjects) {\n      return roles\n    }\n\n    return [...new Set(roles.reduce((rev, current) => {\n      if (current.inheritedRoles) {\n        return rev.concat(current.inheritedRoles.map(r => r._id))\n      } else if (current.role) {\n        rev.push(current.role._id)\n      }\n      return rev\n    }, []))]\n  },\n\n  /**\n   * Retrieve cursor of all existing roles.\n   *\n   * @method getAllRoles\n   * @param {Object} queryOptions Options which are passed directly\n   *                                through to `Meteor.roles.find(query, options)`.\n   * @return {Cursor} Cursor of existing roles.\n   * @static\n   */\n  getAllRoles: function (queryOptions) {\n    queryOptions = queryOptions || { sort: { _id: 1 } }\n\n    return Meteor.roles.find({}, queryOptions)\n  },\n\n  /**\n   * Retrieve all users who are in target role.\n   *\n   * Options:\n   *\n   * @method getUsersInRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.users.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.users.find(query, options)`\n   * @return {Cursor} Cursor of users in roles.\n   * @static\n   */\n  getUsersInRole: function (roles, options, queryOptions) {\n    const ids = Roles.getUserAssignmentsForRole(roles, options).fetch().map(a => a.user._id)\n\n    return Meteor.users.find({ _id: { $in: ids } }, ((options && options.queryOptions) || queryOptions) || {})\n  },\n\n  /**\n   * Retrieve all assignments of a user which are for the target role.\n   *\n   * Options:\n   *\n   * @method getUserAssignmentsForRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.roleAssignment.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Cursor} Cursor of user assignments for roles.\n   * @static\n   */\n  getUserAssignmentsForRole: function (roles, options) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign({\n      anyScope: false,\n      queryOptions: {}\n    }, options)\n\n    return Roles._getUsersInRoleCursor(roles, options, options.queryOptions)\n  },\n\n  /**\n   * @method _getUsersInRoleCursor\n   * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n   *                             returned which have at least one of the roles\n   *                             assigned but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [filter] Options which are passed directly\n   *                                through to `Meteor.roleAssignment.find(query, options)`\n   * @return {Object} Cursor to the assignment documents\n   * @private\n   * @static\n   */\n  _getUsersInRoleCursor: function (roles, options, filter) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign({\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    filter = Object.assign({\n      fields: { 'user._id': 1 }\n    }, filter)\n\n    const selector = { 'inheritedRoles._id': { $in: roles } }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    return Meteor.roleAssignment.find(selector, filter)\n  },\n\n  /**\n   * Deprecated. Use `getScopesForUser` instead.\n   *\n   * @method getGroupsForUser\n   * @static\n   * @deprecated\n   */\n  getGroupsForUser: function (...args) {\n    if (!getGroupsForUserDeprecationWarning) {\n      getGroupsForUserDeprecationWarning = true\n      console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.')\n    }\n\n    return Roles.getScopesForUser(...args)\n  },\n\n  /**\n   * Retrieve users scopes, if any.\n   *\n   * @method getScopesForUser\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} [roles] Name of roles to restrict scopes to.\n   *\n   * @return {Array} Array of user's scopes, unsorted.\n   * @static\n   */\n  getScopesForUser: function (user, roles) {\n    let id\n\n    if (roles && !Array.isArray(roles)) roles = [roles]\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id,\n      scope: { $ne: null }\n    }\n\n    if (roles) {\n      selector['inheritedRoles._id'] = { $in: roles }\n    }\n\n    const scopes = Meteor.roleAssignment.find(selector, { fields: { scope: 1 } }).fetch().map(obi => obi.scope)\n\n    return [...new Set(scopes)]\n  },\n\n  /**\n   * Rename a scope.\n   *\n   * Roles assigned with a given scope are changed to be under the new scope.\n   *\n   * @method renameScope\n   * @param {String} oldName Old name of a scope.\n   * @param {String} newName New name of a scope.\n   * @static\n   */\n  renameScope: function (oldName, newName) {\n    let count\n\n    Roles._checkScopeName(oldName)\n    Roles._checkScopeName(newName)\n\n    if (oldName === newName) return\n\n    do {\n      count = Meteor.roleAssignment.update({\n        scope: oldName\n      }, {\n        $set: {\n          scope: newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n  },\n\n  /**\n   * Remove a scope.\n   *\n   * Roles assigned with a given scope are removed.\n   *\n   * @method removeScope\n   * @param {String} name The name of a scope.\n   * @static\n   */\n  removeScope: function (name) {\n    Roles._checkScopeName(name)\n\n    Meteor.roleAssignment.remove({ scope: name })\n  },\n\n  /**\n   * Throw an exception if `roleName` is an invalid role name.\n   *\n   * @method _checkRoleName\n   * @param {String} roleName A role name to match against.\n   * @private\n   * @static\n   */\n  _checkRoleName: function (roleName) {\n    if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n      throw new Error('Invalid role name \\'' + roleName + '\\'.')\n    }\n  },\n\n  /**\n   * Find out if a role is an ancestor of another role.\n   *\n   * WARNING: If you check this on the client, please make sure all roles are published.\n   *\n   * @method isParentOf\n   * @param {String} parentRoleName The role you want to research.\n   * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n   * @static\n   */\n  isParentOf: function (parentRoleName, childRoleName) {\n    if (parentRoleName === childRoleName) {\n      return true\n    }\n\n    if (parentRoleName == null || childRoleName == null) {\n      return false\n    }\n\n    Roles._checkRoleName(parentRoleName)\n    Roles._checkRoleName(childRoleName)\n\n    let rolesToCheck = [parentRoleName]\n    while (rolesToCheck.length !== 0) {\n      const roleName = rolesToCheck.pop()\n\n      if (roleName === childRoleName) {\n        return true\n      }\n\n      const role = Meteor.roles.findOne({ _id: roleName })\n\n      // This should not happen, but this is a problem to address at some other time.\n      if (!role) continue\n\n      rolesToCheck = rolesToCheck.concat(role.children.map(r => r._id))\n    }\n\n    return false\n  },\n\n  /**\n   * Normalize options.\n   *\n   * @method _normalizeOptions\n   * @param {Object} options Options to normalize.\n   * @return {Object} Normalized options.\n   * @private\n   * @static\n   */\n  _normalizeOptions: function (options) {\n    options = options === undefined ? {} : options\n\n    if (options === null || typeof options === 'string') {\n      options = { scope: options }\n    }\n\n    options.scope = Roles._normalizeScopeName(options.scope)\n\n    return options\n  },\n\n  /**\n   * Normalize scope name.\n   *\n   * @method _normalizeScopeName\n   * @param {String} scopeName A scope name to normalize.\n   * @return {String} Normalized scope name.\n   * @private\n   * @static\n   */\n  _normalizeScopeName: function (scopeName) {\n    // map undefined and null to null\n    if (scopeName == null) {\n      return null\n    } else {\n      return scopeName\n    }\n  },\n\n  /**\n   * Throw an exception if `scopeName` is an invalid scope name.\n   *\n   * @method _checkRoleName\n   * @param {String} scopeName A scope name to match against.\n   * @private\n   * @static\n   */\n  _checkScopeName: function (scopeName) {\n    if (scopeName === null) return\n\n    if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n      throw new Error('Invalid scope name \\'' + scopeName + '\\'.')\n    }\n  }\n})\n"],"mappings":";EAAA,IAAIA,OAAO;EAACC,OAAO,CAACC,IAAI,CAAC,+BAA+B,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACJ,OAAO,GAACI,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAC,IAAIC,kBAAkB;EAACJ,OAAO,CAACC,IAAI,CAAC,0CAA0C,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACC,kBAAkB,GAACD,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAA1N;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAI,CAACE,MAAM,CAACC,KAAK,EAAE;IACjBD,MAAM,CAACC,KAAK,GAAG,IAAIC,KAAK,CAACC,UAAU,CAAC,OAAO,CAAC;EAC9C;EAEA,IAAI,CAACH,MAAM,CAACI,cAAc,EAAE;IAC1BJ,MAAM,CAACI,cAAc,GAAG,IAAIF,KAAK,CAACC,UAAU,CAAC,iBAAiB,CAAC;EACjE;;EAEA;AACA;AACA;EACA,IAAI,OAAOE,KAAK,KAAK,WAAW,EAAE;IAChCA,KAAK,GAAG,CAAC,CAAC,EAAC;EACb;EAEA,IAAIC,kCAAkC,GAAG,KAAK;EAE9CC,MAAM,CAACC,MAAM,CAACH,KAAK,EAAE;IAEnB;AACF;AACA;AACA;AACA;AACA;AACA;IACEI,YAAY,EAAE,IAAI;IAElB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,UAAU,EAAE,SAAAA,CAAUC,QAAQ,EAAEC,OAAO,EAAE;MACvCP,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAE9BC,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtBM,YAAY,EAAE;MAChB,CAAC,EAAEF,OAAO,CAAC;MAEX,IAAMG,MAAM,GAAGf,MAAM,CAACC,KAAK,CAACe,MAAM,CAAC;QAAEC,GAAG,EAAEN;MAAS,CAAC,EAAE;QAAEO,YAAY,EAAE;UAAEC,QAAQ,EAAE;QAAG;MAAE,CAAC,CAAC;MAEzF,IAAI,CAACJ,MAAM,CAACK,UAAU,EAAE;QACtB,IAAIR,OAAO,CAACE,YAAY,EAAE,OAAO,IAAI;QACrC,MAAM,IAAIO,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;MAC9D;MAEA,OAAOI,MAAM,CAACK,UAAU;IAC1B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,UAAU,EAAE,SAAAA,CAAUX,QAAQ,EAAE;MAC9B,IAAIV,KAAK;MACT,IAAIsB,cAAc;MAElBlB,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;;MAE9B;MACAX,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC;QAC3B,UAAU,EAAEb;MACd,CAAC,CAAC;MAEF,GAAG;QACD;QACAV,KAAK,GAAGI,KAAK,CAACoB,mBAAmB,CAACzB,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;UAAET,GAAG,EAAEN;QAAS,CAAC,CAAC,CAAC;QAE1EX,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;UAAEV,GAAG,EAAE;YAAEW,GAAG,EAAE3B;UAAM;QAAE,CAAC,CAAC,CAAC4B,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,UAAAC,CAAC,EAAI;UAC9D/B,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;YAClBf,GAAG,EAAEc,CAAC,CAACd;UACT,CAAC,EAAE;YACDgB,KAAK,EAAE;cACLd,QAAQ,EAAE;gBACRF,GAAG,EAAEN;cACP;YACF;UACF,CAAC,CAAC;UAEFY,cAAc,GAAGlB,KAAK,CAAC6B,sBAAsB,CAAClC,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;YAAET,GAAG,EAAEc,CAAC,CAACd;UAAI,CAAC,CAAC,CAAC;UACnFjB,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;YAC3B,UAAU,EAAED,CAAC,CAACd;UAChB,CAAC,EAAE;YACDkB,IAAI,EAAE;cACJZ,cAAc,EAAE,CAACQ,CAAC,CAACd,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKwB,cAAc,GAAEc,GAAG,CAAC,UAAAC,EAAE;gBAAA,OAAK;kBAAErB,GAAG,EAAEqB;gBAAG,CAAC;cAAA,CAAC;YACpE;UACF,CAAC,EAAE;YAAEC,KAAK,EAAE;UAAK,CAAC,CAAC;QACrB,CAAC,CAAC;MACJ,CAAC,QAAQtC,KAAK,CAACuC,MAAM,GAAG,CAAC;;MAEzB;MACAxC,MAAM,CAACC,KAAK,CAACuB,MAAM,CAAC;QAAEP,GAAG,EAAEN;MAAS,CAAC,CAAC;IACxC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE8B,UAAU,EAAE,SAAAA,CAAUC,OAAO,EAAEC,OAAO,EAAE;MACtC,IAAIC,KAAK;MAETvC,KAAK,CAACQ,cAAc,CAAC6B,OAAO,CAAC;MAC7BrC,KAAK,CAACQ,cAAc,CAAC8B,OAAO,CAAC;MAE7B,IAAID,OAAO,KAAKC,OAAO,EAAE;MAEzB,IAAME,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEyB;MAAQ,CAAC,CAAC;MAEnD,IAAI,CAACG,IAAI,EAAE;QACT,MAAM,IAAIxB,KAAK,CAAC,SAAS,GAAGqB,OAAO,GAAG,oBAAoB,CAAC;MAC7D;MAEAG,IAAI,CAAC5B,GAAG,GAAG0B,OAAO;MAElB3C,MAAM,CAACC,KAAK,CAAC6C,MAAM,CAACD,IAAI,CAAC;MAEzB,GAAG;QACDD,KAAK,GAAG5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UACnC,UAAU,EAAEU;QACd,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ,UAAU,EAAEQ;UACd;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB,GAAG;QACDA,KAAK,GAAG5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UACnC,oBAAoB,EAAEU;QACxB,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ,sBAAsB,EAAEQ;UAC1B;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB,GAAG;QACDA,KAAK,GAAG5C,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;UAC1B,cAAc,EAAEU;QAClB,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ,gBAAgB,EAAEQ;UACpB;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB5C,MAAM,CAACC,KAAK,CAACuB,MAAM,CAAC;QAAEP,GAAG,EAAEyB;MAAQ,CAAC,CAAC;IACvC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEK,gBAAgB,EAAE,SAAAA,CAAUC,UAAU,EAAEC,UAAU,EAAE;MAClD;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;MAEzDA,UAAU,CAAClB,OAAO,CAAC,UAAUnB,QAAQ,EAAE;QACrCN,KAAK,CAAC+C,gBAAgB,CAACzC,QAAQ,EAAEsC,UAAU,CAAC;MAC9C,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;IACEG,gBAAgB,EAAE,SAAAA,CAAUzC,QAAQ,EAAEsC,UAAU,EAAE;MAChD5C,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAACQ,cAAc,CAACoC,UAAU,CAAC;;MAEhC;MACA,IAAMJ,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEN;MAAS,CAAC,CAAC;MAEpD,IAAI,CAACkC,IAAI,EAAE;QACT,MAAM,IAAIxB,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;MAC9D;;MAEA;MACA,IAAIN,KAAK,CAAC6B,sBAAsB,CAACW,IAAI,CAAC,CAACQ,QAAQ,CAACJ,UAAU,CAAC,EAAE;QAC3D,MAAM,IAAI5B,KAAK,CAAC,UAAU,GAAGV,QAAQ,GAAG,WAAW,GAAGsC,UAAU,GAAG,wBAAwB,CAAC;MAC9F;MAEA,IAAML,KAAK,GAAG5C,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;QAChCf,GAAG,EAAEgC,UAAU;QACf,cAAc,EAAE;UACdK,GAAG,EAAET,IAAI,CAAC5B;QACZ;MACF,CAAC,EAAE;QACDsC,KAAK,EAAE;UACLpC,QAAQ,EAAE;YACRF,GAAG,EAAE4B,IAAI,CAAC5B;UACZ;QACF;MACF,CAAC,CAAC;;MAEF;MACA;MACA,IAAI,CAAC2B,KAAK,EAAE;MAEZ5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;QAC3B,oBAAoB,EAAEiB;MACxB,CAAC,EAAE;QACDM,KAAK,EAAE;UACLhC,cAAc,EAAE;YAAEiC,KAAK,EAAE,CAACX,IAAI,CAAC5B,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKM,KAAK,CAAC6B,sBAAsB,CAACW,IAAI,CAAC,GAAER,GAAG,CAAC,UAAAN,CAAC;cAAA,OAAK;gBAAEd,GAAG,EAAEc;cAAE,CAAC;YAAA,CAAC;UAAE;QACpG;MACF,CAAC,EAAE;QAAEQ,KAAK,EAAE;MAAK,CAAC,CAAC;IACrB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEkB,qBAAqB,EAAE,SAAAA,CAAUT,UAAU,EAAEC,UAAU,EAAE;MACvD;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;MAEzDA,UAAU,CAAClB,OAAO,CAAC,UAAUnB,QAAQ,EAAE;QACrCN,KAAK,CAACqD,qBAAqB,CAAC/C,QAAQ,EAAEsC,UAAU,CAAC;MACnD,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;IACES,qBAAqB,EAAE,SAAAA,CAAU/C,QAAQ,EAAEsC,UAAU,EAAE;MACrD5C,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAACQ,cAAc,CAACoC,UAAU,CAAC;;MAEhC;MACA;MACA,IAAMJ,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEN;MAAS,CAAC,EAAE;QAAEgD,MAAM,EAAE;UAAE1C,GAAG,EAAE;QAAE;MAAE,CAAC,CAAC;MAE5E,IAAI,CAAC4B,IAAI,EAAE;QACT,MAAM,IAAIxB,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;MAC9D;MAEA,IAAMiC,KAAK,GAAG5C,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;QAChCf,GAAG,EAAEgC;MACP,CAAC,EAAE;QACDhB,KAAK,EAAE;UACLd,QAAQ,EAAE;YACRF,GAAG,EAAE4B,IAAI,CAAC5B;UACZ;QACF;MACF,CAAC,CAAC;;MAEF;MACA;MACA,IAAI,CAAC2B,KAAK,EAAE;;MAEZ;MACA,IAAM3C,KAAK,MAAAmC,MAAA,CAAArC,kBAAA,CAAOM,KAAK,CAACoB,mBAAmB,CAACzB,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEgC;MAAW,CAAC,CAAC,CAAC,IAAEA,UAAU,EAAC;MAEnGjD,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;QAAEV,GAAG,EAAE;UAAEW,GAAG,EAAE3B;QAAM;MAAE,CAAC,CAAC,CAAC4B,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,UAAAC,CAAC,EAAI;QAC9D,IAAMR,cAAc,GAAGlB,KAAK,CAAC6B,sBAAsB,CAAClC,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;UAAET,GAAG,EAAEc,CAAC,CAACd;QAAI,CAAC,CAAC,CAAC;QACzFjB,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UAC3B,UAAU,EAAED,CAAC,CAACd,GAAG;UACjB,oBAAoB,EAAE4B,IAAI,CAAC5B;QAC7B,CAAC,EAAE;UACDkB,IAAI,EAAE;YACJZ,cAAc,EAAE,CAACQ,CAAC,CAACd,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKwB,cAAc,GAAEc,GAAG,CAAC,UAAAC,EAAE;cAAA,OAAK;gBAAErB,GAAG,EAAEqB;cAAG,CAAC;YAAA,CAAC;UACpE;QACF,CAAC,EAAE;UAAEC,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEqB,eAAe,EAAE,SAAAA,CAAUC,KAAK,EAAE5D,KAAK,EAAEW,OAAO,EAAE;MAChD,IAAIkD,EAAE;MAEN,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIxC,KAAK,CAAC,0BAA0B,CAAC;MACvD,IAAI,CAACpB,KAAK,EAAE,MAAM,IAAIoB,KAAK,CAAC,0BAA0B,CAAC;MAEvDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB0D,QAAQ,EAAE;MACZ,CAAC,EAAEtD,OAAO,CAAC;MAEXiD,KAAK,CAAC/B,OAAO,CAAC,UAAUqC,IAAI,EAAE;QAC5B,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;UAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;QACf,CAAC,MAAM;UACL6C,EAAE,GAAGK,IAAI;QACX;QAEAlE,KAAK,CAAC6B,OAAO,CAAC,UAAUe,IAAI,EAAE;UAC5BxC,KAAK,CAAC+D,cAAc,CAACN,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;QACzC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEyD,YAAY,EAAE,SAAAA,CAAUR,KAAK,EAAE5D,KAAK,EAAEW,OAAO,EAAE;MAC7C,IAAIkD,EAAE;MAEN,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIxC,KAAK,CAAC,0BAA0B,CAAC;MACvD,IAAI,CAACpB,KAAK,EAAE,MAAM,IAAIoB,KAAK,CAAC,0BAA0B,CAAC;MAEvDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB0D,QAAQ,EAAE,KAAK;QACfI,QAAQ,EAAE;MACZ,CAAC,EAAE1D,OAAO,CAAC;MAEXiD,KAAK,CAAC/B,OAAO,CAAC,UAAUqC,IAAI,EAAE;QAC5B,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;UAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;QACf,CAAC,MAAM;UACL6C,EAAE,GAAGK,IAAI;QACX;QACA;QACA,IAAMI,QAAQ,GAAG;UAAE,UAAU,EAAET;QAAG,CAAC;QACnC,IAAI,CAAClD,OAAO,CAAC0D,QAAQ,EAAE;UACrBC,QAAQ,CAACN,KAAK,GAAGrD,OAAO,CAACqD,KAAK;QAChC;QAEAjE,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC+C,QAAQ,CAAC;;QAEtC;QACAtE,KAAK,CAAC6B,OAAO,CAAC,UAAUe,IAAI,EAAE;UAC5BxC,KAAK,CAAC+D,cAAc,CAACN,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;QACzC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEwD,cAAc,EAAE,SAAAA,CAAUI,MAAM,EAAE7D,QAAQ,EAAEC,OAAO,EAAE;MACnDP,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpC,IAAI,CAACO,MAAM,EAAE;QACX;MACF;MAEA,IAAM3B,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEN;MAAS,CAAC,EAAE;QAAEgD,MAAM,EAAE;UAAExC,QAAQ,EAAE;QAAE;MAAE,CAAC,CAAC;MAEjF,IAAI,CAAC0B,IAAI,EAAE;QACT,IAAIjC,OAAO,CAACsD,QAAQ,EAAE;UACpB,OAAO,EAAE;QACX,CAAC,MAAM;UACL,MAAM,IAAI7C,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;QAC9D;MACF;;MAEA;MACA,IAAM8D,GAAG,GAAGzE,MAAM,CAACI,cAAc,CAACY,MAAM,CAAC;QACvC,UAAU,EAAEwD,MAAM;QAClB,UAAU,EAAE7D,QAAQ;QACpBsD,KAAK,EAAErD,OAAO,CAACqD;MACjB,CAAC,EAAE;QACD/C,YAAY,EAAE;UACZiD,IAAI,EAAE;YAAElD,GAAG,EAAEuD;UAAO,CAAC;UACrB3B,IAAI,EAAE;YAAE5B,GAAG,EAAEN;UAAS,CAAC;UACvBsD,KAAK,EAAErD,OAAO,CAACqD;QACjB;MACF,CAAC,CAAC;MAEF,IAAIQ,GAAG,CAACrD,UAAU,EAAE;QAClBpB,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UAAEf,GAAG,EAAEwD,GAAG,CAACrD;QAAW,CAAC,EAAE;UACpDe,IAAI,EAAE;YACJZ,cAAc,EAAE,CAACZ,QAAQ,EAAAyB,MAAA,CAAArC,kBAAA,CAAKM,KAAK,CAAC6B,sBAAsB,CAACW,IAAI,CAAC,GAAER,GAAG,CAAC,UAAAN,CAAC;cAAA,OAAK;gBAAEd,GAAG,EAAEc;cAAE,CAAC;YAAA,CAAC;UACzF;QACF,CAAC,CAAC;MACJ;MAEA,OAAO0C,GAAG;IACZ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEhD,mBAAmB,EAAE,SAAAA,CAAUoB,IAAI,EAAE;MACnC,IAAI,CAACA,IAAI,EAAE;QACT,OAAO,EAAE;MACX;MAEA,IAAM6B,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC9B,IAAI,CAAC5B,GAAG,CAAC,CAAC;MAEvCyD,WAAW,CAAC5C,OAAO,CAAC,UAAAnB,QAAQ,EAAI;QAC9BX,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;UAAE,cAAc,EAAEhB;QAAS,CAAC,CAAC,CAACkB,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,UAAA8C,UAAU,EAAI;UAC5EF,WAAW,CAACG,GAAG,CAACD,UAAU,CAAC3D,GAAG,CAAC;QACjC,CAAC,CAAC;MACJ,CAAC,CAAC;MAEFyD,WAAW,CAACI,MAAM,CAACjC,IAAI,CAAC5B,GAAG,CAAC;MAE5B,OAAAlB,kBAAA,CAAW2E,WAAW;IACxB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACExC,sBAAsB,EAAE,SAAAA,CAAUW,IAAI,EAAE;MACtC,IAAMtB,cAAc,GAAG,IAAIoD,GAAG,CAAC,CAAC;MAChC,IAAMI,WAAW,GAAG,IAAIJ,GAAG,CAAC,CAAC9B,IAAI,CAAC,CAAC;MAEnCkC,WAAW,CAACjD,OAAO,CAAC,UAAAC,CAAC,EAAI;QACvB,IAAM9B,KAAK,GAAGD,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;UAAEV,GAAG,EAAE;YAAEW,GAAG,EAAEG,CAAC,CAACZ,QAAQ,CAACkB,GAAG,CAAC,UAAAN,CAAC;cAAA,OAAIA,CAAC,CAACd,GAAG;YAAA;UAAE;QAAE,CAAC,EAAE;UAAE0C,MAAM,EAAE;YAAExC,QAAQ,EAAE;UAAE;QAAE,CAAC,CAAC,CAACU,KAAK,CAAC,CAAC;QAElH5B,KAAK,CAAC6B,OAAO,CAAC,UAAAQ,EAAE,EAAI;UAClBf,cAAc,CAACsD,GAAG,CAACvC,EAAE,CAACrB,GAAG,CAAC;UAC1B8D,WAAW,CAACF,GAAG,CAACvC,EAAE,CAAC;QACrB,CAAC,CAAC;MACJ,CAAC,CAAC;MAEF,OAAAvC,kBAAA,CAAWwB,cAAc;IAC3B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEyD,oBAAoB,EAAE,SAAAA,CAAUnB,KAAK,EAAE5D,KAAK,EAAEW,OAAO,EAAE;MACrD,IAAI,CAACiD,KAAK,EAAE,MAAM,IAAIxC,KAAK,CAAC,0BAA0B,CAAC;MACvD,IAAI,CAACpB,KAAK,EAAE,MAAM,IAAIoB,KAAK,CAAC,0BAA0B,CAAC;MAEvDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCJ,KAAK,CAAC/B,OAAO,CAAC,UAAUqC,IAAI,EAAE;QAC5B,IAAI,CAACA,IAAI,EAAE;QAEXlE,KAAK,CAAC6B,OAAO,CAAC,UAAUe,IAAI,EAAE;UAC5B,IAAIiB,EAAE;UACN,IAAIpE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;YAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;UACf,CAAC,MAAM;YACL6C,EAAE,GAAGK,IAAI;UACX;UAEA9D,KAAK,CAAC4E,mBAAmB,CAACnB,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;QAC9C,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEqE,mBAAmB,EAAE,SAAAA,CAAUT,MAAM,EAAE7D,QAAQ,EAAEC,OAAO,EAAE;MACxDP,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpC,IAAI,CAACO,MAAM,EAAE;MAEb,IAAMD,QAAQ,GAAG;QACf,UAAU,EAAEC,MAAM;QAClB,UAAU,EAAE7D;MACd,CAAC;MAED,IAAI,CAACC,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAGrD,OAAO,CAACqD,KAAK;MAChC;MAEAjE,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC+C,QAAQ,CAAC;IACxC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEW,YAAY,EAAE,SAAAA,CAAUf,IAAI,EAAElE,KAAK,EAAEW,OAAO,EAAE;MAC5C,IAAIkD,EAAE;MACNlD,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CA,KAAK,GAAGA,KAAK,CAACkF,MAAM,CAAC,UAAApD,CAAC;QAAA,OAAIA,CAAC,IAAI,IAAI;MAAA,EAAC;MAEpC,IAAI,CAAC9B,KAAK,CAACuC,MAAM,EAAE,OAAO,KAAK;MAE/BnC,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB8D,QAAQ,EAAE;MACZ,CAAC,EAAE1D,OAAO,CAAC;MAEX,IAAIuD,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;MACf,CAAC,MAAM;QACL6C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,KAAK;MACrB,IAAI,OAAOA,EAAE,KAAK,QAAQ,EAAE,OAAO,KAAK;MAExC,IAAMS,QAAQ,GAAG;QAAE,UAAU,EAAET;MAAG,CAAC;MAEnC,IAAI,CAAClD,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK,EAAE,IAAI;QAAE,CAAC;MACjD;MAEA,OAAOhE,KAAK,CAACmF,IAAI,CAAC,UAACzE,QAAQ,EAAK;QAC9B4D,QAAQ,CAAC,oBAAoB,CAAC,GAAG5D,QAAQ;QAEzC,OAAOX,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAE;UAAEc,KAAK,EAAE;QAAE,CAAC,CAAC,CAACzC,KAAK,CAAC,CAAC,GAAG,CAAC;MACvE,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE0C,eAAe,EAAE,SAAAA,CAAUnB,IAAI,EAAEvD,OAAO,EAAE;MACxC,IAAIkD,EAAE;MAENlD,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CP,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB+E,WAAW,EAAE,KAAK;QAClBC,YAAY,EAAE,KAAK;QACnBlB,QAAQ,EAAE,KAAK;QACfmB,UAAU,EAAE;MACd,CAAC,EAAE7E,OAAO,CAAC;MAEX,IAAIuD,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;MACf,CAAC,MAAM;QACL6C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,EAAE;MAElB,IAAMS,QAAQ,GAAG;QAAE,UAAU,EAAET;MAAG,CAAC;MACnC,IAAMqB,MAAM,GAAG;QAAExB,MAAM,EAAE;UAAE,oBAAoB,EAAE;QAAE;MAAE,CAAC;MAEtD,IAAI,CAAC/C,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK;QAAE,CAAC;QAEzC,IAAI,CAACrD,OAAO,CAAC6E,UAAU,EAAE;UACvBlB,QAAQ,CAACN,KAAK,CAACrC,GAAG,CAAC8D,IAAI,CAAC,IAAI,CAAC;QAC/B;MACF;MAEA,IAAI9E,OAAO,CAAC4E,YAAY,EAAE;QACxB,OAAOL,MAAM,CAACxB,MAAM,CAAC,oBAAoB,CAAC;QAC1CwB,MAAM,CAACxB,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;MAC/B;MAEA,IAAI/C,OAAO,CAAC2E,WAAW,EAAE;QACvB,OAAOJ,MAAM,CAACxB,MAAM;MACtB;MAEA,IAAM1D,KAAK,GAAGD,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAEY,MAAM,CAAC,CAACtD,KAAK,CAAC,CAAC;MAElE,IAAIjB,OAAO,CAAC2E,WAAW,EAAE;QACvB,OAAOtF,KAAK;MACd;MAEA,OAAAF,kBAAA,CAAW,IAAI4E,GAAG,CAAC1E,KAAK,CAAC0F,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO,EAAK;QAChD,IAAIA,OAAO,CAACtE,cAAc,EAAE;UAC1B,OAAOqE,GAAG,CAACxD,MAAM,CAACyD,OAAO,CAACtE,cAAc,CAACc,GAAG,CAAC,UAAAN,CAAC;YAAA,OAAIA,CAAC,CAACd,GAAG;UAAA,EAAC,CAAC;QAC3D,CAAC,MAAM,IAAI4E,OAAO,CAAChD,IAAI,EAAE;UACvB+C,GAAG,CAACF,IAAI,CAACG,OAAO,CAAChD,IAAI,CAAC5B,GAAG,CAAC;QAC5B;QACA,OAAO2E,GAAG;MACZ,CAAC,EAAE,EAAE,CAAC,CAAC;IACT,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,WAAW,EAAE,SAAAA,CAAUC,YAAY,EAAE;MACnCA,YAAY,GAAGA,YAAY,IAAI;QAAEC,IAAI,EAAE;UAAE/E,GAAG,EAAE;QAAE;MAAE,CAAC;MAEnD,OAAOjB,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC,CAAC,CAAC,EAAEoE,YAAY,CAAC;IAC5C,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,cAAc,EAAE,SAAAA,CAAUhG,KAAK,EAAEW,OAAO,EAAEmF,YAAY,EAAE;MACtD,IAAMG,GAAG,GAAG7F,KAAK,CAAC8F,yBAAyB,CAAClG,KAAK,EAAEW,OAAO,CAAC,CAACiB,KAAK,CAAC,CAAC,CAACQ,GAAG,CAAC,UAAA+D,CAAC;QAAA,OAAIA,CAAC,CAACjC,IAAI,CAAClD,GAAG;MAAA,EAAC;MAExF,OAAOjB,MAAM,CAAC6D,KAAK,CAAClC,IAAI,CAAC;QAAEV,GAAG,EAAE;UAAEW,GAAG,EAAEsE;QAAI;MAAE,CAAC,EAAItF,OAAO,IAAIA,OAAO,CAACmF,YAAY,IAAKA,YAAY,IAAK,CAAC,CAAC,CAAC;IAC5G,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEI,yBAAyB,EAAE,SAAAA,CAAUlG,KAAK,EAAEW,OAAO,EAAE;MACnDA,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB8D,QAAQ,EAAE,KAAK;QACfyB,YAAY,EAAE,CAAC;MACjB,CAAC,EAAEnF,OAAO,CAAC;MAEX,OAAOP,KAAK,CAACgG,qBAAqB,CAACpG,KAAK,EAAEW,OAAO,EAAEA,OAAO,CAACmF,YAAY,CAAC;IAC1E,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEM,qBAAqB,EAAE,SAAAA,CAAUpG,KAAK,EAAEW,OAAO,EAAEuE,MAAM,EAAE;MACvDvE,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB8D,QAAQ,EAAE,KAAK;QACfmB,UAAU,EAAE;MACd,CAAC,EAAE7E,OAAO,CAAC;;MAEX;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCkB,MAAM,GAAG5E,MAAM,CAACC,MAAM,CAAC;QACrBmD,MAAM,EAAE;UAAE,UAAU,EAAE;QAAE;MAC1B,CAAC,EAAEwB,MAAM,CAAC;MAEV,IAAMZ,QAAQ,GAAG;QAAE,oBAAoB,EAAE;UAAE3C,GAAG,EAAE3B;QAAM;MAAE,CAAC;MAEzD,IAAI,CAACW,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK;QAAE,CAAC;QAEzC,IAAI,CAACrD,OAAO,CAAC6E,UAAU,EAAE;UACvBlB,QAAQ,CAACN,KAAK,CAACrC,GAAG,CAAC8D,IAAI,CAAC,IAAI,CAAC;QAC/B;MACF;MAEA,OAAO1F,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAEY,MAAM,CAAC;IACrD,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;IACEmB,gBAAgB,EAAE,SAAAA,CAAA,EAAmB;MAAA,IAAAC,MAAA;MACnC,IAAI,CAACjG,kCAAkC,EAAE;QACvCA,kCAAkC,GAAG,IAAI;QACzCkG,OAAO,IAAIA,OAAO,CAACC,IAAI,CAAC,qEAAqE,CAAC;MAChG;MAEA,OAAO,CAAAF,MAAA,GAAAlG,KAAK,EAACqG,gBAAgB,CAAAC,KAAA,CAAAJ,MAAA,EAAAK,SAAQ,CAAC;IACxC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEF,gBAAgB,EAAE,SAAAA,CAAUvC,IAAI,EAAElE,KAAK,EAAE;MACvC,IAAI6D,EAAE;MAEN,IAAI7D,KAAK,IAAI,CAACiD,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAEnD,IAAIkE,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;MACf,CAAC,MAAM;QACL6C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,EAAE;MAElB,IAAMS,QAAQ,GAAG;QACf,UAAU,EAAET,EAAE;QACdG,KAAK,EAAE;UAAEX,GAAG,EAAE;QAAK;MACrB,CAAC;MAED,IAAIrD,KAAK,EAAE;QACTsE,QAAQ,CAAC,oBAAoB,CAAC,GAAG;UAAE3C,GAAG,EAAE3B;QAAM,CAAC;MACjD;MAEA,IAAM4G,MAAM,GAAG7G,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAE;QAAEZ,MAAM,EAAE;UAAEM,KAAK,EAAE;QAAE;MAAE,CAAC,CAAC,CAACpC,KAAK,CAAC,CAAC,CAACQ,GAAG,CAAC,UAAAyE,GAAG;QAAA,OAAIA,GAAG,CAAC7C,KAAK;MAAA,EAAC;MAE3G,OAAAlE,kBAAA,CAAW,IAAI4E,GAAG,CAACkC,MAAM,CAAC;IAC5B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,WAAW,EAAE,SAAAA,CAAUrE,OAAO,EAAEC,OAAO,EAAE;MACvC,IAAIC,KAAK;MAETvC,KAAK,CAAC2D,eAAe,CAACtB,OAAO,CAAC;MAC9BrC,KAAK,CAAC2D,eAAe,CAACrB,OAAO,CAAC;MAE9B,IAAID,OAAO,KAAKC,OAAO,EAAE;MAEzB,GAAG;QACDC,KAAK,GAAG5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UACnCiC,KAAK,EAAEvB;QACT,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ8B,KAAK,EAAEtB;UACT;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;IACpB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEoE,WAAW,EAAE,SAAAA,CAAUC,IAAI,EAAE;MAC3B5G,KAAK,CAAC2D,eAAe,CAACiD,IAAI,CAAC;MAE3BjH,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC;QAAEyC,KAAK,EAAEgD;MAAK,CAAC,CAAC;IAC/C,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACEpG,cAAc,EAAE,SAAAA,CAAUF,QAAQ,EAAE;MAClC,IAAI,CAACA,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,CAACuG,IAAI,CAAC,CAAC,KAAKvG,QAAQ,EAAE;QAC7E,MAAM,IAAIU,KAAK,CAAC,sBAAsB,GAAGV,QAAQ,GAAG,KAAK,CAAC;MAC5D;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEwG,UAAU,EAAE,SAAAA,CAAUC,cAAc,EAAEC,aAAa,EAAE;MACnD,IAAID,cAAc,KAAKC,aAAa,EAAE;QACpC,OAAO,IAAI;MACb;MAEA,IAAID,cAAc,IAAI,IAAI,IAAIC,aAAa,IAAI,IAAI,EAAE;QACnD,OAAO,KAAK;MACd;MAEAhH,KAAK,CAACQ,cAAc,CAACuG,cAAc,CAAC;MACpC/G,KAAK,CAACQ,cAAc,CAACwG,aAAa,CAAC;MAEnC,IAAIC,YAAY,GAAG,CAACF,cAAc,CAAC;MACnC,OAAOE,YAAY,CAAC9E,MAAM,KAAK,CAAC,EAAE;QAChC,IAAM7B,QAAQ,GAAG2G,YAAY,CAACC,GAAG,CAAC,CAAC;QAEnC,IAAI5G,QAAQ,KAAK0G,aAAa,EAAE;UAC9B,OAAO,IAAI;QACb;QAEA,IAAMxE,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;UAAET,GAAG,EAAEN;QAAS,CAAC,CAAC;;QAEpD;QACA,IAAI,CAACkC,IAAI,EAAE;QAEXyE,YAAY,GAAGA,YAAY,CAAClF,MAAM,CAACS,IAAI,CAAC1B,QAAQ,CAACkB,GAAG,CAAC,UAAAN,CAAC;UAAA,OAAIA,CAAC,CAACd,GAAG;QAAA,EAAC,CAAC;MACnE;MAEA,OAAO,KAAK;IACd,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE8C,iBAAiB,EAAE,SAAAA,CAAUnD,OAAO,EAAE;MACpCA,OAAO,GAAGA,OAAO,KAAK4G,SAAS,GAAG,CAAC,CAAC,GAAG5G,OAAO;MAE9C,IAAIA,OAAO,KAAK,IAAI,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QACnDA,OAAO,GAAG;UAAEqD,KAAK,EAAErD;QAAQ,CAAC;MAC9B;MAEAA,OAAO,CAACqD,KAAK,GAAG5D,KAAK,CAACoH,mBAAmB,CAAC7G,OAAO,CAACqD,KAAK,CAAC;MAExD,OAAOrD,OAAO;IAChB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE6G,mBAAmB,EAAE,SAAAA,CAAUC,SAAS,EAAE;MACxC;MACA,IAAIA,SAAS,IAAI,IAAI,EAAE;QACrB,OAAO,IAAI;MACb,CAAC,MAAM;QACL,OAAOA,SAAS;MAClB;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE1D,eAAe,EAAE,SAAAA,CAAU0D,SAAS,EAAE;MACpC,IAAIA,SAAS,KAAK,IAAI,EAAE;MAExB,IAAI,CAACA,SAAS,IAAI,OAAOA,SAAS,KAAK,QAAQ,IAAIA,SAAS,CAACR,IAAI,CAAC,CAAC,KAAKQ,SAAS,EAAE;QACjF,MAAM,IAAIrG,KAAK,CAAC,uBAAuB,GAAGqG,SAAS,GAAG,KAAK,CAAC;MAC9D;IACF;EACF,CAAC,CAAC;AAAA,EAAAC,IAAA,OAAAC,MAAA"},"sourceType":"module","externalDependencies":{},"hash":"af44c7c38f2c708e708c53a9c5309291799551d9"}
