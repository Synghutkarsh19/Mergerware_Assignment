{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"D:\\mergerware\\loan-management-app\\packages\\blaze\\domrange.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/blaze/domrange.js","filename":"D:\\mergerware\\loan-management-app\\packages\\blaze\\domrange.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"D:\\mergerware\\loan-management-app","root":"D:\\mergerware\\loan-management-app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"D:\\mergerware\\loan-management-app\\packages\\blaze\\domrange.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/blaze/domrange.js"}},"code":"// A constant empty array (frozen if the JS engine supports it).\nvar _emptyArray = Object.freeze ? Object.freeze([]) : [];\n\n// `[new] Blaze._DOMRange([nodeAndRangeArray])`\n//\n// A DOMRange consists of an array of consecutive nodes and DOMRanges,\n// which may be replaced at any time with a new array.  If the DOMRange\n// has been attached to the DOM at some location, then updating\n// the array will cause the DOM to be updated at that location.\nBlaze._DOMRange = function (nodeAndRangeArray) {\n  if (!(this instanceof DOMRange))\n    // called without `new`\n    return new DOMRange(nodeAndRangeArray);\n  var members = nodeAndRangeArray || _emptyArray;\n  if (!(members && typeof members.length === 'number')) throw new Error(\"Expected array\");\n  for (var i = 0; i < members.length; i++) this._memberIn(members[i]);\n  this.members = members;\n  this.emptyRangePlaceholder = null;\n  this.attached = false;\n  this.parentElement = null;\n  this.parentRange = null;\n  this.attachedCallbacks = _emptyArray;\n};\nvar DOMRange = Blaze._DOMRange;\n\n// In IE 8, don't use empty text nodes as placeholders\n// in empty DOMRanges, use comment nodes instead.  Using\n// empty text nodes in modern browsers is great because\n// it doesn't clutter the web inspector.  In IE 8, however,\n// it seems to lead in some roundabout way to the OAuth\n// pop-up crashing the browser completely.  In the past,\n// we didn't use empty text nodes on IE 8 because they\n// don't accept JS properties, so just use the same logic\n// even though we don't need to set properties on the\n// placeholder anymore.\nDOMRange._USE_COMMENT_PLACEHOLDERS = function () {\n  var result = false;\n  var textNode = document.createTextNode(\"\");\n  try {\n    textNode.someProp = true;\n  } catch (e) {\n    // IE 8\n    result = true;\n  }\n  return result;\n}();\n\n// static methods\nDOMRange._insert = function (rangeOrNode, parentElement, nextNode, _isMove) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.attach(parentElement, nextNode, _isMove);\n  } else {\n    if (_isMove) DOMRange._moveNodeWithHooks(m, parentElement, nextNode);else DOMRange._insertNodeWithHooks(m, parentElement, nextNode);\n  }\n};\nDOMRange._remove = function (rangeOrNode) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.detach();\n  } else {\n    DOMRange._removeNodeWithHooks(m);\n  }\n};\nDOMRange._removeNodeWithHooks = function (n) {\n  if (!n.parentNode) return;\n  if (n.nodeType === 1 && n.parentNode._uihooks && n.parentNode._uihooks.removeElement) {\n    n.parentNode._uihooks.removeElement(n);\n  } else {\n    n.parentNode.removeChild(n);\n  }\n};\nDOMRange._insertNodeWithHooks = function (n, parent, next) {\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 && parent._uihooks && parent._uihooks.insertElement) {\n    parent._uihooks.insertElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\nDOMRange._moveNodeWithHooks = function (n, parent, next) {\n  if (n.parentNode !== parent) return;\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 && parent._uihooks && parent._uihooks.moveElement) {\n    parent._uihooks.moveElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\nDOMRange.forElement = function (elem) {\n  if (elem.nodeType !== 1) throw new Error(\"Expected element, found: \" + elem);\n  var range = null;\n  while (elem && !range) {\n    range = elem.$blaze_range || null;\n    if (!range) elem = elem.parentNode;\n  }\n  return range;\n};\nDOMRange.prototype.attach = function (parentElement, nextNode, _isMove, _isReplace) {\n  // This method is called to insert the DOMRange into the DOM for\n  // the first time, but it's also used internally when\n  // updating the DOM.\n  //\n  // If _isMove is true, move this attached range to a different\n  // location under the same parentElement.\n  if (_isMove || _isReplace) {\n    if (!(this.parentElement === parentElement && this.attached)) throw new Error(\"Can only move or replace an attached DOMRange, and only under the same parent element\");\n  }\n  var members = this.members;\n  if (members.length) {\n    this.emptyRangePlaceholder = null;\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._insert(members[i], parentElement, nextNode, _isMove);\n    }\n  } else {\n    var placeholder = DOMRange._USE_COMMENT_PLACEHOLDERS ? document.createComment(\"\") : document.createTextNode(\"\");\n    this.emptyRangePlaceholder = placeholder;\n    parentElement.insertBefore(placeholder, nextNode || null);\n  }\n  this.attached = true;\n  this.parentElement = parentElement;\n  if (!(_isMove || _isReplace)) {\n    for (var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.attached && obj.attached(this, parentElement);\n    }\n  }\n};\nDOMRange.prototype.setMembers = function (newNodeAndRangeArray) {\n  var newMembers = newNodeAndRangeArray;\n  if (!(newMembers && typeof newMembers.length === 'number')) throw new Error(\"Expected array\");\n  var oldMembers = this.members;\n  for (var i = 0; i < oldMembers.length; i++) this._memberOut(oldMembers[i]);\n  for (var i = 0; i < newMembers.length; i++) this._memberIn(newMembers[i]);\n  if (!this.attached) {\n    this.members = newMembers;\n  } else {\n    // don't do anything if we're going from empty to empty\n    if (newMembers.length || oldMembers.length) {\n      // detach the old members and insert the new members\n      var nextNode = this.lastNode().nextSibling;\n      var parentElement = this.parentElement;\n      // Use detach/attach, but don't fire attached/detached hooks\n      this.detach(true /*_isReplace*/);\n      this.members = newMembers;\n      this.attach(parentElement, nextNode, false, true /*_isReplace*/);\n    }\n  }\n};\nDOMRange.prototype.firstNode = function () {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  if (!this.members.length) return this.emptyRangePlaceholder;\n  var m = this.members[0];\n  return m instanceof DOMRange ? m.firstNode() : m;\n};\nDOMRange.prototype.lastNode = function () {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  if (!this.members.length) return this.emptyRangePlaceholder;\n  var m = this.members[this.members.length - 1];\n  return m instanceof DOMRange ? m.lastNode() : m;\n};\nDOMRange.prototype.detach = function (_isReplace) {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  var oldParentElement = this.parentElement;\n  var members = this.members;\n  if (members.length) {\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._remove(members[i]);\n    }\n  } else {\n    var placeholder = this.emptyRangePlaceholder;\n    this.parentElement.removeChild(placeholder);\n    this.emptyRangePlaceholder = null;\n  }\n  if (!_isReplace) {\n    this.attached = false;\n    this.parentElement = null;\n    for (var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.detached && obj.detached(this, oldParentElement);\n    }\n  }\n};\nDOMRange.prototype.addMember = function (newMember, atIndex, _isMove) {\n  var members = this.members;\n  if (!(atIndex >= 0 && atIndex <= members.length)) throw new Error(\"Bad index in range.addMember: \" + atIndex);\n  if (!_isMove) this._memberIn(newMember);\n  if (!this.attached) {\n    // currently detached; just updated members\n    members.splice(atIndex, 0, newMember);\n  } else if (members.length === 0) {\n    // empty; use the empty-to-nonempty handling of setMembers\n    this.setMembers([newMember]);\n  } else {\n    var nextNode;\n    if (atIndex === members.length) {\n      // insert at end\n      nextNode = this.lastNode().nextSibling;\n    } else {\n      var m = members[atIndex];\n      nextNode = m instanceof DOMRange ? m.firstNode() : m;\n    }\n    members.splice(atIndex, 0, newMember);\n    DOMRange._insert(newMember, this.parentElement, nextNode, _isMove);\n  }\n};\nDOMRange.prototype.removeMember = function (atIndex, _isMove) {\n  var members = this.members;\n  if (!(atIndex >= 0 && atIndex < members.length)) throw new Error(\"Bad index in range.removeMember: \" + atIndex);\n  if (_isMove) {\n    members.splice(atIndex, 1);\n  } else {\n    var oldMember = members[atIndex];\n    this._memberOut(oldMember);\n    if (members.length === 1) {\n      // becoming empty; use the logic in setMembers\n      this.setMembers(_emptyArray);\n    } else {\n      members.splice(atIndex, 1);\n      if (this.attached) DOMRange._remove(oldMember);\n    }\n  }\n};\nDOMRange.prototype.moveMember = function (oldIndex, newIndex) {\n  var member = this.members[oldIndex];\n  this.removeMember(oldIndex, true /*_isMove*/);\n  this.addMember(member, newIndex, true /*_isMove*/);\n};\nDOMRange.prototype.getMember = function (atIndex) {\n  var members = this.members;\n  if (!(atIndex >= 0 && atIndex < members.length)) throw new Error(\"Bad index in range.getMember: \" + atIndex);\n  return this.members[atIndex];\n};\nDOMRange.prototype._memberIn = function (m) {\n  if (m instanceof DOMRange) m.parentRange = this;else if (m.nodeType === 1)\n    // DOM Element\n    m.$blaze_range = this;\n};\nDOMRange._destroy = function (m, _skipNodes) {\n  if (m instanceof DOMRange) {\n    if (m.view) Blaze._destroyView(m.view, _skipNodes);\n  } else if (!_skipNodes && m.nodeType === 1) {\n    // DOM Element\n    if (m.$blaze_range) {\n      Blaze._destroyNode(m);\n      m.$blaze_range = null;\n    }\n  }\n};\nDOMRange.prototype._memberOut = DOMRange._destroy;\n\n// Tear down, but don't remove, the members.  Used when chunks\n// of DOM are being torn down or replaced.\nDOMRange.prototype.destroyMembers = function (_skipNodes) {\n  var members = this.members;\n  for (var i = 0; i < members.length; i++) this._memberOut(members[i], _skipNodes);\n};\nDOMRange.prototype.destroy = function (_skipNodes) {\n  DOMRange._destroy(this, _skipNodes);\n};\nDOMRange.prototype.containsElement = function (elem, selector, event) {\n  var _this$view;\n  const templateName = (_this$view = this.view) !== null && _this$view !== void 0 && _this$view.name ? this.view.name.split('.')[1] : 'unknown template';\n  if (!this.attached) throw new Error(\"\".concat(event, \" event triggerd with \").concat(selector, \" on \").concat(templateName, \" but associated view is not be found.\\n    Make sure the event doesn't destroy the view.\"));\n\n  // An element is contained in this DOMRange if it's possible to\n  // reach it by walking parent pointers, first through the DOM and\n  // then parentRange pointers.  In other words, the element or some\n  // ancestor of it is at our level of the DOM (a child of our\n  // parentElement), and this element is one of our members or\n  // is a member of a descendant Range.\n\n  // First check that elem is a descendant of this.parentElement,\n  // according to the DOM.\n  if (!Blaze._elementContains(this.parentElement, elem)) return false;\n\n  // If elem is not an immediate child of this.parentElement,\n  // walk up to its ancestor that is.\n  while (elem.parentNode !== this.parentElement) elem = elem.parentNode;\n  var range = elem.$blaze_range;\n  while (range && range !== this) range = range.parentRange;\n  return range === this;\n};\nDOMRange.prototype.containsRange = function (range) {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  if (!range.attached) return false;\n\n  // A DOMRange is contained in this DOMRange if it's possible\n  // to reach this range by following parent pointers.  If the\n  // DOMRange has the same parentElement, then it should be\n  // a member, or a member of a member etc.  Otherwise, we must\n  // contain its parentElement.\n\n  if (range.parentElement !== this.parentElement) return this.containsElement(range.parentElement);\n  if (range === this) return false; // don't contain self\n\n  while (range && range !== this) range = range.parentRange;\n  return range === this;\n};\nDOMRange.prototype.onAttached = function (attached) {\n  this.onAttachedDetached({\n    attached: attached\n  });\n};\n\n// callbacks are `attached(range, element)` and\n// `detached(range, element)`, and they may\n// access the `callbacks` object in `this`.\n// The arguments to `detached` are the same\n// range and element that were passed to `attached`.\nDOMRange.prototype.onAttachedDetached = function (callbacks) {\n  if (this.attachedCallbacks === _emptyArray) this.attachedCallbacks = [];\n  this.attachedCallbacks.push(callbacks);\n};\nDOMRange.prototype.$ = function (selector) {\n  var self = this;\n  var parentNode = this.parentElement;\n  if (!parentNode) throw new Error(\"Can't select in removed DomRange\");\n\n  // Strategy: Find all selector matches under parentNode,\n  // then filter out the ones that aren't in this DomRange\n  // using `DOMRange#containsElement`.  This is\n  // asymptotically slow in the presence of O(N) sibling\n  // content that is under parentNode but not in our range,\n  // so if performance is an issue, the selector should be\n  // run on a child element.\n\n  // Since jQuery can't run selectors on a DocumentFragment,\n  // we don't expect findBySelector to work.\n  if (parentNode.nodeType === 11 /* DocumentFragment */) throw new Error(\"Can't use $ on an offscreen range\");\n  var results = Blaze._DOMBackend.findBySelector(selector, parentNode);\n\n  // We don't assume `results` has jQuery API; a plain array\n  // should do just as well.  However, if we do have a jQuery\n  // array, we want to end up with one also, so we use\n  // `.filter`.\n\n  // Function that selects only elements that are actually\n  // in this DomRange, rather than simply descending from\n  // `parentNode`.\n  var filterFunc = function (elem) {\n    // handle jQuery's arguments to filter, where the node\n    // is in `this` and the index is the first argument.\n    if (typeof elem === 'number') elem = this;\n    return self.containsElement(elem);\n  };\n  if (!results.filter) {\n    // not a jQuery array, and not a browser with\n    // Array.prototype.filter (e.g. IE <9)\n    var newResults = [];\n    for (var i = 0; i < results.length; i++) {\n      var x = results[i];\n      if (filterFunc(x)) newResults.push(x);\n    }\n    results = newResults;\n  } else {\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\n    results = results.filter(filterFunc);\n  }\n  return results;\n};\n\n// Returns true if element a contains node b and is not node b.\n//\n// The restriction that `a` be an element (not a document fragment,\n// say) is based on what's easy to implement cross-browser.\nBlaze._elementContains = function (a, b) {\n  if (a.nodeType !== 1)\n    // ELEMENT\n    return false;\n  if (a === b) return false;\n  if (a.compareDocumentPosition) {\n    return a.compareDocumentPosition(b) & 0x10;\n  } else {\n    // Should be only old IE and maybe other old browsers here.\n    // Modern Safari has both functions but seems to get contains() wrong.\n    // IE can't handle b being a text node.  We work around this\n    // by doing a direct parent test now.\n    b = b.parentNode;\n    if (!(b && b.nodeType === 1))\n      // ELEMENT\n      return false;\n    if (a === b) return true;\n    return a.contains(b);\n  }\n};","map":{"version":3,"names":["_emptyArray","Object","freeze","Blaze","_DOMRange","nodeAndRangeArray","DOMRange","members","length","Error","i","_memberIn","emptyRangePlaceholder","attached","parentElement","parentRange","attachedCallbacks","_USE_COMMENT_PLACEHOLDERS","result","textNode","document","createTextNode","someProp","e","_insert","rangeOrNode","nextNode","_isMove","m","attach","_moveNodeWithHooks","_insertNodeWithHooks","_remove","detach","_removeNodeWithHooks","n","parentNode","nodeType","_uihooks","removeElement","removeChild","parent","next","insertElement","insertBefore","moveElement","forElement","elem","range","$blaze_range","prototype","_isReplace","placeholder","createComment","obj","setMembers","newNodeAndRangeArray","newMembers","oldMembers","_memberOut","lastNode","nextSibling","firstNode","oldParentElement","detached","addMember","newMember","atIndex","splice","removeMember","oldMember","moveMember","oldIndex","newIndex","member","getMember","_destroy","_skipNodes","view","_destroyView","_destroyNode","destroyMembers","destroy","containsElement","selector","event","_this$view","templateName","name","split","concat","_elementContains","containsRange","onAttached","onAttachedDetached","callbacks","push","$","self","results","_DOMBackend","findBySelector","filterFunc","filter","newResults","x","a","b","compareDocumentPosition","contains"],"sources":["packages/blaze/domrange.js"],"sourcesContent":["\n// A constant empty array (frozen if the JS engine supports it).\nvar _emptyArray = Object.freeze ? Object.freeze([]) : [];\n\n// `[new] Blaze._DOMRange([nodeAndRangeArray])`\n//\n// A DOMRange consists of an array of consecutive nodes and DOMRanges,\n// which may be replaced at any time with a new array.  If the DOMRange\n// has been attached to the DOM at some location, then updating\n// the array will cause the DOM to be updated at that location.\nBlaze._DOMRange = function (nodeAndRangeArray) {\n  if (! (this instanceof DOMRange))\n    // called without `new`\n    return new DOMRange(nodeAndRangeArray);\n\n  var members = (nodeAndRangeArray || _emptyArray);\n  if (! (members && (typeof members.length) === 'number'))\n    throw new Error(\"Expected array\");\n\n  for (var i = 0; i < members.length; i++)\n    this._memberIn(members[i]);\n\n  this.members = members;\n  this.emptyRangePlaceholder = null;\n  this.attached = false;\n  this.parentElement = null;\n  this.parentRange = null;\n  this.attachedCallbacks = _emptyArray;\n};\nvar DOMRange = Blaze._DOMRange;\n\n// In IE 8, don't use empty text nodes as placeholders\n// in empty DOMRanges, use comment nodes instead.  Using\n// empty text nodes in modern browsers is great because\n// it doesn't clutter the web inspector.  In IE 8, however,\n// it seems to lead in some roundabout way to the OAuth\n// pop-up crashing the browser completely.  In the past,\n// we didn't use empty text nodes on IE 8 because they\n// don't accept JS properties, so just use the same logic\n// even though we don't need to set properties on the\n// placeholder anymore.\nDOMRange._USE_COMMENT_PLACEHOLDERS = (function () {\n  var result = false;\n  var textNode = document.createTextNode(\"\");\n  try {\n    textNode.someProp = true;\n  } catch (e) {\n    // IE 8\n    result = true;\n  }\n  return result;\n})();\n\n// static methods\nDOMRange._insert = function (rangeOrNode, parentElement, nextNode, _isMove) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.attach(parentElement, nextNode, _isMove);\n  } else {\n    if (_isMove)\n      DOMRange._moveNodeWithHooks(m, parentElement, nextNode);\n    else\n      DOMRange._insertNodeWithHooks(m, parentElement, nextNode);\n  }\n};\n\nDOMRange._remove = function (rangeOrNode) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.detach();\n  } else {\n    DOMRange._removeNodeWithHooks(m);\n  }\n};\n\nDOMRange._removeNodeWithHooks = function (n) {\n  if (! n.parentNode)\n    return;\n  if (n.nodeType === 1 &&\n      n.parentNode._uihooks && n.parentNode._uihooks.removeElement) {\n    n.parentNode._uihooks.removeElement(n);\n  } else {\n    n.parentNode.removeChild(n);\n  }\n};\n\nDOMRange._insertNodeWithHooks = function (n, parent, next) {\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 &&\n      parent._uihooks && parent._uihooks.insertElement) {\n    parent._uihooks.insertElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange._moveNodeWithHooks = function (n, parent, next) {\n  if (n.parentNode !== parent)\n    return;\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 &&\n      parent._uihooks && parent._uihooks.moveElement) {\n    parent._uihooks.moveElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange.forElement = function (elem) {\n  if (elem.nodeType !== 1)\n    throw new Error(\"Expected element, found: \" + elem);\n  var range = null;\n  while (elem && ! range) {\n    range = (elem.$blaze_range || null);\n    if (! range)\n      elem = elem.parentNode;\n  }\n  return range;\n};\n\nDOMRange.prototype.attach = function (parentElement, nextNode, _isMove, _isReplace) {\n  // This method is called to insert the DOMRange into the DOM for\n  // the first time, but it's also used internally when\n  // updating the DOM.\n  //\n  // If _isMove is true, move this attached range to a different\n  // location under the same parentElement.\n  if (_isMove || _isReplace) {\n    if (! (this.parentElement === parentElement &&\n           this.attached))\n      throw new Error(\"Can only move or replace an attached DOMRange, and only under the same parent element\");\n  }\n\n  var members = this.members;\n  if (members.length) {\n    this.emptyRangePlaceholder = null;\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._insert(members[i], parentElement, nextNode, _isMove);\n    }\n  } else {\n    var placeholder = (\n      DOMRange._USE_COMMENT_PLACEHOLDERS ?\n        document.createComment(\"\") :\n        document.createTextNode(\"\"));\n    this.emptyRangePlaceholder = placeholder;\n    parentElement.insertBefore(placeholder, nextNode || null);\n  }\n  this.attached = true;\n  this.parentElement = parentElement;\n\n  if (! (_isMove || _isReplace)) {\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.attached && obj.attached(this, parentElement);\n    }\n  }\n};\n\nDOMRange.prototype.setMembers = function (newNodeAndRangeArray) {\n  var newMembers = newNodeAndRangeArray;\n  if (! (newMembers && (typeof newMembers.length) === 'number'))\n    throw new Error(\"Expected array\");\n\n  var oldMembers = this.members;\n\n  for (var i = 0; i < oldMembers.length; i++)\n    this._memberOut(oldMembers[i]);\n  for (var i = 0; i < newMembers.length; i++)\n    this._memberIn(newMembers[i]);\n\n  if (! this.attached) {\n    this.members = newMembers;\n  } else {\n    // don't do anything if we're going from empty to empty\n    if (newMembers.length || oldMembers.length) {\n      // detach the old members and insert the new members\n      var nextNode = this.lastNode().nextSibling;\n      var parentElement = this.parentElement;\n      // Use detach/attach, but don't fire attached/detached hooks\n      this.detach(true /*_isReplace*/);\n      this.members = newMembers;\n      this.attach(parentElement, nextNode, false, true /*_isReplace*/);\n    }\n  }\n};\n\nDOMRange.prototype.firstNode = function () {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! this.members.length)\n    return this.emptyRangePlaceholder;\n\n  var m = this.members[0];\n  return (m instanceof DOMRange) ? m.firstNode() : m;\n};\n\nDOMRange.prototype.lastNode = function () {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! this.members.length)\n    return this.emptyRangePlaceholder;\n\n  var m = this.members[this.members.length - 1];\n  return (m instanceof DOMRange) ? m.lastNode() : m;\n};\n\nDOMRange.prototype.detach = function (_isReplace) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  var oldParentElement = this.parentElement;\n  var members = this.members;\n  if (members.length) {\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._remove(members[i]);\n    }\n  } else {\n    var placeholder = this.emptyRangePlaceholder;\n    this.parentElement.removeChild(placeholder);\n    this.emptyRangePlaceholder = null;\n  }\n\n  if (! _isReplace) {\n    this.attached = false;\n    this.parentElement = null;\n\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.detached && obj.detached(this, oldParentElement);\n    }\n  }\n};\n\nDOMRange.prototype.addMember = function (newMember, atIndex, _isMove) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex <= members.length))\n    throw new Error(\"Bad index in range.addMember: \" + atIndex);\n\n  if (! _isMove)\n    this._memberIn(newMember);\n\n  if (! this.attached) {\n    // currently detached; just updated members\n    members.splice(atIndex, 0, newMember);\n  } else if (members.length === 0) {\n    // empty; use the empty-to-nonempty handling of setMembers\n    this.setMembers([newMember]);\n  } else {\n    var nextNode;\n    if (atIndex === members.length) {\n      // insert at end\n      nextNode = this.lastNode().nextSibling;\n    } else {\n      var m = members[atIndex];\n      nextNode = (m instanceof DOMRange) ? m.firstNode() : m;\n    }\n    members.splice(atIndex, 0, newMember);\n    DOMRange._insert(newMember, this.parentElement, nextNode, _isMove);\n  }\n};\n\nDOMRange.prototype.removeMember = function (atIndex, _isMove) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex < members.length))\n    throw new Error(\"Bad index in range.removeMember: \" + atIndex);\n\n  if (_isMove) {\n    members.splice(atIndex, 1);\n  } else {\n    var oldMember = members[atIndex];\n    this._memberOut(oldMember);\n\n    if (members.length === 1) {\n      // becoming empty; use the logic in setMembers\n      this.setMembers(_emptyArray);\n    } else {\n      members.splice(atIndex, 1);\n      if (this.attached)\n        DOMRange._remove(oldMember);\n    }\n  }\n};\n\nDOMRange.prototype.moveMember = function (oldIndex, newIndex) {\n  var member = this.members[oldIndex];\n  this.removeMember(oldIndex, true /*_isMove*/);\n  this.addMember(member, newIndex, true /*_isMove*/);\n};\n\nDOMRange.prototype.getMember = function (atIndex) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex < members.length))\n    throw new Error(\"Bad index in range.getMember: \" + atIndex);\n  return this.members[atIndex];\n};\n\nDOMRange.prototype._memberIn = function (m) {\n  if (m instanceof DOMRange)\n    m.parentRange = this;\n  else if (m.nodeType === 1) // DOM Element\n    m.$blaze_range = this;\n};\n\nDOMRange._destroy = function (m, _skipNodes) {\n  if (m instanceof DOMRange) {\n    if (m.view)\n      Blaze._destroyView(m.view, _skipNodes);\n  } else if ((! _skipNodes) && m.nodeType === 1) {\n    // DOM Element\n    if (m.$blaze_range) {\n      Blaze._destroyNode(m);\n      m.$blaze_range = null;\n    }\n  }\n};\n\nDOMRange.prototype._memberOut = DOMRange._destroy;\n\n// Tear down, but don't remove, the members.  Used when chunks\n// of DOM are being torn down or replaced.\nDOMRange.prototype.destroyMembers = function (_skipNodes) {\n  var members = this.members;\n  for (var i = 0; i < members.length; i++)\n    this._memberOut(members[i], _skipNodes);\n};\n\nDOMRange.prototype.destroy = function (_skipNodes) {\n  DOMRange._destroy(this, _skipNodes);\n};\n\nDOMRange.prototype.containsElement = function (elem, selector, event) {\n  const templateName = this.view?.name\n  ? this.view.name.split('.')[1]\n  : 'unknown template';\n  if (! this.attached)\n    throw new Error(`${event} event triggerd with ${selector} on ${templateName} but associated view is not be found.\n    Make sure the event doesn't destroy the view.`);\n\n  // An element is contained in this DOMRange if it's possible to\n  // reach it by walking parent pointers, first through the DOM and\n  // then parentRange pointers.  In other words, the element or some\n  // ancestor of it is at our level of the DOM (a child of our\n  // parentElement), and this element is one of our members or\n  // is a member of a descendant Range.\n\n  // First check that elem is a descendant of this.parentElement,\n  // according to the DOM.\n  if (! Blaze._elementContains(this.parentElement, elem))\n    return false;\n\n  // If elem is not an immediate child of this.parentElement,\n  // walk up to its ancestor that is.\n  while (elem.parentNode !== this.parentElement)\n    elem = elem.parentNode;\n\n  var range = elem.$blaze_range;\n  while (range && range !== this)\n    range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.containsRange = function (range) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! range.attached)\n    return false;\n\n  // A DOMRange is contained in this DOMRange if it's possible\n  // to reach this range by following parent pointers.  If the\n  // DOMRange has the same parentElement, then it should be\n  // a member, or a member of a member etc.  Otherwise, we must\n  // contain its parentElement.\n\n  if (range.parentElement !== this.parentElement)\n    return this.containsElement(range.parentElement);\n\n  if (range === this)\n    return false; // don't contain self\n\n  while (range && range !== this)\n    range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.onAttached = function (attached) {\n  this.onAttachedDetached({ attached: attached });\n};\n\n// callbacks are `attached(range, element)` and\n// `detached(range, element)`, and they may\n// access the `callbacks` object in `this`.\n// The arguments to `detached` are the same\n// range and element that were passed to `attached`.\nDOMRange.prototype.onAttachedDetached = function (callbacks) {\n  if (this.attachedCallbacks === _emptyArray)\n    this.attachedCallbacks = [];\n  this.attachedCallbacks.push(callbacks);\n};\n\nDOMRange.prototype.$ = function (selector) {\n  var self = this;\n\n  var parentNode = this.parentElement;\n  if (! parentNode)\n    throw new Error(\"Can't select in removed DomRange\");\n\n  // Strategy: Find all selector matches under parentNode,\n  // then filter out the ones that aren't in this DomRange\n  // using `DOMRange#containsElement`.  This is\n  // asymptotically slow in the presence of O(N) sibling\n  // content that is under parentNode but not in our range,\n  // so if performance is an issue, the selector should be\n  // run on a child element.\n\n  // Since jQuery can't run selectors on a DocumentFragment,\n  // we don't expect findBySelector to work.\n  if (parentNode.nodeType === 11 /* DocumentFragment */)\n    throw new Error(\"Can't use $ on an offscreen range\");\n\n  var results = Blaze._DOMBackend.findBySelector(selector, parentNode);\n\n  // We don't assume `results` has jQuery API; a plain array\n  // should do just as well.  However, if we do have a jQuery\n  // array, we want to end up with one also, so we use\n  // `.filter`.\n\n  // Function that selects only elements that are actually\n  // in this DomRange, rather than simply descending from\n  // `parentNode`.\n  var filterFunc = function (elem) {\n    // handle jQuery's arguments to filter, where the node\n    // is in `this` and the index is the first argument.\n    if (typeof elem === 'number')\n      elem = this;\n\n    return self.containsElement(elem);\n  };\n\n  if (! results.filter) {\n    // not a jQuery array, and not a browser with\n    // Array.prototype.filter (e.g. IE <9)\n    var newResults = [];\n    for (var i = 0; i < results.length; i++) {\n      var x = results[i];\n      if (filterFunc(x))\n        newResults.push(x);\n    }\n    results = newResults;\n  } else {\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\n    results = results.filter(filterFunc);\n  }\n\n  return results;\n};\n\n// Returns true if element a contains node b and is not node b.\n//\n// The restriction that `a` be an element (not a document fragment,\n// say) is based on what's easy to implement cross-browser.\nBlaze._elementContains = function (a, b) {\n  if (a.nodeType !== 1) // ELEMENT\n    return false;\n  if (a === b)\n    return false;\n\n  if (a.compareDocumentPosition) {\n    return a.compareDocumentPosition(b) & 0x10;\n  } else {\n    // Should be only old IE and maybe other old browsers here.\n    // Modern Safari has both functions but seems to get contains() wrong.\n    // IE can't handle b being a text node.  We work around this\n    // by doing a direct parent test now.\n    b = b.parentNode;\n    if (! (b && b.nodeType === 1)) // ELEMENT\n      return false;\n    if (a === b)\n      return true;\n\n    return a.contains(b);\n  }\n};\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"2cdd0565a33b5912abfcd248994be68dba1421b2"}
