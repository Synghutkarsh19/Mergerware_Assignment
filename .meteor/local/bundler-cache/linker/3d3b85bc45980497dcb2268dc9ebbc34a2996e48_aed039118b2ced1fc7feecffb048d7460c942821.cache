[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Accounts = Package['accounts-base'].Accounts;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Mongo = Package.mongo.Mongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package.modules.meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\nvar Symbol = Package['ecmascript-runtime-client'].Symbol;\nvar Map = Package['ecmascript-runtime-client'].Map;\nvar Set = Package['ecmascript-runtime-client'].Set;\n\n/* Package-scope variables */\nvar Roles;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"alanning:roles\":{\"roles\":{\"roles_common.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/roles_common.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  var _typeof;\n  module1.link(\"@babel/runtime/helpers/typeof\", {\n    default: function (v) {\n      _typeof = v;\n    }\n  }, 0);\n  var _toConsumableArray;\n  module1.link(\"@babel/runtime/helpers/toConsumableArray\", {\n    default: function (v) {\n      _toConsumableArray = v;\n    }\n  }, 1);\n  /* global Meteor, Roles, Mongo */\n\n  /**\n   * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n   *\n   * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n   *  - `_id`: role name\n   *  - `children`: list of subdocuments:\n   *    - `_id`\n   *\n   * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n   *\n   * Roles can have multiple parents and can be children (subroles) of multiple roles.\n   *\n   * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n   *\n   * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n   * It's documents consist of\n   *  - `_id`: Internal MongoDB id\n   *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n   *  - `user`: A user object, usually only contains the `_id` property\n   *  - `scope`: scope name\n   *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n   *\n   * @module Roles\n   */\n  if (!Meteor.roles) {\n    Meteor.roles = new Mongo.Collection('roles');\n  }\n  if (!Meteor.roleAssignment) {\n    Meteor.roleAssignment = new Mongo.Collection('role-assignment');\n  }\n\n  /**\n   * @class Roles\n   */\n  if (typeof Roles === 'undefined') {\n    Roles = {}; // eslint-disable-line no-global-assign\n  }\n  var getGroupsForUserDeprecationWarning = false;\n  Object.assign(Roles, {\n    /**\n     * Used as a global group (now scope) name. Not used anymore.\n     *\n     * @property GLOBAL_GROUP\n     * @static\n     * @deprecated\n     */\n    GLOBAL_GROUP: null,\n    /**\n     * Create a new role.\n     *\n     * @method createRole\n     * @param {String} roleName Name of role.\n     * @param {Object} [options] Options:\n     *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n     * @return {String} ID of the new role or null.\n     * @static\n     */\n    createRole: function (roleName, options) {\n      Roles._checkRoleName(roleName);\n      options = Object.assign({\n        unlessExists: false\n      }, options);\n      var result = Meteor.roles.upsert({\n        _id: roleName\n      }, {\n        $setOnInsert: {\n          children: []\n        }\n      });\n      if (!result.insertedId) {\n        if (options.unlessExists) return null;\n        throw new Error('Role \\'' + roleName + '\\' already exists.');\n      }\n      return result.insertedId;\n    },\n    /**\n     * Delete an existing role.\n     *\n     * If the role is set for any user, it is automatically unset.\n     *\n     * @method deleteRole\n     * @param {String} roleName Name of role.\n     * @static\n     */\n    deleteRole: function (roleName) {\n      var roles;\n      var inheritedRoles;\n      Roles._checkRoleName(roleName);\n\n      // Remove all assignments\n      Meteor.roleAssignment.remove({\n        'role._id': roleName\n      });\n      do {\n        // For all roles who have it as a dependency ...\n        roles = Roles._getParentRoleNames(Meteor.roles.findOne({\n          _id: roleName\n        }));\n        Meteor.roles.find({\n          _id: {\n            $in: roles\n          }\n        }).fetch().forEach(function (r) {\n          Meteor.roles.update({\n            _id: r._id\n          }, {\n            $pull: {\n              children: {\n                _id: roleName\n              }\n            }\n          });\n          inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({\n            _id: r._id\n          }));\n          Meteor.roleAssignment.update({\n            'role._id': r._id\n          }, {\n            $set: {\n              inheritedRoles: [r._id].concat(_toConsumableArray(inheritedRoles)).map(function (r2) {\n                return {\n                  _id: r2\n                };\n              })\n            }\n          }, {\n            multi: true\n          });\n        });\n      } while (roles.length > 0);\n\n      // And finally remove the role itself\n      Meteor.roles.remove({\n        _id: roleName\n      });\n    },\n    /**\n     * Rename an existing role.\n     *\n     * @method renameRole\n     * @param {String} oldName Old name of a role.\n     * @param {String} newName New name of a role.\n     * @static\n     */\n    renameRole: function (oldName, newName) {\n      var count;\n      Roles._checkRoleName(oldName);\n      Roles._checkRoleName(newName);\n      if (oldName === newName) return;\n      var role = Meteor.roles.findOne({\n        _id: oldName\n      });\n      if (!role) {\n        throw new Error('Role \\'' + oldName + '\\' does not exist.');\n      }\n      role._id = newName;\n      Meteor.roles.insert(role);\n      do {\n        count = Meteor.roleAssignment.update({\n          'role._id': oldName\n        }, {\n          $set: {\n            'role._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      do {\n        count = Meteor.roleAssignment.update({\n          'inheritedRoles._id': oldName\n        }, {\n          $set: {\n            'inheritedRoles.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      do {\n        count = Meteor.roles.update({\n          'children._id': oldName\n        }, {\n          $set: {\n            'children.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      Meteor.roles.remove({\n        _id: oldName\n      });\n    },\n    /**\n     * Add role parent to roles.\n     *\n     * Previous parents are kept (role can have multiple parents). For users which have the\n     * parent role set, new subroles are added automatically.\n     *\n     * @method addRolesToParent\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @static\n     */\n    addRolesToParent: function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      rolesNames.forEach(function (roleName) {\n        Roles._addRoleToParent(roleName, parentName);\n      });\n    },\n    /**\n     * @method _addRoleToParent\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @private\n     * @static\n     */\n    _addRoleToParent: function (roleName, parentName) {\n      Roles._checkRoleName(roleName);\n      Roles._checkRoleName(parentName);\n\n      // query to get role's children\n      var role = Meteor.roles.findOne({\n        _id: roleName\n      });\n      if (!role) {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.');\n      }\n\n      // detect cycles\n      if (Roles._getInheritedRoleNames(role).includes(parentName)) {\n        throw new Error('Roles \\'' + roleName + '\\' and \\'' + parentName + '\\' would form a cycle.');\n      }\n      var count = Meteor.roles.update({\n        _id: parentName,\n        'children._id': {\n          $ne: role._id\n        }\n      }, {\n        $push: {\n          children: {\n            _id: role._id\n          }\n        }\n      });\n\n      // if there was no change, parent role might not exist, or role is\n      // already a subrole; in any case we do not have anything more to do\n      if (!count) return;\n      Meteor.roleAssignment.update({\n        'inheritedRoles._id': parentName\n      }, {\n        $push: {\n          inheritedRoles: {\n            $each: [role._id].concat(_toConsumableArray(Roles._getInheritedRoleNames(role))).map(function (r) {\n              return {\n                _id: r\n              };\n            })\n          }\n        }\n      }, {\n        multi: true\n      });\n    },\n    /**\n     * Remove role parent from roles.\n     *\n     * Other parents are kept (role can have multiple parents). For users which have the\n     * parent role set, removed subrole is removed automatically.\n     *\n     * @method removeRolesFromParent\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @static\n     */\n    removeRolesFromParent: function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      rolesNames.forEach(function (roleName) {\n        Roles._removeRoleFromParent(roleName, parentName);\n      });\n    },\n    /**\n     * @method _removeRoleFromParent\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @private\n     * @static\n     */\n    _removeRoleFromParent: function (roleName, parentName) {\n      Roles._checkRoleName(roleName);\n      Roles._checkRoleName(parentName);\n\n      // check for role existence\n      // this would not really be needed, but we are trying to match addRolesToParent\n      var role = Meteor.roles.findOne({\n        _id: roleName\n      }, {\n        fields: {\n          _id: 1\n        }\n      });\n      if (!role) {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.');\n      }\n      var count = Meteor.roles.update({\n        _id: parentName\n      }, {\n        $pull: {\n          children: {\n            _id: role._id\n          }\n        }\n      });\n\n      // if there was no change, parent role might not exist, or role was\n      // already not a subrole; in any case we do not have anything more to do\n      if (!count) return;\n\n      // For all roles who have had it as a dependency ...\n      var roles = [].concat(_toConsumableArray(Roles._getParentRoleNames(Meteor.roles.findOne({\n        _id: parentName\n      }))), [parentName]);\n      Meteor.roles.find({\n        _id: {\n          $in: roles\n        }\n      }).fetch().forEach(function (r) {\n        var inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({\n          _id: r._id\n        }));\n        Meteor.roleAssignment.update({\n          'role._id': r._id,\n          'inheritedRoles._id': role._id\n        }, {\n          $set: {\n            inheritedRoles: [r._id].concat(_toConsumableArray(inheritedRoles)).map(function (r2) {\n              return {\n                _id: r2\n              };\n            })\n          }\n        }, {\n          multi: true\n        });\n      });\n    },\n    /**\n     * Add users to roles.\n     *\n     * Adds roles to existing roles for each user.\n     *\n     * @example\n     *     Roles.addUsersToRoles(userId, 'admin')\n     *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n     *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n     *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method addUsersToRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    addUsersToRoles: function (users, roles, options) {\n      var id;\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        ifExists: false\n      }, options);\n      users.forEach(function (user) {\n        if (_typeof(user) === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        roles.forEach(function (role) {\n          Roles._addUserToRole(id, role, options);\n        });\n      });\n    },\n    /**\n     * Set users' roles.\n     *\n     * Replaces all existing roles with a new set of roles.\n     *\n     * @example\n     *     Roles.setUserRoles(userId, 'admin')\n     *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n     *     Roles.setUserRoles([user1, user2], ['user','editor'])\n     *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method setUserRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    setUserRoles: function (users, roles, options) {\n      var id;\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        ifExists: false,\n        anyScope: false\n      }, options);\n      users.forEach(function (user) {\n        if (_typeof(user) === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        // we first clear all roles for the user\n        var selector = {\n          'user._id': id\n        };\n        if (!options.anyScope) {\n          selector.scope = options.scope;\n        }\n        Meteor.roleAssignment.remove(selector);\n\n        // and then add all\n        roles.forEach(function (role) {\n          Roles._addUserToRole(id, role, options);\n        });\n      });\n    },\n    /**\n     * Add one user to one role.\n     *\n     * @method _addUserToRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @private\n     * @static\n     */\n    _addUserToRole: function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n      Roles._checkScopeName(options.scope);\n      if (!userId) {\n        return;\n      }\n      var role = Meteor.roles.findOne({\n        _id: roleName\n      }, {\n        fields: {\n          children: 1\n        }\n      });\n      if (!role) {\n        if (options.ifExists) {\n          return [];\n        } else {\n          throw new Error('Role \\'' + roleName + '\\' does not exist.');\n        }\n      }\n\n      // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n      var res = Meteor.roleAssignment.upsert({\n        'user._id': userId,\n        'role._id': roleName,\n        scope: options.scope\n      }, {\n        $setOnInsert: {\n          user: {\n            _id: userId\n          },\n          role: {\n            _id: roleName\n          },\n          scope: options.scope\n        }\n      });\n      if (res.insertedId) {\n        Meteor.roleAssignment.update({\n          _id: res.insertedId\n        }, {\n          $set: {\n            inheritedRoles: [roleName].concat(_toConsumableArray(Roles._getInheritedRoleNames(role))).map(function (r) {\n              return {\n                _id: r\n              };\n            })\n          }\n        });\n      }\n      return res;\n    },\n    /**\n     * Returns an array of role names the given role name is a child of.\n     *\n     * @example\n     *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getParentRoleNames\n     * @param {object} role The role object\n     * @private\n     * @static\n     */\n    _getParentRoleNames: function (role) {\n      if (!role) {\n        return [];\n      }\n      var parentRoles = new Set([role._id]);\n      parentRoles.forEach(function (roleName) {\n        Meteor.roles.find({\n          'children._id': roleName\n        }).fetch().forEach(function (parentRole) {\n          parentRoles.add(parentRole._id);\n        });\n      });\n      parentRoles.delete(role._id);\n      return _toConsumableArray(parentRoles);\n    },\n    /**\n     * Returns an array of role names the given role name is a parent of.\n     *\n     * @example\n     *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getInheritedRoleNames\n     * @param {object} role The role object\n     * @private\n     * @static\n     */\n    _getInheritedRoleNames: function (role) {\n      var inheritedRoles = new Set();\n      var nestedRoles = new Set([role]);\n      nestedRoles.forEach(function (r) {\n        var roles = Meteor.roles.find({\n          _id: {\n            $in: r.children.map(function (r) {\n              return r._id;\n            })\n          }\n        }, {\n          fields: {\n            children: 1\n          }\n        }).fetch();\n        roles.forEach(function (r2) {\n          inheritedRoles.add(r2._id);\n          nestedRoles.add(r2);\n        });\n      });\n      return _toConsumableArray(inheritedRoles);\n    },\n    /**\n     * Remove users from assigned roles.\n     *\n     * @example\n     *     Roles.removeUsersFromRoles(userId, 'admin')\n     *     Roles.removeUsersFromRoles([userId, user2], ['editor'])\n     *     Roles.removeUsersFromRoles(userId, ['user'], 'group1')\n     *\n     * @method removeUsersFromRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    removeUsersFromRoles: function (users, roles, options) {\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      users.forEach(function (user) {\n        if (!user) return;\n        roles.forEach(function (role) {\n          var id;\n          if (_typeof(user) === 'object') {\n            id = user._id;\n          } else {\n            id = user;\n          }\n          Roles._removeUserFromRole(id, role, options);\n        });\n      });\n    },\n    /**\n     * Remove one user from one role.\n     *\n     * @method _removeUserFromRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @private\n     * @static\n     */\n    _removeUserFromRole: function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n      Roles._checkScopeName(options.scope);\n      if (!userId) return;\n      var selector = {\n        'user._id': userId,\n        'role._id': roleName\n      };\n      if (!options.anyScope) {\n        selector.scope = options.scope;\n      }\n      Meteor.roleAssignment.remove(selector);\n    },\n    /**\n     * Check if user has specified roles.\n     *\n     * @example\n     *     // global roles\n     *     Roles.userIsInRole(user, 'admin')\n     *     Roles.userIsInRole(user, ['admin','editor'])\n     *     Roles.userIsInRole(userId, 'admin')\n     *     Roles.userIsInRole(userId, ['admin','editor'])\n     *\n     *     // scope roles (global roles are still checked)\n     *     Roles.userIsInRole(user, 'admin', 'group1')\n     *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n     *     Roles.userIsInRole(userId, ['admin','editor'], {scope: 'group1'})\n     *\n     * @method userIsInRole\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n     *                             will return `true` if user is in _any_ role.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope; if supplied, limits check to just that scope\n     *     the user's global roles will always be checked whether scope is specified or not\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Boolean} `true` if user is in _any_ of the target roles\n     * @static\n     */\n    userIsInRole: function (user, roles, options) {\n      var id;\n      options = Roles._normalizeOptions(options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      roles = roles.filter(function (r) {\n        return r != null;\n      });\n      if (!roles.length) return false;\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        anyScope: false\n      }, options);\n      if (user && _typeof(user) === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return false;\n      if (typeof id !== 'string') return false;\n      var selector = {\n        'user._id': id\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope, null]\n        };\n      }\n      return roles.some(function (roleName) {\n        selector['inheritedRoles._id'] = roleName;\n        return Meteor.roleAssignment.find(selector, {\n          limit: 1\n        }).count() > 0;\n      });\n    },\n    /**\n     * Retrieve user's roles.\n     *\n     * @method getRolesForUser\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n     *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n     *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n     *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n     *     result strongly dependent on the internal data structure of this plugin.\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Array} Array of user's roles, unsorted.\n     * @static\n     */\n    getRolesForUser: function (user, options) {\n      var id;\n      options = Roles._normalizeOptions(options);\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        fullObjects: false,\n        onlyAssigned: false,\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n      if (user && _typeof(user) === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return [];\n      var selector = {\n        'user._id': id\n      };\n      var filter = {\n        fields: {\n          'inheritedRoles._id': 1\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      if (options.onlyAssigned) {\n        delete filter.fields['inheritedRoles._id'];\n        filter.fields['role._id'] = 1;\n      }\n      if (options.fullObjects) {\n        delete filter.fields;\n      }\n      var roles = Meteor.roleAssignment.find(selector, filter).fetch();\n      if (options.fullObjects) {\n        return roles;\n      }\n      return _toConsumableArray(new Set(roles.reduce(function (rev, current) {\n        if (current.inheritedRoles) {\n          return rev.concat(current.inheritedRoles.map(function (r) {\n            return r._id;\n          }));\n        } else if (current.role) {\n          rev.push(current.role._id);\n        }\n        return rev;\n      }, [])));\n    },\n    /**\n     * Retrieve cursor of all existing roles.\n     *\n     * @method getAllRoles\n     * @param {Object} queryOptions Options which are passed directly\n     *                                through to `Meteor.roles.find(query, options)`.\n     * @return {Cursor} Cursor of existing roles.\n     * @static\n     */\n    getAllRoles: function (queryOptions) {\n      queryOptions = queryOptions || {\n        sort: {\n          _id: 1\n        }\n      };\n      return Meteor.roles.find({}, queryOptions);\n    },\n    /**\n     * Retrieve all users who are in target role.\n     *\n     * Options:\n     *\n     * @method getUsersInRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.users.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.users.find(query, options)`\n     * @return {Cursor} Cursor of users in roles.\n     * @static\n     */\n    getUsersInRole: function (roles, options, queryOptions) {\n      var ids = Roles.getUserAssignmentsForRole(roles, options).fetch().map(function (a) {\n        return a.user._id;\n      });\n      return Meteor.users.find({\n        _id: {\n          $in: ids\n        }\n      }, options && options.queryOptions || queryOptions || {});\n    },\n    /**\n     * Retrieve all assignments of a user which are for the target role.\n     *\n     * Options:\n     *\n     * @method getUserAssignmentsForRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.roleAssignment.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Cursor} Cursor of user assignments for roles.\n     * @static\n     */\n    getUserAssignmentsForRole: function (roles, options) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        queryOptions: {}\n      }, options);\n      return Roles._getUsersInRoleCursor(roles, options, options.queryOptions);\n    },\n    /**\n     * @method _getUsersInRoleCursor\n     * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n     *                             returned which have at least one of the roles\n     *                             assigned but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [filter] Options which are passed directly\n     *                                through to `Meteor.roleAssignment.find(query, options)`\n     * @return {Object} Cursor to the assignment documents\n     * @private\n     * @static\n     */\n    _getUsersInRoleCursor: function (roles, options, filter) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      filter = Object.assign({\n        fields: {\n          'user._id': 1\n        }\n      }, filter);\n      var selector = {\n        'inheritedRoles._id': {\n          $in: roles\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      return Meteor.roleAssignment.find(selector, filter);\n    },\n    /**\n     * Deprecated. Use `getScopesForUser` instead.\n     *\n     * @method getGroupsForUser\n     * @static\n     * @deprecated\n     */\n    getGroupsForUser: function () {\n      var _Roles;\n      if (!getGroupsForUserDeprecationWarning) {\n        getGroupsForUserDeprecationWarning = true;\n        console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.');\n      }\n      return (_Roles = Roles).getScopesForUser.apply(_Roles, arguments);\n    },\n    /**\n     * Retrieve users scopes, if any.\n     *\n     * @method getScopesForUser\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} [roles] Name of roles to restrict scopes to.\n     *\n     * @return {Array} Array of user's scopes, unsorted.\n     * @static\n     */\n    getScopesForUser: function (user, roles) {\n      var id;\n      if (roles && !Array.isArray(roles)) roles = [roles];\n      if (user && _typeof(user) === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return [];\n      var selector = {\n        'user._id': id,\n        scope: {\n          $ne: null\n        }\n      };\n      if (roles) {\n        selector['inheritedRoles._id'] = {\n          $in: roles\n        };\n      }\n      var scopes = Meteor.roleAssignment.find(selector, {\n        fields: {\n          scope: 1\n        }\n      }).fetch().map(function (obi) {\n        return obi.scope;\n      });\n      return _toConsumableArray(new Set(scopes));\n    },\n    /**\n     * Rename a scope.\n     *\n     * Roles assigned with a given scope are changed to be under the new scope.\n     *\n     * @method renameScope\n     * @param {String} oldName Old name of a scope.\n     * @param {String} newName New name of a scope.\n     * @static\n     */\n    renameScope: function (oldName, newName) {\n      var count;\n      Roles._checkScopeName(oldName);\n      Roles._checkScopeName(newName);\n      if (oldName === newName) return;\n      do {\n        count = Meteor.roleAssignment.update({\n          scope: oldName\n        }, {\n          $set: {\n            scope: newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n    },\n    /**\n     * Remove a scope.\n     *\n     * Roles assigned with a given scope are removed.\n     *\n     * @method removeScope\n     * @param {String} name The name of a scope.\n     * @static\n     */\n    removeScope: function (name) {\n      Roles._checkScopeName(name);\n      Meteor.roleAssignment.remove({\n        scope: name\n      });\n    },\n    /**\n     * Throw an exception if `roleName` is an invalid role name.\n     *\n     * @method _checkRoleName\n     * @param {String} roleName A role name to match against.\n     * @private\n     * @static\n     */\n    _checkRoleName: function (roleName) {\n      if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n        throw new Error('Invalid role name \\'' + roleName + '\\'.');\n      }\n    },\n    /**\n     * Find out if a role is an ancestor of another role.\n     *\n     * WARNING: If you check this on the client, please make sure all roles are published.\n     *\n     * @method isParentOf\n     * @param {String} parentRoleName The role you want to research.\n     * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n     * @static\n     */\n    isParentOf: function (parentRoleName, childRoleName) {\n      if (parentRoleName === childRoleName) {\n        return true;\n      }\n      if (parentRoleName == null || childRoleName == null) {\n        return false;\n      }\n      Roles._checkRoleName(parentRoleName);\n      Roles._checkRoleName(childRoleName);\n      var rolesToCheck = [parentRoleName];\n      while (rolesToCheck.length !== 0) {\n        var roleName = rolesToCheck.pop();\n        if (roleName === childRoleName) {\n          return true;\n        }\n        var role = Meteor.roles.findOne({\n          _id: roleName\n        });\n\n        // This should not happen, but this is a problem to address at some other time.\n        if (!role) continue;\n        rolesToCheck = rolesToCheck.concat(role.children.map(function (r) {\n          return r._id;\n        }));\n      }\n      return false;\n    },\n    /**\n     * Normalize options.\n     *\n     * @method _normalizeOptions\n     * @param {Object} options Options to normalize.\n     * @return {Object} Normalized options.\n     * @private\n     * @static\n     */\n    _normalizeOptions: function (options) {\n      options = options === undefined ? {} : options;\n      if (options === null || typeof options === 'string') {\n        options = {\n          scope: options\n        };\n      }\n      options.scope = Roles._normalizeScopeName(options.scope);\n      return options;\n    },\n    /**\n     * Normalize scope name.\n     *\n     * @method _normalizeScopeName\n     * @param {String} scopeName A scope name to normalize.\n     * @return {String} Normalized scope name.\n     * @private\n     * @static\n     */\n    _normalizeScopeName: function (scopeName) {\n      // map undefined and null to null\n      if (scopeName == null) {\n        return null;\n      } else {\n        return scopeName;\n      }\n    },\n    /**\n     * Throw an exception if `scopeName` is an invalid scope name.\n     *\n     * @method _checkRoleName\n     * @param {String} scopeName A scope name to match against.\n     * @private\n     * @static\n     */\n    _checkScopeName: function (scopeName) {\n      if (scopeName === null) return;\n      if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n        throw new Error('Invalid scope name \\'' + scopeName + '\\'.');\n      }\n    }\n  });\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"roles_common_async.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/roles_common_async.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  var _regeneratorRuntime;\n  module1.link(\"@babel/runtime/regenerator\", {\n    default: function (v) {\n      _regeneratorRuntime = v;\n    }\n  }, 0);\n  var _typeof;\n  module1.link(\"@babel/runtime/helpers/typeof\", {\n    default: function (v) {\n      _typeof = v;\n    }\n  }, 1);\n  var _toConsumableArray;\n  module1.link(\"@babel/runtime/helpers/toConsumableArray\", {\n    default: function (v) {\n      _toConsumableArray = v;\n    }\n  }, 2);\n  var _createForOfIteratorHelperLoose;\n  module1.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n    default: function (v) {\n      _createForOfIteratorHelperLoose = v;\n    }\n  }, 3);\n  var Meteor;\n  module1.link(\"meteor/meteor\", {\n    Meteor: function (v) {\n      Meteor = v;\n    }\n  }, 0);\n  var Mongo;\n  module1.link(\"meteor/mongo\", {\n    Mongo: function (v) {\n      Mongo = v;\n    }\n  }, 1);\n  /**\n   * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n   *\n   * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n   *  - `_id`: role name\n   *  - `children`: list of subdocuments:\n   *    - `_id`\n   *\n   * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n   *\n   * Roles can have multiple parents and can be children (subroles) of multiple roles.\n   *\n   * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n   *\n   * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n   * It's documents consist of\n   *  - `_id`: Internal MongoDB id\n   *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n   *  - `user`: A user object, usually only contains the `_id` property\n   *  - `scope`: scope name\n   *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n   *\n   * @module Roles\n   */\n  if (!Meteor.roles) {\n    Meteor.roles = new Mongo.Collection('roles');\n  }\n  if (!Meteor.roleAssignment) {\n    Meteor.roleAssignment = new Mongo.Collection('role-assignment');\n  }\n\n  /**\n   * @class Roles\n   */\n  if (typeof Roles === 'undefined') {\n    Roles = {}; // eslint-disable-line no-global-assign\n  }\n  var getGroupsForUserDeprecationWarning = false;\n\n  /**\n   * Helper, resolves async some\n   * @param {*} arr\n   * @param {*} predicate\n   * @returns {Promise<Boolean>}\n   */\n  var asyncSome = function () {\n    function _callee(arr, predicate) {\n      var _iterator, _step, e;\n      return _regeneratorRuntime.async(function () {\n        function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelperLoose(arr);\n            case 1:\n              if ((_step = _iterator()).done) {\n                _context.next = 9;\n                break;\n              }\n              e = _step.value;\n              _context.next = 5;\n              return _regeneratorRuntime.awrap(predicate(e));\n            case 5:\n              if (!_context.sent) {\n                _context.next = 7;\n                break;\n              }\n              return _context.abrupt(\"return\", true);\n            case 7:\n              _context.next = 1;\n              break;\n            case 9:\n              return _context.abrupt(\"return\", false);\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n        return _callee$;\n      }(), null, null, null, Promise);\n    }\n    return _callee;\n  }();\n  Object.assign(Roles, {\n    /**\n     * Used as a global group (now scope) name. Not used anymore.\n     *\n     * @property GLOBAL_GROUP\n     * @static\n     * @deprecated\n     */\n    GLOBAL_GROUP: null,\n    /**\n     * Create a new role.\n     *\n     * @method createRoleAsync\n     * @param {String} roleName Name of role.\n     * @param {Object} [options] Options:\n     *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n     * @return {Promise<String>} ID of the new role or null.\n     * @static\n     */\n    createRoleAsync: function () {\n      function _callee2(roleName, options) {\n        var insertedId, existingRole;\n        return _regeneratorRuntime.async(function () {\n          function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                Roles._checkRoleName(roleName);\n                options = Object.assign({\n                  unlessExists: false\n                }, options);\n                insertedId = null;\n                _context2.next = 5;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: roleName\n                }));\n              case 5:\n                existingRole = _context2.sent;\n                if (!existingRole) {\n                  _context2.next = 12;\n                  break;\n                }\n                _context2.next = 9;\n                return _regeneratorRuntime.awrap(Meteor.roles.updateAsync({\n                  _id: roleName\n                }, {\n                  $setOnInsert: {\n                    children: []\n                  }\n                }));\n              case 9:\n                return _context2.abrupt(\"return\", null);\n              case 12:\n                _context2.next = 14;\n                return _regeneratorRuntime.awrap(Meteor.roles.insertAsync({\n                  _id: roleName,\n                  children: []\n                }));\n              case 14:\n                insertedId = _context2.sent;\n              case 15:\n                if (insertedId) {\n                  _context2.next = 19;\n                  break;\n                }\n                if (!options.unlessExists) {\n                  _context2.next = 18;\n                  break;\n                }\n                return _context2.abrupt(\"return\", null);\n              case 18:\n                throw new Error(\"Role '\" + roleName + \"' already exists.\");\n              case 19:\n                return _context2.abrupt(\"return\", insertedId);\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n          return _callee2$;\n        }(), null, null, null, Promise);\n      }\n      return _callee2;\n    }(),\n    /**\n     * Delete an existing role.\n     *\n     * If the role is set for any user, it is automatically unset.\n     *\n     * @method deleteRoleAsync\n     * @param {String} roleName Name of role.\n     * @returns {Promise}\n     * @static\n     */\n    deleteRoleAsync: function () {\n      function _callee3(roleName) {\n        var roles, inheritedRoles, _iterator2, _step2, r;\n        return _regeneratorRuntime.async(function () {\n          function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                Roles._checkRoleName(roleName);\n\n                // Remove all assignments\n                _context3.next = 3;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.removeAsync({\n                  'role._id': roleName\n                }));\n              case 3:\n                _context3.t0 = Roles;\n                _context3.next = 6;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: roleName\n                }));\n              case 6:\n                _context3.t1 = _context3.sent;\n                roles = _context3.t0._getParentRoleNames.call(_context3.t0, _context3.t1);\n                _context3.t2 = _createForOfIteratorHelperLoose;\n                _context3.next = 11;\n                return _regeneratorRuntime.awrap(Meteor.roles.find({\n                  _id: {\n                    $in: roles\n                  }\n                }).fetchAsync());\n              case 11:\n                _context3.t3 = _context3.sent;\n                _iterator2 = (0, _context3.t2)(_context3.t3);\n              case 13:\n                if ((_step2 = _iterator2()).done) {\n                  _context3.next = 30;\n                  break;\n                }\n                r = _step2.value;\n                _context3.next = 17;\n                return _regeneratorRuntime.awrap(Meteor.roles.updateAsync({\n                  _id: r._id\n                }, {\n                  $pull: {\n                    children: {\n                      _id: roleName\n                    }\n                  }\n                }));\n              case 17:\n                _context3.t4 = _regeneratorRuntime;\n                _context3.t5 = Roles;\n                _context3.next = 21;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: r._id\n                }));\n              case 21:\n                _context3.t6 = _context3.sent;\n                _context3.t7 = _context3.t5._getInheritedRoleNamesAsync.call(_context3.t5, _context3.t6);\n                _context3.next = 25;\n                return _context3.t4.awrap.call(_context3.t4, _context3.t7);\n              case 25:\n                inheritedRoles = _context3.sent;\n                _context3.next = 28;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.updateAsync({\n                  'role._id': r._id\n                }, {\n                  $set: {\n                    inheritedRoles: [r._id].concat(_toConsumableArray(inheritedRoles)).map(function (r2) {\n                      return {\n                        _id: r2\n                      };\n                    })\n                  }\n                }, {\n                  multi: true\n                }));\n              case 28:\n                _context3.next = 13;\n                break;\n              case 30:\n                if (roles.length > 0) {\n                  _context3.next = 3;\n                  break;\n                }\n              case 31:\n                _context3.next = 33;\n                return _regeneratorRuntime.awrap(Meteor.roles.removeAsync({\n                  _id: roleName\n                }));\n              case 33:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n          return _callee3$;\n        }(), null, null, null, Promise);\n      }\n      return _callee3;\n    }(),\n    /**\n     * Rename an existing role.\n     *\n     * @method renameRoleAsync\n     * @param {String} oldName Old name of a role.\n     * @param {String} newName New name of a role.\n     * @returns {Promise}\n     * @static\n     */\n    renameRoleAsync: function () {\n      function _callee4(oldName, newName) {\n        var count, role;\n        return _regeneratorRuntime.async(function () {\n          function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                Roles._checkRoleName(oldName);\n                Roles._checkRoleName(newName);\n                if (!(oldName === newName)) {\n                  _context4.next = 4;\n                  break;\n                }\n                return _context4.abrupt(\"return\");\n              case 4:\n                _context4.next = 6;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: oldName\n                }));\n              case 6:\n                role = _context4.sent;\n                if (role) {\n                  _context4.next = 9;\n                  break;\n                }\n                throw new Error(\"Role '\" + oldName + \"' does not exist.\");\n              case 9:\n                role._id = newName;\n                _context4.next = 12;\n                return _regeneratorRuntime.awrap(Meteor.roles.insertAsync(role));\n              case 12:\n                _context4.next = 14;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.updateAsync({\n                  'role._id': oldName\n                }, {\n                  $set: {\n                    'role._id': newName\n                  }\n                }, {\n                  multi: true\n                }));\n              case 14:\n                count = _context4.sent;\n              case 15:\n                if (count > 0) {\n                  _context4.next = 12;\n                  break;\n                }\n              case 16:\n                _context4.next = 18;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.updateAsync({\n                  'inheritedRoles._id': oldName\n                }, {\n                  $set: {\n                    'inheritedRoles.$._id': newName\n                  }\n                }, {\n                  multi: true\n                }));\n              case 18:\n                count = _context4.sent;\n              case 19:\n                if (count > 0) {\n                  _context4.next = 16;\n                  break;\n                }\n              case 20:\n                _context4.next = 22;\n                return _regeneratorRuntime.awrap(Meteor.roles.updateAsync({\n                  'children._id': oldName\n                }, {\n                  $set: {\n                    'children.$._id': newName\n                  }\n                }, {\n                  multi: true\n                }));\n              case 22:\n                count = _context4.sent;\n              case 23:\n                if (count > 0) {\n                  _context4.next = 20;\n                  break;\n                }\n              case 24:\n                _context4.next = 26;\n                return _regeneratorRuntime.awrap(Meteor.roles.removeAsync({\n                  _id: oldName\n                }));\n              case 26:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n          return _callee4$;\n        }(), null, null, null, Promise);\n      }\n      return _callee4;\n    }(),\n    /**\n     * Add role parent to roles.\n     *\n     * Previous parents are kept (role can have multiple parents). For users which have the\n     * parent role set, new subroles are added automatically.\n     *\n     * @method addRolesToParentAsync\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @static\n     */\n    addRolesToParentAsync: function () {\n      function _callee5(rolesNames, parentName) {\n        var _iterator3, _step3, roleName;\n        return _regeneratorRuntime.async(function () {\n          function _callee5$(_context5) {\n            while (1) switch (_context5.prev = _context5.next) {\n              case 0:\n                // ensure arrays\n                if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n                _iterator3 = _createForOfIteratorHelperLoose(rolesNames);\n              case 2:\n                if ((_step3 = _iterator3()).done) {\n                  _context5.next = 8;\n                  break;\n                }\n                roleName = _step3.value;\n                _context5.next = 6;\n                return _regeneratorRuntime.awrap(Roles._addRoleToParentAsync(roleName, parentName));\n              case 6:\n                _context5.next = 2;\n                break;\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n          return _callee5$;\n        }(), null, null, null, Promise);\n      }\n      return _callee5;\n    }(),\n    /**\n     * @method _addRoleToParentAsync\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _addRoleToParentAsync: function () {\n      function _callee6(roleName, parentName) {\n        var role, count;\n        return _regeneratorRuntime.async(function () {\n          function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                Roles._checkRoleName(roleName);\n                Roles._checkRoleName(parentName);\n\n                // query to get role's children\n                _context6.next = 4;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: roleName\n                }));\n              case 4:\n                role = _context6.sent;\n                if (role) {\n                  _context6.next = 7;\n                  break;\n                }\n                throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n              case 7:\n                _context6.next = 9;\n                return _regeneratorRuntime.awrap(Roles._getInheritedRoleNamesAsync(role));\n              case 9:\n                if (!_context6.sent.includes(parentName)) {\n                  _context6.next = 11;\n                  break;\n                }\n                throw new Error(\"Roles '\" + roleName + \"' and '\" + parentName + \"' would form a cycle.\");\n              case 11:\n                _context6.next = 13;\n                return _regeneratorRuntime.awrap(Meteor.roles.updateAsync({\n                  _id: parentName,\n                  'children._id': {\n                    $ne: role._id\n                  }\n                }, {\n                  $push: {\n                    children: {\n                      _id: role._id\n                    }\n                  }\n                }));\n              case 13:\n                count = _context6.sent;\n                if (count) {\n                  _context6.next = 16;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 16:\n                _context6.t0 = _regeneratorRuntime;\n                _context6.t1 = Meteor.roleAssignment;\n                _context6.t2 = {\n                  'inheritedRoles._id': parentName\n                };\n                _context6.t3 = [role._id];\n                _context6.t4 = _toConsumableArray;\n                _context6.next = 23;\n                return _regeneratorRuntime.awrap(Roles._getInheritedRoleNamesAsync(role));\n              case 23:\n                _context6.t5 = _context6.sent;\n                _context6.t6 = (0, _context6.t4)(_context6.t5);\n                _context6.t7 = _context6.t3.concat.call(_context6.t3, _context6.t6).map(function (r) {\n                  return {\n                    _id: r\n                  };\n                });\n                _context6.t8 = {\n                  $each: _context6.t7\n                };\n                _context6.t9 = {\n                  inheritedRoles: _context6.t8\n                };\n                _context6.t10 = {\n                  $push: _context6.t9\n                };\n                _context6.t11 = {\n                  multi: true\n                };\n                _context6.t12 = _context6.t1.updateAsync.call(_context6.t1, _context6.t2, _context6.t10, _context6.t11);\n                _context6.next = 33;\n                return _context6.t0.awrap.call(_context6.t0, _context6.t12);\n              case 33:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n          return _callee6$;\n        }(), null, null, null, Promise);\n      }\n      return _callee6;\n    }(),\n    /**\n     * Remove role parent from roles.\n     *\n     * Other parents are kept (role can have multiple parents). For users which have the\n     * parent role set, removed subrole is removed automatically.\n     *\n     * @method removeRolesFromParentAsync\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @static\n     */\n    removeRolesFromParentAsync: function () {\n      function _callee7(rolesNames, parentName) {\n        var _iterator4, _step4, roleName;\n        return _regeneratorRuntime.async(function () {\n          function _callee7$(_context7) {\n            while (1) switch (_context7.prev = _context7.next) {\n              case 0:\n                // ensure arrays\n                if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n                _iterator4 = _createForOfIteratorHelperLoose(rolesNames);\n              case 2:\n                if ((_step4 = _iterator4()).done) {\n                  _context7.next = 8;\n                  break;\n                }\n                roleName = _step4.value;\n                _context7.next = 6;\n                return _regeneratorRuntime.awrap(Roles._removeRoleFromParentAsync(roleName, parentName));\n              case 6:\n                _context7.next = 2;\n                break;\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n          return _callee7$;\n        }(), null, null, null, Promise);\n      }\n      return _callee7;\n    }(),\n    /**\n     * @method _removeRoleFromParentAsync\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _removeRoleFromParentAsync: function () {\n      function _callee8(roleName, parentName) {\n        var role, count, roles, _iterator5, _step5, r, inheritedRoles;\n        return _regeneratorRuntime.async(function () {\n          function _callee8$(_context8) {\n            while (1) switch (_context8.prev = _context8.next) {\n              case 0:\n                Roles._checkRoleName(roleName);\n                Roles._checkRoleName(parentName);\n\n                // check for role existence\n                // this would not really be needed, but we are trying to match addRolesToParent\n                _context8.next = 4;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: roleName\n                }, {\n                  fields: {\n                    _id: 1\n                  }\n                }));\n              case 4:\n                role = _context8.sent;\n                if (role) {\n                  _context8.next = 7;\n                  break;\n                }\n                throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n              case 7:\n                _context8.next = 9;\n                return _regeneratorRuntime.awrap(Meteor.roles.updateAsync({\n                  _id: parentName\n                }, {\n                  $pull: {\n                    children: {\n                      _id: role._id\n                    }\n                  }\n                }));\n              case 9:\n                count = _context8.sent;\n                if (count) {\n                  _context8.next = 12;\n                  break;\n                }\n                return _context8.abrupt(\"return\");\n              case 12:\n                _context8.t0 = [];\n                _context8.t1 = _toConsumableArray;\n                _context8.t2 = _regeneratorRuntime;\n                _context8.t3 = Roles;\n                _context8.next = 18;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: parentName\n                }));\n              case 18:\n                _context8.t4 = _context8.sent;\n                _context8.t5 = _context8.t3._getParentRoleNamesAsync.call(_context8.t3, _context8.t4);\n                _context8.next = 22;\n                return _context8.t2.awrap.call(_context8.t2, _context8.t5);\n              case 22:\n                _context8.t6 = _context8.sent;\n                _context8.t7 = (0, _context8.t1)(_context8.t6);\n                _context8.t8 = [parentName];\n                roles = _context8.t0.concat.call(_context8.t0, _context8.t7, _context8.t8);\n                _context8.t9 = _createForOfIteratorHelperLoose;\n                _context8.next = 29;\n                return _regeneratorRuntime.awrap(Meteor.roles.find({\n                  _id: {\n                    $in: roles\n                  }\n                }).fetchAsync());\n              case 29:\n                _context8.t10 = _context8.sent;\n                _iterator5 = (0, _context8.t9)(_context8.t10);\n              case 31:\n                if ((_step5 = _iterator5()).done) {\n                  _context8.next = 46;\n                  break;\n                }\n                r = _step5.value;\n                _context8.t11 = _regeneratorRuntime;\n                _context8.t12 = Roles;\n                _context8.next = 37;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: r._id\n                }));\n              case 37:\n                _context8.t13 = _context8.sent;\n                _context8.t14 = _context8.t12._getInheritedRoleNamesAsync.call(_context8.t12, _context8.t13);\n                _context8.next = 41;\n                return _context8.t11.awrap.call(_context8.t11, _context8.t14);\n              case 41:\n                inheritedRoles = _context8.sent;\n                _context8.next = 44;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.updateAsync({\n                  'role._id': r._id,\n                  'inheritedRoles._id': role._id\n                }, {\n                  $set: {\n                    inheritedRoles: [r._id].concat(_toConsumableArray(inheritedRoles)).map(function (r2) {\n                      return {\n                        _id: r2\n                      };\n                    })\n                  }\n                }, {\n                  multi: true\n                }));\n              case 44:\n                _context8.next = 31;\n                break;\n              case 46:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n          return _callee8$;\n        }(), null, null, null, Promise);\n      }\n      return _callee8;\n    }(),\n    /**\n     * Add users to roles.\n     *\n     * Adds roles to existing roles for each user.\n     *\n     * @example\n     *     Roles.addUsersToRolesAsync(userId, 'admin')\n     *     Roles.addUsersToRolesAsync(userId, ['view-secrets'], 'example.com')\n     *     Roles.addUsersToRolesAsync([user1, user2], ['user','editor'])\n     *     Roles.addUsersToRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method addUsersToRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    addUsersToRolesAsync: function () {\n      function _callee9(users, roles, options) {\n        var id, _iterator6, _step6, user, _iterator7, _step7, role;\n        return _regeneratorRuntime.async(function () {\n          function _callee9$(_context9) {\n            while (1) switch (_context9.prev = _context9.next) {\n              case 0:\n                if (users) {\n                  _context9.next = 2;\n                  break;\n                }\n                throw new Error(\"Missing 'users' param.\");\n              case 2:\n                if (roles) {\n                  _context9.next = 4;\n                  break;\n                }\n                throw new Error(\"Missing 'roles' param.\");\n              case 4:\n                options = Roles._normalizeOptions(options);\n\n                // ensure arrays\n                if (!Array.isArray(users)) users = [users];\n                if (!Array.isArray(roles)) roles = [roles];\n                Roles._checkScopeName(options.scope);\n                options = Object.assign({\n                  ifExists: false\n                }, options);\n                _iterator6 = _createForOfIteratorHelperLoose(users);\n              case 10:\n                if ((_step6 = _iterator6()).done) {\n                  _context9.next = 22;\n                  break;\n                }\n                user = _step6.value;\n                if (_typeof(user) === 'object') {\n                  id = user._id;\n                } else {\n                  id = user;\n                }\n                _iterator7 = _createForOfIteratorHelperLoose(roles);\n              case 14:\n                if ((_step7 = _iterator7()).done) {\n                  _context9.next = 20;\n                  break;\n                }\n                role = _step7.value;\n                _context9.next = 18;\n                return _regeneratorRuntime.awrap(Roles._addUserToRoleAsync(id, role, options));\n              case 18:\n                _context9.next = 14;\n                break;\n              case 20:\n                _context9.next = 10;\n                break;\n              case 22:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n          return _callee9$;\n        }(), null, null, null, Promise);\n      }\n      return _callee9;\n    }(),\n    /**\n     * Set users' roles.\n     *\n     * Replaces all existing roles with a new set of roles.\n     *\n     * @example\n     *     await Roles.setUserRolesAsync(userId, 'admin')\n     *     await Roles.setUserRolesAsync(userId, ['view-secrets'], 'example.com')\n     *     await Roles.setUserRolesAsync([user1, user2], ['user','editor'])\n     *     await Roles.setUserRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method setUserRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    setUserRolesAsync: function () {\n      function _callee10(users, roles, options) {\n        var id, _iterator8, _step8, user, selector, _iterator9, _step9, role;\n        return _regeneratorRuntime.async(function () {\n          function _callee10$(_context10) {\n            while (1) switch (_context10.prev = _context10.next) {\n              case 0:\n                if (users) {\n                  _context10.next = 2;\n                  break;\n                }\n                throw new Error(\"Missing 'users' param.\");\n              case 2:\n                if (roles) {\n                  _context10.next = 4;\n                  break;\n                }\n                throw new Error(\"Missing 'roles' param.\");\n              case 4:\n                options = Roles._normalizeOptions(options);\n\n                // ensure arrays\n                if (!Array.isArray(users)) users = [users];\n                if (!Array.isArray(roles)) roles = [roles];\n                Roles._checkScopeName(options.scope);\n                options = Object.assign({\n                  ifExists: false,\n                  anyScope: false\n                }, options);\n                _iterator8 = _createForOfIteratorHelperLoose(users);\n              case 10:\n                if ((_step8 = _iterator8()).done) {\n                  _context10.next = 26;\n                  break;\n                }\n                user = _step8.value;\n                if (_typeof(user) === 'object') {\n                  id = user._id;\n                } else {\n                  id = user;\n                }\n                // we first clear all roles for the user\n                selector = {\n                  'user._id': id\n                };\n                if (!options.anyScope) {\n                  selector.scope = options.scope;\n                }\n                _context10.next = 17;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.removeAsync(selector));\n              case 17:\n                _iterator9 = _createForOfIteratorHelperLoose(roles);\n              case 18:\n                if ((_step9 = _iterator9()).done) {\n                  _context10.next = 24;\n                  break;\n                }\n                role = _step9.value;\n                _context10.next = 22;\n                return _regeneratorRuntime.awrap(Roles._addUserToRole(id, role, options));\n              case 22:\n                _context10.next = 18;\n                break;\n              case 24:\n                _context10.next = 10;\n                break;\n              case 26:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n          return _callee10$;\n        }(), null, null, null, Promise);\n      }\n      return _callee10;\n    }(),\n    /**\n     * Add one user to one role.\n     *\n     * @method _addUserToRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _addUserToRoleAsync: function () {\n      function _callee11(userId, roleName, options) {\n        var role, existingAssignment, insertedId, res;\n        return _regeneratorRuntime.async(function () {\n          function _callee11$(_context11) {\n            while (1) switch (_context11.prev = _context11.next) {\n              case 0:\n                Roles._checkRoleName(roleName);\n                Roles._checkScopeName(options.scope);\n                if (userId) {\n                  _context11.next = 4;\n                  break;\n                }\n                return _context11.abrupt(\"return\");\n              case 4:\n                _context11.next = 6;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: roleName\n                }, {\n                  fields: {\n                    children: 1\n                  }\n                }));\n              case 6:\n                role = _context11.sent;\n                if (role) {\n                  _context11.next = 13;\n                  break;\n                }\n                if (!options.ifExists) {\n                  _context11.next = 12;\n                  break;\n                }\n                return _context11.abrupt(\"return\", []);\n              case 12:\n                throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n              case 13:\n                _context11.next = 15;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.findOneAsync({\n                  'user._id': userId,\n                  'role._id': roleName,\n                  scope: options.scope\n                }));\n              case 15:\n                existingAssignment = _context11.sent;\n                if (!existingAssignment) {\n                  _context11.next = 24;\n                  break;\n                }\n                _context11.next = 19;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.updateAsync(existingAssignment._id, {\n                  $set: {\n                    user: {\n                      _id: userId\n                    },\n                    role: {\n                      _id: roleName\n                    },\n                    scope: options.scope\n                  }\n                }));\n              case 19:\n                _context11.next = 21;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.findOneAsync(existingAssignment._id));\n              case 21:\n                res = _context11.sent;\n                _context11.next = 27;\n                break;\n              case 24:\n                _context11.next = 26;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.insertAsync({\n                  user: {\n                    _id: userId\n                  },\n                  role: {\n                    _id: roleName\n                  },\n                  scope: options.scope\n                }));\n              case 26:\n                insertedId = _context11.sent;\n              case 27:\n                if (!insertedId) {\n                  _context11.next = 46;\n                  break;\n                }\n                _context11.t0 = _regeneratorRuntime;\n                _context11.t1 = Meteor.roleAssignment;\n                _context11.t2 = {\n                  _id: insertedId\n                };\n                _context11.t3 = [roleName];\n                _context11.t4 = _toConsumableArray;\n                _context11.next = 35;\n                return _regeneratorRuntime.awrap(Roles._getInheritedRoleNamesAsync(role));\n              case 35:\n                _context11.t5 = _context11.sent;\n                _context11.t6 = (0, _context11.t4)(_context11.t5);\n                _context11.t7 = _context11.t3.concat.call(_context11.t3, _context11.t6).map(function (r) {\n                  return {\n                    _id: r\n                  };\n                });\n                _context11.t8 = {\n                  inheritedRoles: _context11.t7\n                };\n                _context11.t9 = {\n                  $set: _context11.t8\n                };\n                _context11.t10 = _context11.t1.updateAsync.call(_context11.t1, _context11.t2, _context11.t9);\n                _context11.next = 43;\n                return _context11.t0.awrap.call(_context11.t0, _context11.t10);\n              case 43:\n                _context11.next = 45;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.findOneAsync({\n                  _id: insertedId\n                }));\n              case 45:\n                res = _context11.sent;\n              case 46:\n                res.insertedId = insertedId; // For backward compatibility\n                return _context11.abrupt(\"return\", res);\n              case 48:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n          return _callee11$;\n        }(), null, null, null, Promise);\n      }\n      return _callee11;\n    }(),\n    /**\n     * Returns an array of role names the given role name is a child of.\n     *\n     * @example\n     *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getParentRoleNames\n     * @param {object} role The role object\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _getParentRoleNamesAsync: function () {\n      function _callee12(role) {\n        var parentRoles, _iterator10, _step10, roleName, _iterator11, _step11, parentRole;\n        return _regeneratorRuntime.async(function () {\n          function _callee12$(_context12) {\n            while (1) switch (_context12.prev = _context12.next) {\n              case 0:\n                if (role) {\n                  _context12.next = 2;\n                  break;\n                }\n                return _context12.abrupt(\"return\", []);\n              case 2:\n                parentRoles = new Set([role._id]);\n                _iterator10 = _createForOfIteratorHelperLoose(parentRoles);\n              case 4:\n                if ((_step10 = _iterator10()).done) {\n                  _context12.next = 18;\n                  break;\n                }\n                roleName = _step10.value;\n                _context12.t0 = _createForOfIteratorHelperLoose;\n                _context12.next = 9;\n                return _regeneratorRuntime.awrap(Meteor.roles.find({\n                  'children._id': roleName\n                }).fetchAsync());\n              case 9:\n                _context12.t1 = _context12.sent;\n                _iterator11 = (0, _context12.t0)(_context12.t1);\n              case 11:\n                if ((_step11 = _iterator11()).done) {\n                  _context12.next = 16;\n                  break;\n                }\n                parentRole = _step11.value;\n                parentRoles.add(parentRole._id);\n              case 14:\n                _context12.next = 11;\n                break;\n              case 16:\n                _context12.next = 4;\n                break;\n              case 18:\n                parentRoles.delete(role._id);\n                return _context12.abrupt(\"return\", _toConsumableArray(parentRoles));\n              case 20:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n          return _callee12$;\n        }(), null, null, null, Promise);\n      }\n      return _callee12;\n    }(),\n    /**\n     * Returns an array of role names the given role name is a parent of.\n     *\n     * @example\n     *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getInheritedRoleNames\n     * @param {object} role The role object\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _getInheritedRoleNamesAsync: function () {\n      function _callee13(role) {\n        var inheritedRoles, nestedRoles, _iterator12, _step12, r, roles, _iterator13, _step13, r2;\n        return _regeneratorRuntime.async(function () {\n          function _callee13$(_context13) {\n            while (1) switch (_context13.prev = _context13.next) {\n              case 0:\n                inheritedRoles = new Set();\n                nestedRoles = new Set([role]);\n                _iterator12 = _createForOfIteratorHelperLoose(nestedRoles);\n              case 3:\n                if ((_step12 = _iterator12()).done) {\n                  _context13.next = 11;\n                  break;\n                }\n                r = _step12.value;\n                _context13.next = 7;\n                return _regeneratorRuntime.awrap(Meteor.roles.find({\n                  _id: {\n                    $in: r.children.map(function (r) {\n                      return r._id;\n                    })\n                  }\n                }, {\n                  fields: {\n                    children: 1\n                  }\n                }).fetchAsync());\n              case 7:\n                roles = _context13.sent;\n                for (_iterator13 = _createForOfIteratorHelperLoose(roles); !(_step13 = _iterator13()).done;) {\n                  r2 = _step13.value;\n                  inheritedRoles.add(r2._id);\n                  nestedRoles.add(r2);\n                }\n              case 9:\n                _context13.next = 3;\n                break;\n              case 11:\n                return _context13.abrupt(\"return\", _toConsumableArray(inheritedRoles));\n              case 12:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n          return _callee13$;\n        }(), null, null, null, Promise);\n      }\n      return _callee13;\n    }(),\n    /**\n     * Remove users from assigned roles.\n     *\n     * @example\n     *     await Roles.removeUsersFromRolesAsync(userId, 'admin')\n     *     await Roles.removeUsersFromRolesAsync([userId, user2], ['editor'])\n     *     await Roles.removeUsersFromRolesAsync(userId, ['user'], 'group1')\n     *\n     * @method removeUsersFromRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    removeUsersFromRolesAsync: function () {\n      function _callee14(users, roles, options) {\n        var _iterator14, _step14, user, _iterator15, _step15, role, id;\n        return _regeneratorRuntime.async(function () {\n          function _callee14$(_context14) {\n            while (1) switch (_context14.prev = _context14.next) {\n              case 0:\n                if (users) {\n                  _context14.next = 2;\n                  break;\n                }\n                throw new Error(\"Missing 'users' param.\");\n              case 2:\n                if (roles) {\n                  _context14.next = 4;\n                  break;\n                }\n                throw new Error(\"Missing 'roles' param.\");\n              case 4:\n                options = Roles._normalizeOptions(options);\n\n                // ensure arrays\n                if (!Array.isArray(users)) users = [users];\n                if (!Array.isArray(roles)) roles = [roles];\n                Roles._checkScopeName(options.scope);\n                _iterator14 = _createForOfIteratorHelperLoose(users);\n              case 9:\n                if ((_step14 = _iterator14()).done) {\n                  _context14.next = 24;\n                  break;\n                }\n                user = _step14.value;\n                if (user) {\n                  _context14.next = 13;\n                  break;\n                }\n                return _context14.abrupt(\"return\");\n              case 13:\n                _iterator15 = _createForOfIteratorHelperLoose(roles);\n              case 14:\n                if ((_step15 = _iterator15()).done) {\n                  _context14.next = 22;\n                  break;\n                }\n                role = _step15.value;\n                id = void 0;\n                if (_typeof(user) === 'object') {\n                  id = user._id;\n                } else {\n                  id = user;\n                }\n                _context14.next = 20;\n                return _regeneratorRuntime.awrap(Roles._removeUserFromRoleAsync(id, role, options));\n              case 20:\n                _context14.next = 14;\n                break;\n              case 22:\n                _context14.next = 9;\n                break;\n              case 24:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n          return _callee14$;\n        }(), null, null, null, Promise);\n      }\n      return _callee14;\n    }(),\n    /**\n     * Remove one user from one role.\n     *\n     * @method _removeUserFromRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _removeUserFromRoleAsync: function () {\n      function _callee15(userId, roleName, options) {\n        var selector;\n        return _regeneratorRuntime.async(function () {\n          function _callee15$(_context15) {\n            while (1) switch (_context15.prev = _context15.next) {\n              case 0:\n                Roles._checkRoleName(roleName);\n                Roles._checkScopeName(options.scope);\n                if (userId) {\n                  _context15.next = 4;\n                  break;\n                }\n                return _context15.abrupt(\"return\");\n              case 4:\n                selector = {\n                  'user._id': userId,\n                  'role._id': roleName\n                };\n                if (!options.anyScope) {\n                  selector.scope = options.scope;\n                }\n                _context15.next = 8;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.removeAsync(selector));\n              case 8:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n          return _callee15$;\n        }(), null, null, null, Promise);\n      }\n      return _callee15;\n    }(),\n    /**\n     * Check if user has specified roles.\n     *\n     * @example\n     *     // global roles\n     *     await Roles.userIsInRoleAsync(user, 'admin')\n     *     await Roles.userIsInRoleAsync(user, ['admin','editor'])\n     *     await Roles.userIsInRoleAsync(userId, 'admin')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'])\n     *\n     *     // scope roles (global roles are still checked)\n     *     await Roles.userIsInRoleAsync(user, 'admin', 'group1')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], 'group1')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], {scope: 'group1'})\n     *\n     * @method userIsInRoleAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n     *                             will return `true` if user is in _any_ role.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope; if supplied, limits check to just that scope\n     *     the user's global roles will always be checked whether scope is specified or not\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Promise<Boolean>} `true` if user is in _any_ of the target roles\n     * @static\n     */\n    userIsInRoleAsync: function () {\n      function _callee17(user, roles, options) {\n        var id, selector, res;\n        return _regeneratorRuntime.async(function () {\n          function _callee17$(_context17) {\n            while (1) switch (_context17.prev = _context17.next) {\n              case 0:\n                options = Roles._normalizeOptions(options);\n\n                // ensure array to simplify code\n                if (!Array.isArray(roles)) roles = [roles];\n                roles = roles.filter(function (r) {\n                  return r != null;\n                });\n                if (roles.length) {\n                  _context17.next = 5;\n                  break;\n                }\n                return _context17.abrupt(\"return\", false);\n              case 5:\n                Roles._checkScopeName(options.scope);\n                options = Object.assign({\n                  anyScope: false\n                }, options);\n                if (user && _typeof(user) === 'object') {\n                  id = user._id;\n                } else {\n                  id = user;\n                }\n                if (id) {\n                  _context17.next = 10;\n                  break;\n                }\n                return _context17.abrupt(\"return\", false);\n              case 10:\n                if (!(typeof id !== 'string')) {\n                  _context17.next = 12;\n                  break;\n                }\n                return _context17.abrupt(\"return\", false);\n              case 12:\n                selector = {\n                  'user._id': id\n                };\n                if (!options.anyScope) {\n                  selector.scope = {\n                    $in: [options.scope, null]\n                  };\n                }\n                _context17.next = 16;\n                return _regeneratorRuntime.awrap(asyncSome(roles, function () {\n                  function _callee16(roleName) {\n                    var out;\n                    return _regeneratorRuntime.async(function () {\n                      function _callee16$(_context16) {\n                        while (1) switch (_context16.prev = _context16.next) {\n                          case 0:\n                            selector['inheritedRoles._id'] = roleName;\n                            _context16.next = 3;\n                            return _regeneratorRuntime.awrap(Meteor.roleAssignment.find(selector, {\n                              limit: 1\n                            }).countAsync());\n                          case 3:\n                            _context16.t0 = _context16.sent;\n                            out = _context16.t0 > 0;\n                            return _context16.abrupt(\"return\", out);\n                          case 6:\n                          case \"end\":\n                            return _context16.stop();\n                        }\n                      }\n                      return _callee16$;\n                    }(), null, null, null, Promise);\n                  }\n                  return _callee16;\n                }()));\n              case 16:\n                res = _context17.sent;\n                return _context17.abrupt(\"return\", res);\n              case 18:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n          return _callee17$;\n        }(), null, null, null, Promise);\n      }\n      return _callee17;\n    }(),\n    /**\n     * Retrieve user's roles.\n     *\n     * @method getRolesForUserAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n     *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n     *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n     *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n     *     result strongly dependent on the internal data structure of this plugin.\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Promise<Array>} Array of user's roles, unsorted.\n     * @static\n     */\n    getRolesForUserAsync: function () {\n      function _callee18(user, options) {\n        var id, selector, filter, roles;\n        return _regeneratorRuntime.async(function () {\n          function _callee18$(_context18) {\n            while (1) switch (_context18.prev = _context18.next) {\n              case 0:\n                options = Roles._normalizeOptions(options);\n                Roles._checkScopeName(options.scope);\n                options = Object.assign({\n                  fullObjects: false,\n                  onlyAssigned: false,\n                  anyScope: false,\n                  onlyScoped: false\n                }, options);\n                if (user && _typeof(user) === 'object') {\n                  id = user._id;\n                } else {\n                  id = user;\n                }\n                if (id) {\n                  _context18.next = 6;\n                  break;\n                }\n                return _context18.abrupt(\"return\", []);\n              case 6:\n                selector = {\n                  'user._id': id\n                };\n                filter = {\n                  fields: {\n                    'inheritedRoles._id': 1\n                  }\n                };\n                if (!options.anyScope) {\n                  selector.scope = {\n                    $in: [options.scope]\n                  };\n                  if (!options.onlyScoped) {\n                    selector.scope.$in.push(null);\n                  }\n                }\n                if (options.onlyAssigned) {\n                  delete filter.fields['inheritedRoles._id'];\n                  filter.fields['role._id'] = 1;\n                }\n                if (options.fullObjects) {\n                  delete filter.fields;\n                }\n                _context18.next = 13;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.find(selector, filter).fetchAsync());\n              case 13:\n                roles = _context18.sent;\n                if (!options.fullObjects) {\n                  _context18.next = 16;\n                  break;\n                }\n                return _context18.abrupt(\"return\", roles);\n              case 16:\n                return _context18.abrupt(\"return\", _toConsumableArray(new Set(roles.reduce(function (rev, current) {\n                  if (current.inheritedRoles) {\n                    return rev.concat(current.inheritedRoles.map(function (r) {\n                      return r._id;\n                    }));\n                  } else if (current.role) {\n                    rev.push(current.role._id);\n                  }\n                  return rev;\n                }, []))));\n              case 17:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n          return _callee18$;\n        }(), null, null, null, Promise);\n      }\n      return _callee18;\n    }(),\n    /**\n     * Retrieve cursor of all existing roles.\n     *\n     * @method getAllRoles\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.roles.find(query, options)`.\n     * @return {Cursor} Cursor of existing roles.\n     * @static\n     */\n    getAllRoles: function (queryOptions) {\n      queryOptions = queryOptions || {\n        sort: {\n          _id: 1\n        }\n      };\n      return Meteor.roles.find({}, queryOptions);\n    },\n    /**\n     * Retrieve all users who are in target role.\n     *\n     * Options:\n     *\n     * @method getUsersInRoleAsync\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.users.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.users.find(query, options)`\n     * @return {Promise<Cursor>} Cursor of users in roles.\n     * @static\n     */\n    getUsersInRoleAsync: function () {\n      function _callee19(roles, options, queryOptions) {\n        var ids;\n        return _regeneratorRuntime.async(function () {\n          function _callee19$(_context19) {\n            while (1) switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return _regeneratorRuntime.awrap(Roles.getUserAssignmentsForRole(roles, options).fetchAsync());\n              case 2:\n                ids = _context19.sent.map(function (a) {\n                  return a.user._id;\n                });\n                return _context19.abrupt(\"return\", Meteor.users.find({\n                  _id: {\n                    $in: ids\n                  }\n                }, options && options.queryOptions || queryOptions || {}));\n              case 4:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n          return _callee19$;\n        }(), null, null, null, Promise);\n      }\n      return _callee19;\n    }(),\n    /**\n     * Retrieve all assignments of a user which are for the target role.\n     *\n     * Options:\n     *\n     * @method getUserAssignmentsForRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.roleAssignment.find(query, options)`\n      * Alternatively, it can be a scope name string.\n     * @return {Cursor} Cursor of user assignments for roles.\n     * @static\n     */\n    getUserAssignmentsForRole: function (roles, options) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        queryOptions: {}\n      }, options);\n      return Roles._getUsersInRoleCursor(roles, options, options.queryOptions);\n    },\n    /**\n     * @method _getUsersInRoleCursor\n     * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n     *                             returned which have at least one of the roles\n     *                             assigned but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [filter] Options which are passed directly\n     *                                through to `Meteor.roleAssignment.find(query, options)`\n     * @return {Object} Cursor to the assignment documents\n     * @private\n     * @static\n     */\n    _getUsersInRoleCursor: function (roles, options, filter) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      filter = Object.assign({\n        fields: {\n          'user._id': 1\n        }\n      }, filter);\n      var selector = {\n        'inheritedRoles._id': {\n          $in: roles\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      return Meteor.roleAssignment.find(selector, filter);\n    },\n    /**\n     * Deprecated. Use `getScopesForUser` instead.\n     *\n     * @method getGroupsForUserAsync\n     * @returns {Promise<Array>}\n     * @static\n     * @deprecated\n     */\n    getGroupsForUserAsync: function () {\n      function _callee20() {\n        var _Roles;\n        var _args20 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function _callee20$(_context20) {\n            while (1) switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!getGroupsForUserDeprecationWarning) {\n                  getGroupsForUserDeprecationWarning = true;\n                  console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.');\n                }\n                _context20.next = 3;\n                return _regeneratorRuntime.awrap((_Roles = Roles).getScopesForUser.apply(_Roles, _args20));\n              case 3:\n                return _context20.abrupt(\"return\", _context20.sent);\n              case 4:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n          return _callee20$;\n        }(), null, null, null, Promise);\n      }\n      return _callee20;\n    }(),\n    /**\n     * Retrieve users scopes, if any.\n     *\n     * @method getScopesForUserAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} [roles] Name of roles to restrict scopes to.\n     *\n     * @return {Promise<Array>} Array of user's scopes, unsorted.\n     * @static\n     */\n    getScopesForUserAsync: function () {\n      function _callee21(user, roles) {\n        var id, selector, scopes;\n        return _regeneratorRuntime.async(function () {\n          function _callee21$(_context21) {\n            while (1) switch (_context21.prev = _context21.next) {\n              case 0:\n                if (roles && !Array.isArray(roles)) roles = [roles];\n                if (user && _typeof(user) === 'object') {\n                  id = user._id;\n                } else {\n                  id = user;\n                }\n                if (id) {\n                  _context21.next = 4;\n                  break;\n                }\n                return _context21.abrupt(\"return\", []);\n              case 4:\n                selector = {\n                  'user._id': id,\n                  scope: {\n                    $ne: null\n                  }\n                };\n                if (roles) {\n                  selector['inheritedRoles._id'] = {\n                    $in: roles\n                  };\n                }\n                _context21.next = 8;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.find(selector, {\n                  fields: {\n                    scope: 1\n                  }\n                }).fetchAsync());\n              case 8:\n                scopes = _context21.sent.map(function (obi) {\n                  return obi.scope;\n                });\n                return _context21.abrupt(\"return\", _toConsumableArray(new Set(scopes)));\n              case 10:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n          return _callee21$;\n        }(), null, null, null, Promise);\n      }\n      return _callee21;\n    }(),\n    /**\n     * Rename a scope.\n     *\n     * Roles assigned with a given scope are changed to be under the new scope.\n     *\n     * @method renameScopeAsync\n     * @param {String} oldName Old name of a scope.\n     * @param {String} newName New name of a scope.\n     * @returns {Promise}\n     * @static\n     */\n    renameScopeAsync: function () {\n      function _callee22(oldName, newName) {\n        var count;\n        return _regeneratorRuntime.async(function () {\n          function _callee22$(_context22) {\n            while (1) switch (_context22.prev = _context22.next) {\n              case 0:\n                Roles._checkScopeName(oldName);\n                Roles._checkScopeName(newName);\n                if (!(oldName === newName)) {\n                  _context22.next = 4;\n                  break;\n                }\n                return _context22.abrupt(\"return\");\n              case 4:\n                _context22.next = 6;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.updateAsync({\n                  scope: oldName\n                }, {\n                  $set: {\n                    scope: newName\n                  }\n                }, {\n                  multi: true\n                }));\n              case 6:\n                count = _context22.sent;\n              case 7:\n                if (count > 0) {\n                  _context22.next = 4;\n                  break;\n                }\n              case 8:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n          return _callee22$;\n        }(), null, null, null, Promise);\n      }\n      return _callee22;\n    }(),\n    /**\n     * Remove a scope.\n     *\n     * Roles assigned with a given scope are removed.\n     *\n     * @method removeScopeAsync\n     * @param {String} name The name of a scope.\n     * @returns {Promise}\n     * @static\n     */\n    removeScopeAsync: function () {\n      function _callee23(name) {\n        return _regeneratorRuntime.async(function () {\n          function _callee23$(_context23) {\n            while (1) switch (_context23.prev = _context23.next) {\n              case 0:\n                Roles._checkScopeName(name);\n                _context23.next = 3;\n                return _regeneratorRuntime.awrap(Meteor.roleAssignment.removeAsync({\n                  scope: name\n                }));\n              case 3:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n          return _callee23$;\n        }(), null, null, null, Promise);\n      }\n      return _callee23;\n    }(),\n    /**\n     * Throw an exception if `roleName` is an invalid role name.\n     *\n     * @method _checkRoleName\n     * @param {String} roleName A role name to match against.\n     * @private\n     * @static\n     */\n    _checkRoleName: function (roleName) {\n      if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n        throw new Error(\"Invalid role name '\" + roleName + \"'.\");\n      }\n    },\n    /**\n     * Find out if a role is an ancestor of another role.\n     *\n     * WARNING: If you check this on the client, please make sure all roles are published.\n     *\n     * @method isParentOfAsync\n     * @param {String} parentRoleName The role you want to research.\n     * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n     * @returns {Promise}\n     * @static\n     */\n    isParentOfAsync: function () {\n      function _callee24(parentRoleName, childRoleName) {\n        var rolesToCheck, roleName, role;\n        return _regeneratorRuntime.async(function () {\n          function _callee24$(_context24) {\n            while (1) switch (_context24.prev = _context24.next) {\n              case 0:\n                if (!(parentRoleName === childRoleName)) {\n                  _context24.next = 2;\n                  break;\n                }\n                return _context24.abrupt(\"return\", true);\n              case 2:\n                if (!(parentRoleName == null || childRoleName == null)) {\n                  _context24.next = 4;\n                  break;\n                }\n                return _context24.abrupt(\"return\", false);\n              case 4:\n                Roles._checkRoleName(parentRoleName);\n                Roles._checkRoleName(childRoleName);\n                rolesToCheck = [parentRoleName];\n              case 7:\n                if (!(rolesToCheck.length !== 0)) {\n                  _context24.next = 19;\n                  break;\n                }\n                roleName = rolesToCheck.pop();\n                if (!(roleName === childRoleName)) {\n                  _context24.next = 11;\n                  break;\n                }\n                return _context24.abrupt(\"return\", true);\n              case 11:\n                _context24.next = 13;\n                return _regeneratorRuntime.awrap(Meteor.roles.findOneAsync({\n                  _id: roleName\n                }));\n              case 13:\n                role = _context24.sent;\n                if (role) {\n                  _context24.next = 16;\n                  break;\n                }\n                return _context24.abrupt(\"continue\", 7);\n              case 16:\n                rolesToCheck = rolesToCheck.concat(role.children.map(function (r) {\n                  return r._id;\n                }));\n                _context24.next = 7;\n                break;\n              case 19:\n                return _context24.abrupt(\"return\", false);\n              case 20:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n          return _callee24$;\n        }(), null, null, null, Promise);\n      }\n      return _callee24;\n    }(),\n    /**\n     * Normalize options.\n     *\n     * @method _normalizeOptions\n     * @param {Object} options Options to normalize.\n     * @return {Object} Normalized options.\n     * @private\n     * @static\n     */\n    _normalizeOptions: function (options) {\n      options = options === undefined ? {} : options;\n      if (options === null || typeof options === 'string') {\n        options = {\n          scope: options\n        };\n      }\n      options.scope = Roles._normalizeScopeName(options.scope);\n      return options;\n    },\n    /**\n     * Normalize scope name.\n     *\n     * @method _normalizeScopeName\n     * @param {String} scopeName A scope name to normalize.\n     * @return {String} Normalized scope name.\n     * @private\n     * @static\n     */\n    _normalizeScopeName: function (scopeName) {\n      // map undefined and null to null\n      if (scopeName == null) {\n        return null;\n      } else {\n        return scopeName;\n      }\n    },\n    /**\n     * Throw an exception if `scopeName` is an invalid scope name.\n     *\n     * @method _checkRoleName\n     * @param {String} scopeName A scope name to match against.\n     * @private\n     * @static\n     */\n    _checkScopeName: function (scopeName) {\n      if (scopeName === null) return;\n      if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n        throw new Error(\"Invalid scope name '\" + scopeName + \"'.\");\n      }\n    }\n  });\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"client\":{\"debug.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/client/debug.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Roles, localStorage */\n\n// //////////////////////////////////////////////////////////\n// Debugging helpers\n//\n// Run this in your browser console to turn on debugging\n// for this package:\n//\n//   localstorage.setItem('Roles.debug', true)\n//\n\nRoles.debug = false;\ntry {\n  if (localStorage) {\n    var temp = localStorage.getItem('Roles.debug');\n    if (typeof temp !== 'undefined') {\n      Roles.debug = !!temp;\n    }\n  }\n} catch (ex) {\n  // ignore: accessing localStorage when its disabled throws\n  // https://github.com/meteor/meteor/issues/5759\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"uiHelpers.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/client/uiHelpers.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  var _slicedToArray;\n  module1.link(\"@babel/runtime/helpers/slicedToArray\", {\n    default: function (v) {\n      _slicedToArray = v;\n    }\n  }, 0);\n  /* global Meteor, Roles, Match, Package */\n\n  /**\n   * Convenience functions for use on client.\n   *\n   * NOTE: You must restrict user actions on the server-side; any\n   * client-side checks are strictly for convenience and must not be\n   * trusted.\n   *\n   * @module UIHelpers\n   */\n\n  // //////////////////////////////////////////////////////////\n  // UI helpers\n  //\n  // Use a semi-private variable rather than declaring UI\n  // helpers directly so that we can unit test the helpers.\n  // XXX For some reason, the UI helpers are not registered\n  // before the tests run.\n  //\n  Roles._uiHelpers = {\n    /**\n     * UI helper to check if current user is in at least one\n     * of the target roles.  For use in client-side templates.\n     *\n     * @example\n     *     {{#if isInRole 'admin'}}\n     *     {{/if}}\n     *\n     *     {{#if isInRole 'editor,user'}}\n     *     {{/if}}\n     *\n     *     {{#if isInRole 'editor,user' 'scope1'}}\n     *     {{/if}}\n     *\n     * @method isInRole\n     * @param {String} role Name of role or comma-seperated list of roles.\n     * @param {String} [scope] Optional, name of scope to check.\n     * @return {Boolean} `true` if current user is in at least one of the target roles.\n     * @static\n     * @for UIHelpers\n     */\n    isInRole: function (role, scope) {\n      var user = Meteor.user();\n      var comma = (role || '').indexOf(',');\n      var roles;\n      if (!user) return false;\n      if (!Match.test(role, String)) return false;\n      if (comma !== -1) {\n        roles = role.split(',').reduce(function (memo, r) {\n          if (!r) {\n            return memo;\n          }\n          memo.push(r);\n          return memo;\n        }, []);\n      } else {\n        roles = [role];\n      }\n      if (Match.test(scope, String)) {\n        return Roles.userIsInRole(user, roles, scope);\n      }\n      return Roles.userIsInRole(user, roles);\n    }\n  };\n\n  // //////////////////////////////////////////////////////////\n  // Register UI helpers\n  //\n\n  if (Roles.debug && console.log) {\n    console.log('[roles] Roles.debug =', Roles.debug);\n  }\n  if (typeof Package.blaze !== 'undefined' && typeof Package.blaze.Blaze !== 'undefined' && typeof Package.blaze.Blaze.registerHelper === 'function') {\n    Object.entries(Roles._uiHelpers).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        func = _ref2[1];\n      if (Roles.debug && console.log) {\n        console.log('[roles] registering Blaze helper \\'' + name + '\\'');\n      }\n      Package.blaze.Blaze.registerHelper(name, func);\n    });\n  }\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"subscriptions.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/client/subscriptions.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Meteor, Roles, Tracker */\n\n/**\n * Subscription handle for the collection of all existing roles.\n *\n * @example\n *\n *     Roles.subscription.ready(); // true if roles have been loaded\n *\n * @property subscription\n * @type Object\n * @for Roles\n * @static\n */\n\nTracker.autorun(function () {\n  Roles.subscription = Meteor.subscribe('_roles');\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".d.ts\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/alanning:roles/roles/roles_common.js\");\nrequire(\"/node_modules/meteor/alanning:roles/roles/roles_common_async.js\");\nrequire(\"/node_modules/meteor/alanning:roles/roles/client/debug.js\");\nrequire(\"/node_modules/meteor/alanning:roles/roles/client/uiHelpers.js\");\nrequire(\"/node_modules/meteor/alanning:roles/roles/client/subscriptions.js\");\n\n/* Exports */\nPackage._define(\"alanning:roles\", {\n  Roles: Roles\n});\n\n})();\n","servePath":"/packages/alanning_roles.js","sourceMap":{"version":3,"sources":["packages/alanning:roles/roles/roles_common.js","packages/alanning:roles/roles/roles_common_async.js","packages/alanning:roles/roles/client/debug.js","packages/alanning:roles/roles/client/uiHelpers.js","packages/alanning:roles/roles/client/subscriptions.js"],"names":["_typeof","module1","link","default","v","_toConsumableArray","Meteor","roles","Mongo","Collection","roleAssignment","Roles","getGroupsForUserDeprecationWarning","Object","assign","GLOBAL_GROUP","createRole","roleName","options","_checkRoleName","unlessExists","result","upsert","_id","$setOnInsert","children","insertedId","Error","deleteRole","inheritedRoles","remove","_getParentRoleNames","findOne","find","$in","fetch","forEach","r","update","$pull","_getInheritedRoleNames","$set","concat","map","r2","multi","length","renameRole","oldName","newName","count","role","insert","addRolesToParent","rolesNames","parentName","Array","isArray","_addRoleToParent","includes","$ne","$push","$each","removeRolesFromParent","_removeRoleFromParent","fields","addUsersToRoles","users","id","_normalizeOptions","_checkScopeName","scope","ifExists","user","_addUserToRole","setUserRoles","anyScope","selector","userId","res","parentRoles","Set","parentRole","add","delete","nestedRoles","removeUsersFromRoles","_removeUserFromRole","userIsInRole","filter","some","limit","getRolesForUser","fullObjects","onlyAssigned","onlyScoped","push","reduce","rev","current","getAllRoles","queryOptions","sort","getUsersInRole","ids","getUserAssignmentsForRole","a","_getUsersInRoleCursor","getGroupsForUser","_Roles","console","warn","getScopesForUser","apply","arguments","scopes","obi","renameScope","removeScope","name","trim","isParentOf","parentRoleName","childRoleName","rolesToCheck","pop","undefined","_normalizeScopeName","scopeName","call","module","_regeneratorRuntime","_createForOfIteratorHelperLoose","asyncSome","_callee","arr","predicate","_iterator","_step","e","async","_callee$","_context","prev","next","done","value","awrap","sent","abrupt","stop","Promise","createRoleAsync","_callee2","existingRole","_callee2$","_context2","findOneAsync","updateAsync","insertAsync","deleteRoleAsync","_callee3","_iterator2","_step2","_callee3$","_context3","removeAsync","t0","t1","t2","fetchAsync","t3","t4","t5","t6","t7","_getInheritedRoleNamesAsync","renameRoleAsync","_callee4","_callee4$","_context4","addRolesToParentAsync","_callee5","_iterator3","_step3","_callee5$","_context5","_addRoleToParentAsync","_callee6","_callee6$","_context6","t8","t9","t10","t11","t12","removeRolesFromParentAsync","_callee7","_iterator4","_step4","_callee7$","_context7","_removeRoleFromParentAsync","_callee8","_iterator5","_step5","_callee8$","_context8","_getParentRoleNamesAsync","t13","t14","addUsersToRolesAsync","_callee9","_iterator6","_step6","_iterator7","_step7","_callee9$","_context9","_addUserToRoleAsync","setUserRolesAsync","_callee10","_iterator8","_step8","_iterator9","_step9","_callee10$","_context10","_callee11","existingAssignment","_callee11$","_context11","_callee12","_iterator10","_step10","_iterator11","_step11","_callee12$","_context12","_callee13","_iterator12","_step12","_iterator13","_step13","_callee13$","_context13","removeUsersFromRolesAsync","_callee14","_iterator14","_step14","_iterator15","_step15","_callee14$","_context14","_removeUserFromRoleAsync","_callee15","_callee15$","_context15","userIsInRoleAsync","_callee17","_callee17$","_context17","_callee16","out","_callee16$","_context16","countAsync","getRolesForUserAsync","_callee18","_callee18$","_context18","getUsersInRoleAsync","_callee19","_callee19$","_context19","getGroupsForUserAsync","_callee20","_args20","_callee20$","_context20","getScopesForUserAsync","_callee21","_callee21$","_context21","renameScopeAsync","_callee22","_callee22$","_context22","removeScopeAsync","_callee23","_callee23$","_context23","isParentOfAsync","_callee24","_callee24$","_context24","debug","localStorage","temp","getItem","ex","_slicedToArray","_uiHelpers","isInRole","comma","indexOf","Match","test","String","split","memo","log","Package","blaze","Blaze","registerHelper","entries","_ref","_ref2","func","Tracker","autorun","subscription","subscribe"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,IAAIA,OAAO;EAACC,OAAO,CAACC,IAAI,CAAC,+BAA+B,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACJ,OAAO,GAACI,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAC,IAAIC,kBAAkB;EAACJ,OAAO,CAACC,IAAI,CAAC,0CAA0C,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACC,kBAAkB,GAACD,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAA1N;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAI,CAACE,MAAM,CAACC,KAAK,EAAE;IACjBD,MAAM,CAACC,KAAK,GAAG,IAAIC,KAAK,CAACC,UAAU,CAAC,OAAO,CAAC;EAC9C;EAEA,IAAI,CAACH,MAAM,CAACI,cAAc,EAAE;IAC1BJ,MAAM,CAACI,cAAc,GAAG,IAAIF,KAAK,CAACC,UAAU,CAAC,iBAAiB,CAAC;EACjE;;EAEA;AACA;AACA;EACA,IAAI,OAAOE,KAAK,KAAK,WAAW,EAAE;IAChCA,KAAK,GAAG,CAAC,CAAC,EAAC;EACb;EAEA,IAAIC,kCAAkC,GAAG,KAAK;EAE9CC,MAAM,CAACC,MAAM,CAACH,KAAK,EAAE;IAEnB;AACF;AACA;AACA;AACA;AACA;AACA;IACEI,YAAY,EAAE,IAAI;IAElB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,UAAU,EAAE,SAAAA,CAAUC,QAAQ,EAAEC,OAAO,EAAE;MACvCP,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAE9BC,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtBM,YAAY,EAAE;MAChB,CAAC,EAAEF,OAAO,CAAC;MAEX,IAAMG,MAAM,GAAGf,MAAM,CAACC,KAAK,CAACe,MAAM,CAAC;QAAEC,GAAG,EAAEN;MAAS,CAAC,EAAE;QAAEO,YAAY,EAAE;UAAEC,QAAQ,EAAE;QAAG;MAAE,CAAC,CAAC;MAEzF,IAAI,CAACJ,MAAM,CAACK,UAAU,EAAE;QACtB,IAAIR,OAAO,CAACE,YAAY,EAAE,OAAO,IAAI;QACrC,MAAM,IAAIO,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;MAC9D;MAEA,OAAOI,MAAM,CAACK,UAAU;IAC1B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,UAAU,EAAE,SAAAA,CAAUX,QAAQ,EAAE;MAC9B,IAAIV,KAAK;MACT,IAAIsB,cAAc;MAElBlB,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;;MAE9B;MACAX,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC;QAC3B,UAAU,EAAEb;MACd,CAAC,CAAC;MAEF,GAAG;QACD;QACAV,KAAK,GAAGI,KAAK,CAACoB,mBAAmB,CAACzB,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;UAAET,GAAG,EAAEN;QAAS,CAAC,CAAC,CAAC;QAE1EX,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;UAAEV,GAAG,EAAE;YAAEW,GAAG,EAAE3B;UAAM;QAAE,CAAC,CAAC,CAAC4B,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,UAAAC,CAAC,EAAI;UAC9D/B,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;YAClBf,GAAG,EAAEc,CAAC,CAACd;UACT,CAAC,EAAE;YACDgB,KAAK,EAAE;cACLd,QAAQ,EAAE;gBACRF,GAAG,EAAEN;cACP;YACF;UACF,CAAC,CAAC;UAEFY,cAAc,GAAGlB,KAAK,CAAC6B,sBAAsB,CAAClC,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;YAAET,GAAG,EAAEc,CAAC,CAACd;UAAI,CAAC,CAAC,CAAC;UACnFjB,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;YAC3B,UAAU,EAAED,CAAC,CAACd;UAChB,CAAC,EAAE;YACDkB,IAAI,EAAE;cACJZ,cAAc,EAAE,CAACQ,CAAC,CAACd,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKwB,cAAc,GAAEc,GAAG,CAAC,UAAAC,EAAE;gBAAA,OAAK;kBAAErB,GAAG,EAAEqB;gBAAG,CAAC;cAAA,CAAC;YACpE;UACF,CAAC,EAAE;YAAEC,KAAK,EAAE;UAAK,CAAC,CAAC;QACrB,CAAC,CAAC;MACJ,CAAC,QAAQtC,KAAK,CAACuC,MAAM,GAAG,CAAC;;MAEzB;MACAxC,MAAM,CAACC,KAAK,CAACuB,MAAM,CAAC;QAAEP,GAAG,EAAEN;MAAS,CAAC,CAAC;IACxC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE8B,UAAU,EAAE,SAAAA,CAAUC,OAAO,EAAEC,OAAO,EAAE;MACtC,IAAIC,KAAK;MAETvC,KAAK,CAACQ,cAAc,CAAC6B,OAAO,CAAC;MAC7BrC,KAAK,CAACQ,cAAc,CAAC8B,OAAO,CAAC;MAE7B,IAAID,OAAO,KAAKC,OAAO,EAAE;MAEzB,IAAME,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEyB;MAAQ,CAAC,CAAC;MAEnD,IAAI,CAACG,IAAI,EAAE;QACT,MAAM,IAAIxB,KAAK,CAAC,SAAS,GAAGqB,OAAO,GAAG,oBAAoB,CAAC;MAC7D;MAEAG,IAAI,CAAC5B,GAAG,GAAG0B,OAAO;MAElB3C,MAAM,CAACC,KAAK,CAAC6C,MAAM,CAACD,IAAI,CAAC;MAEzB,GAAG;QACDD,KAAK,GAAG5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UACnC,UAAU,EAAEU;QACd,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ,UAAU,EAAEQ;UACd;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB,GAAG;QACDA,KAAK,GAAG5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UACnC,oBAAoB,EAAEU;QACxB,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ,sBAAsB,EAAEQ;UAC1B;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB,GAAG;QACDA,KAAK,GAAG5C,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;UAC1B,cAAc,EAAEU;QAClB,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ,gBAAgB,EAAEQ;UACpB;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB5C,MAAM,CAACC,KAAK,CAACuB,MAAM,CAAC;QAAEP,GAAG,EAAEyB;MAAQ,CAAC,CAAC;IACvC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEK,gBAAgB,EAAE,SAAAA,CAAUC,UAAU,EAAEC,UAAU,EAAE;MAClD;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;MAEzDA,UAAU,CAAClB,OAAO,CAAC,UAAUnB,QAAQ,EAAE;QACrCN,KAAK,CAAC+C,gBAAgB,CAACzC,QAAQ,EAAEsC,UAAU,CAAC;MAC9C,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;IACEG,gBAAgB,EAAE,SAAAA,CAAUzC,QAAQ,EAAEsC,UAAU,EAAE;MAChD5C,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAACQ,cAAc,CAACoC,UAAU,CAAC;;MAEhC;MACA,IAAMJ,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEN;MAAS,CAAC,CAAC;MAEpD,IAAI,CAACkC,IAAI,EAAE;QACT,MAAM,IAAIxB,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;MAC9D;;MAEA;MACA,IAAIN,KAAK,CAAC6B,sBAAsB,CAACW,IAAI,CAAC,CAACQ,QAAQ,CAACJ,UAAU,CAAC,EAAE;QAC3D,MAAM,IAAI5B,KAAK,CAAC,UAAU,GAAGV,QAAQ,GAAG,WAAW,GAAGsC,UAAU,GAAG,wBAAwB,CAAC;MAC9F;MAEA,IAAML,KAAK,GAAG5C,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;QAChCf,GAAG,EAAEgC,UAAU;QACf,cAAc,EAAE;UACdK,GAAG,EAAET,IAAI,CAAC5B;QACZ;MACF,CAAC,EAAE;QACDsC,KAAK,EAAE;UACLpC,QAAQ,EAAE;YACRF,GAAG,EAAE4B,IAAI,CAAC5B;UACZ;QACF;MACF,CAAC,CAAC;;MAEF;MACA;MACA,IAAI,CAAC2B,KAAK,EAAE;MAEZ5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;QAC3B,oBAAoB,EAAEiB;MACxB,CAAC,EAAE;QACDM,KAAK,EAAE;UACLhC,cAAc,EAAE;YAAEiC,KAAK,EAAE,CAACX,IAAI,CAAC5B,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKM,KAAK,CAAC6B,sBAAsB,CAACW,IAAI,CAAC,GAAER,GAAG,CAAC,UAAAN,CAAC;cAAA,OAAK;gBAAEd,GAAG,EAAEc;cAAE,CAAC;YAAA,CAAC;UAAE;QACpG;MACF,CAAC,EAAE;QAAEQ,KAAK,EAAE;MAAK,CAAC,CAAC;IACrB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEkB,qBAAqB,EAAE,SAAAA,CAAUT,UAAU,EAAEC,UAAU,EAAE;MACvD;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;MAEzDA,UAAU,CAAClB,OAAO,CAAC,UAAUnB,QAAQ,EAAE;QACrCN,KAAK,CAACqD,qBAAqB,CAAC/C,QAAQ,EAAEsC,UAAU,CAAC;MACnD,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;IACES,qBAAqB,EAAE,SAAAA,CAAU/C,QAAQ,EAAEsC,UAAU,EAAE;MACrD5C,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAACQ,cAAc,CAACoC,UAAU,CAAC;;MAEhC;MACA;MACA,IAAMJ,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEN;MAAS,CAAC,EAAE;QAAEgD,MAAM,EAAE;UAAE1C,GAAG,EAAE;QAAE;MAAE,CAAC,CAAC;MAE5E,IAAI,CAAC4B,IAAI,EAAE;QACT,MAAM,IAAIxB,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;MAC9D;MAEA,IAAMiC,KAAK,GAAG5C,MAAM,CAACC,KAAK,CAAC+B,MAAM,CAAC;QAChCf,GAAG,EAAEgC;MACP,CAAC,EAAE;QACDhB,KAAK,EAAE;UACLd,QAAQ,EAAE;YACRF,GAAG,EAAE4B,IAAI,CAAC5B;UACZ;QACF;MACF,CAAC,CAAC;;MAEF;MACA;MACA,IAAI,CAAC2B,KAAK,EAAE;;MAEZ;MACA,IAAM3C,KAAK,MAAAmC,MAAA,CAAArC,kBAAA,CAAOM,KAAK,CAACoB,mBAAmB,CAACzB,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEgC;MAAW,CAAC,CAAC,CAAC,IAAEA,UAAU,EAAC;MAEnGjD,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;QAAEV,GAAG,EAAE;UAAEW,GAAG,EAAE3B;QAAM;MAAE,CAAC,CAAC,CAAC4B,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,UAAAC,CAAC,EAAI;QAC9D,IAAMR,cAAc,GAAGlB,KAAK,CAAC6B,sBAAsB,CAAClC,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;UAAET,GAAG,EAAEc,CAAC,CAACd;QAAI,CAAC,CAAC,CAAC;QACzFjB,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UAC3B,UAAU,EAAED,CAAC,CAACd,GAAG;UACjB,oBAAoB,EAAE4B,IAAI,CAAC5B;QAC7B,CAAC,EAAE;UACDkB,IAAI,EAAE;YACJZ,cAAc,EAAE,CAACQ,CAAC,CAACd,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKwB,cAAc,GAAEc,GAAG,CAAC,UAAAC,EAAE;cAAA,OAAK;gBAAErB,GAAG,EAAEqB;cAAG,CAAC;YAAA,CAAC;UACpE;QACF,CAAC,EAAE;UAAEC,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEqB,eAAe,EAAE,SAAAA,CAAUC,KAAK,EAAE5D,KAAK,EAAEW,OAAO,EAAE;MAChD,IAAIkD,EAAE;MAEN,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIxC,KAAK,CAAC,0BAA0B,CAAC;MACvD,IAAI,CAACpB,KAAK,EAAE,MAAM,IAAIoB,KAAK,CAAC,0BAA0B,CAAC;MAEvDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB0D,QAAQ,EAAE;MACZ,CAAC,EAAEtD,OAAO,CAAC;MAEXiD,KAAK,CAAC/B,OAAO,CAAC,UAAUqC,IAAI,EAAE;QAC5B,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;UAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;QACf,CAAC,MAAM;UACL6C,EAAE,GAAGK,IAAI;QACX;QAEAlE,KAAK,CAAC6B,OAAO,CAAC,UAAUe,IAAI,EAAE;UAC5BxC,KAAK,CAAC+D,cAAc,CAACN,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;QACzC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEyD,YAAY,EAAE,SAAAA,CAAUR,KAAK,EAAE5D,KAAK,EAAEW,OAAO,EAAE;MAC7C,IAAIkD,EAAE;MAEN,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIxC,KAAK,CAAC,0BAA0B,CAAC;MACvD,IAAI,CAACpB,KAAK,EAAE,MAAM,IAAIoB,KAAK,CAAC,0BAA0B,CAAC;MAEvDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB0D,QAAQ,EAAE,KAAK;QACfI,QAAQ,EAAE;MACZ,CAAC,EAAE1D,OAAO,CAAC;MAEXiD,KAAK,CAAC/B,OAAO,CAAC,UAAUqC,IAAI,EAAE;QAC5B,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;UAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;QACf,CAAC,MAAM;UACL6C,EAAE,GAAGK,IAAI;QACX;QACA;QACA,IAAMI,QAAQ,GAAG;UAAE,UAAU,EAAET;QAAG,CAAC;QACnC,IAAI,CAAClD,OAAO,CAAC0D,QAAQ,EAAE;UACrBC,QAAQ,CAACN,KAAK,GAAGrD,OAAO,CAACqD,KAAK;QAChC;QAEAjE,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC+C,QAAQ,CAAC;;QAEtC;QACAtE,KAAK,CAAC6B,OAAO,CAAC,UAAUe,IAAI,EAAE;UAC5BxC,KAAK,CAAC+D,cAAc,CAACN,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;QACzC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEwD,cAAc,EAAE,SAAAA,CAAUI,MAAM,EAAE7D,QAAQ,EAAEC,OAAO,EAAE;MACnDP,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpC,IAAI,CAACO,MAAM,EAAE;QACX;MACF;MAEA,IAAM3B,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;QAAET,GAAG,EAAEN;MAAS,CAAC,EAAE;QAAEgD,MAAM,EAAE;UAAExC,QAAQ,EAAE;QAAE;MAAE,CAAC,CAAC;MAEjF,IAAI,CAAC0B,IAAI,EAAE;QACT,IAAIjC,OAAO,CAACsD,QAAQ,EAAE;UACpB,OAAO,EAAE;QACX,CAAC,MAAM;UACL,MAAM,IAAI7C,KAAK,CAAC,SAAS,GAAGV,QAAQ,GAAG,oBAAoB,CAAC;QAC9D;MACF;;MAEA;MACA,IAAM8D,GAAG,GAAGzE,MAAM,CAACI,cAAc,CAACY,MAAM,CAAC;QACvC,UAAU,EAAEwD,MAAM;QAClB,UAAU,EAAE7D,QAAQ;QACpBsD,KAAK,EAAErD,OAAO,CAACqD;MACjB,CAAC,EAAE;QACD/C,YAAY,EAAE;UACZiD,IAAI,EAAE;YAAElD,GAAG,EAAEuD;UAAO,CAAC;UACrB3B,IAAI,EAAE;YAAE5B,GAAG,EAAEN;UAAS,CAAC;UACvBsD,KAAK,EAAErD,OAAO,CAACqD;QACjB;MACF,CAAC,CAAC;MAEF,IAAIQ,GAAG,CAACrD,UAAU,EAAE;QAClBpB,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UAAEf,GAAG,EAAEwD,GAAG,CAACrD;QAAW,CAAC,EAAE;UACpDe,IAAI,EAAE;YACJZ,cAAc,EAAE,CAACZ,QAAQ,EAAAyB,MAAA,CAAArC,kBAAA,CAAKM,KAAK,CAAC6B,sBAAsB,CAACW,IAAI,CAAC,GAAER,GAAG,CAAC,UAAAN,CAAC;cAAA,OAAK;gBAAEd,GAAG,EAAEc;cAAE,CAAC;YAAA,CAAC;UACzF;QACF,CAAC,CAAC;MACJ;MAEA,OAAO0C,GAAG;IACZ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEhD,mBAAmB,EAAE,SAAAA,CAAUoB,IAAI,EAAE;MACnC,IAAI,CAACA,IAAI,EAAE;QACT,OAAO,EAAE;MACX;MAEA,IAAM6B,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC9B,IAAI,CAAC5B,GAAG,CAAC,CAAC;MAEvCyD,WAAW,CAAC5C,OAAO,CAAC,UAAAnB,QAAQ,EAAI;QAC9BX,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;UAAE,cAAc,EAAEhB;QAAS,CAAC,CAAC,CAACkB,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,UAAA8C,UAAU,EAAI;UAC5EF,WAAW,CAACG,GAAG,CAACD,UAAU,CAAC3D,GAAG,CAAC;QACjC,CAAC,CAAC;MACJ,CAAC,CAAC;MAEFyD,WAAW,CAACI,MAAM,CAACjC,IAAI,CAAC5B,GAAG,CAAC;MAE5B,OAAAlB,kBAAA,CAAW2E,WAAW;IACxB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACExC,sBAAsB,EAAE,SAAAA,CAAUW,IAAI,EAAE;MACtC,IAAMtB,cAAc,GAAG,IAAIoD,GAAG,CAAC,CAAC;MAChC,IAAMI,WAAW,GAAG,IAAIJ,GAAG,CAAC,CAAC9B,IAAI,CAAC,CAAC;MAEnCkC,WAAW,CAACjD,OAAO,CAAC,UAAAC,CAAC,EAAI;QACvB,IAAM9B,KAAK,GAAGD,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC;UAAEV,GAAG,EAAE;YAAEW,GAAG,EAAEG,CAAC,CAACZ,QAAQ,CAACkB,GAAG,CAAC,UAAAN,CAAC;cAAA,OAAIA,CAAC,CAACd,GAAG;YAAA;UAAE;QAAE,CAAC,EAAE;UAAE0C,MAAM,EAAE;YAAExC,QAAQ,EAAE;UAAE;QAAE,CAAC,CAAC,CAACU,KAAK,CAAC,CAAC;QAElH5B,KAAK,CAAC6B,OAAO,CAAC,UAAAQ,EAAE,EAAI;UAClBf,cAAc,CAACsD,GAAG,CAACvC,EAAE,CAACrB,GAAG,CAAC;UAC1B8D,WAAW,CAACF,GAAG,CAACvC,EAAE,CAAC;QACrB,CAAC,CAAC;MACJ,CAAC,CAAC;MAEF,OAAAvC,kBAAA,CAAWwB,cAAc;IAC3B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEyD,oBAAoB,EAAE,SAAAA,CAAUnB,KAAK,EAAE5D,KAAK,EAAEW,OAAO,EAAE;MACrD,IAAI,CAACiD,KAAK,EAAE,MAAM,IAAIxC,KAAK,CAAC,0BAA0B,CAAC;MACvD,IAAI,CAACpB,KAAK,EAAE,MAAM,IAAIoB,KAAK,CAAC,0BAA0B,CAAC;MAEvDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCJ,KAAK,CAAC/B,OAAO,CAAC,UAAUqC,IAAI,EAAE;QAC5B,IAAI,CAACA,IAAI,EAAE;QAEXlE,KAAK,CAAC6B,OAAO,CAAC,UAAUe,IAAI,EAAE;UAC5B,IAAIiB,EAAE;UACN,IAAIpE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;YAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;UACf,CAAC,MAAM;YACL6C,EAAE,GAAGK,IAAI;UACX;UAEA9D,KAAK,CAAC4E,mBAAmB,CAACnB,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;QAC9C,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEqE,mBAAmB,EAAE,SAAAA,CAAUT,MAAM,EAAE7D,QAAQ,EAAEC,OAAO,EAAE;MACxDP,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;MAC9BN,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpC,IAAI,CAACO,MAAM,EAAE;MAEb,IAAMD,QAAQ,GAAG;QACf,UAAU,EAAEC,MAAM;QAClB,UAAU,EAAE7D;MACd,CAAC;MAED,IAAI,CAACC,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAGrD,OAAO,CAACqD,KAAK;MAChC;MAEAjE,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC+C,QAAQ,CAAC;IACxC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEW,YAAY,EAAE,SAAAA,CAAUf,IAAI,EAAElE,KAAK,EAAEW,OAAO,EAAE;MAC5C,IAAIkD,EAAE;MACNlD,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CA,KAAK,GAAGA,KAAK,CAACkF,MAAM,CAAC,UAAApD,CAAC;QAAA,OAAIA,CAAC,IAAI,IAAI;MAAA,EAAC;MAEpC,IAAI,CAAC9B,KAAK,CAACuC,MAAM,EAAE,OAAO,KAAK;MAE/BnC,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB8D,QAAQ,EAAE;MACZ,CAAC,EAAE1D,OAAO,CAAC;MAEX,IAAIuD,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;MACf,CAAC,MAAM;QACL6C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,KAAK;MACrB,IAAI,OAAOA,EAAE,KAAK,QAAQ,EAAE,OAAO,KAAK;MAExC,IAAMS,QAAQ,GAAG;QAAE,UAAU,EAAET;MAAG,CAAC;MAEnC,IAAI,CAAClD,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK,EAAE,IAAI;QAAE,CAAC;MACjD;MAEA,OAAOhE,KAAK,CAACmF,IAAI,CAAC,UAACzE,QAAQ,EAAK;QAC9B4D,QAAQ,CAAC,oBAAoB,CAAC,GAAG5D,QAAQ;QAEzC,OAAOX,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAE;UAAEc,KAAK,EAAE;QAAE,CAAC,CAAC,CAACzC,KAAK,CAAC,CAAC,GAAG,CAAC;MACvE,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE0C,eAAe,EAAE,SAAAA,CAAUnB,IAAI,EAAEvD,OAAO,EAAE;MACxC,IAAIkD,EAAE;MAENlD,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CP,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB+E,WAAW,EAAE,KAAK;QAClBC,YAAY,EAAE,KAAK;QACnBlB,QAAQ,EAAE,KAAK;QACfmB,UAAU,EAAE;MACd,CAAC,EAAE7E,OAAO,CAAC;MAEX,IAAIuD,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;MACf,CAAC,MAAM;QACL6C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,EAAE;MAElB,IAAMS,QAAQ,GAAG;QAAE,UAAU,EAAET;MAAG,CAAC;MACnC,IAAMqB,MAAM,GAAG;QAAExB,MAAM,EAAE;UAAE,oBAAoB,EAAE;QAAE;MAAE,CAAC;MAEtD,IAAI,CAAC/C,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK;QAAE,CAAC;QAEzC,IAAI,CAACrD,OAAO,CAAC6E,UAAU,EAAE;UACvBlB,QAAQ,CAACN,KAAK,CAACrC,GAAG,CAAC8D,IAAI,CAAC,IAAI,CAAC;QAC/B;MACF;MAEA,IAAI9E,OAAO,CAAC4E,YAAY,EAAE;QACxB,OAAOL,MAAM,CAACxB,MAAM,CAAC,oBAAoB,CAAC;QAC1CwB,MAAM,CAACxB,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;MAC/B;MAEA,IAAI/C,OAAO,CAAC2E,WAAW,EAAE;QACvB,OAAOJ,MAAM,CAACxB,MAAM;MACtB;MAEA,IAAM1D,KAAK,GAAGD,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAEY,MAAM,CAAC,CAACtD,KAAK,CAAC,CAAC;MAElE,IAAIjB,OAAO,CAAC2E,WAAW,EAAE;QACvB,OAAOtF,KAAK;MACd;MAEA,OAAAF,kBAAA,CAAW,IAAI4E,GAAG,CAAC1E,KAAK,CAAC0F,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO,EAAK;QAChD,IAAIA,OAAO,CAACtE,cAAc,EAAE;UAC1B,OAAOqE,GAAG,CAACxD,MAAM,CAACyD,OAAO,CAACtE,cAAc,CAACc,GAAG,CAAC,UAAAN,CAAC;YAAA,OAAIA,CAAC,CAACd,GAAG;UAAA,EAAC,CAAC;QAC3D,CAAC,MAAM,IAAI4E,OAAO,CAAChD,IAAI,EAAE;UACvB+C,GAAG,CAACF,IAAI,CAACG,OAAO,CAAChD,IAAI,CAAC5B,GAAG,CAAC;QAC5B;QACA,OAAO2E,GAAG;MACZ,CAAC,EAAE,EAAE,CAAC,CAAC;IACT,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,WAAW,EAAE,SAAAA,CAAUC,YAAY,EAAE;MACnCA,YAAY,GAAGA,YAAY,IAAI;QAAEC,IAAI,EAAE;UAAE/E,GAAG,EAAE;QAAE;MAAE,CAAC;MAEnD,OAAOjB,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC,CAAC,CAAC,EAAEoE,YAAY,CAAC;IAC5C,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,cAAc,EAAE,SAAAA,CAAUhG,KAAK,EAAEW,OAAO,EAAEmF,YAAY,EAAE;MACtD,IAAMG,GAAG,GAAG7F,KAAK,CAAC8F,yBAAyB,CAAClG,KAAK,EAAEW,OAAO,CAAC,CAACiB,KAAK,CAAC,CAAC,CAACQ,GAAG,CAAC,UAAA+D,CAAC;QAAA,OAAIA,CAAC,CAACjC,IAAI,CAAClD,GAAG;MAAA,EAAC;MAExF,OAAOjB,MAAM,CAAC6D,KAAK,CAAClC,IAAI,CAAC;QAAEV,GAAG,EAAE;UAAEW,GAAG,EAAEsE;QAAI;MAAE,CAAC,EAAItF,OAAO,IAAIA,OAAO,CAACmF,YAAY,IAAKA,YAAY,IAAK,CAAC,CAAC,CAAC;IAC5G,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEI,yBAAyB,EAAE,SAAAA,CAAUlG,KAAK,EAAEW,OAAO,EAAE;MACnDA,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB8D,QAAQ,EAAE,KAAK;QACfyB,YAAY,EAAE,CAAC;MACjB,CAAC,EAAEnF,OAAO,CAAC;MAEX,OAAOP,KAAK,CAACgG,qBAAqB,CAACpG,KAAK,EAAEW,OAAO,EAAEA,OAAO,CAACmF,YAAY,CAAC;IAC1E,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEM,qBAAqB,EAAE,SAAAA,CAAUpG,KAAK,EAAEW,OAAO,EAAEuE,MAAM,EAAE;MACvDvE,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtB8D,QAAQ,EAAE,KAAK;QACfmB,UAAU,EAAE;MACd,CAAC,EAAE7E,OAAO,CAAC;;MAEX;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCkB,MAAM,GAAG5E,MAAM,CAACC,MAAM,CAAC;QACrBmD,MAAM,EAAE;UAAE,UAAU,EAAE;QAAE;MAC1B,CAAC,EAAEwB,MAAM,CAAC;MAEV,IAAMZ,QAAQ,GAAG;QAAE,oBAAoB,EAAE;UAAE3C,GAAG,EAAE3B;QAAM;MAAE,CAAC;MAEzD,IAAI,CAACW,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK;QAAE,CAAC;QAEzC,IAAI,CAACrD,OAAO,CAAC6E,UAAU,EAAE;UACvBlB,QAAQ,CAACN,KAAK,CAACrC,GAAG,CAAC8D,IAAI,CAAC,IAAI,CAAC;QAC/B;MACF;MAEA,OAAO1F,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAEY,MAAM,CAAC;IACrD,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;IACEmB,gBAAgB,EAAE,SAAAA,CAAA,EAAmB;MAAA,IAAAC,MAAA;MACnC,IAAI,CAACjG,kCAAkC,EAAE;QACvCA,kCAAkC,GAAG,IAAI;QACzCkG,OAAO,IAAIA,OAAO,CAACC,IAAI,CAAC,qEAAqE,CAAC;MAChG;MAEA,OAAO,CAAAF,MAAA,GAAAlG,KAAK,EAACqG,gBAAgB,CAAAC,KAAA,CAAAJ,MAAA,EAAAK,SAAQ,CAAC;IACxC,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEF,gBAAgB,EAAE,SAAAA,CAAUvC,IAAI,EAAElE,KAAK,EAAE;MACvC,IAAI6D,EAAE;MAEN,IAAI7D,KAAK,IAAI,CAACiD,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAEnD,IAAIkE,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;MACf,CAAC,MAAM;QACL6C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,EAAE;MAElB,IAAMS,QAAQ,GAAG;QACf,UAAU,EAAET,EAAE;QACdG,KAAK,EAAE;UAAEX,GAAG,EAAE;QAAK;MACrB,CAAC;MAED,IAAIrD,KAAK,EAAE;QACTsE,QAAQ,CAAC,oBAAoB,CAAC,GAAG;UAAE3C,GAAG,EAAE3B;QAAM,CAAC;MACjD;MAEA,IAAM4G,MAAM,GAAG7G,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAE;QAAEZ,MAAM,EAAE;UAAEM,KAAK,EAAE;QAAE;MAAE,CAAC,CAAC,CAACpC,KAAK,CAAC,CAAC,CAACQ,GAAG,CAAC,UAAAyE,GAAG;QAAA,OAAIA,GAAG,CAAC7C,KAAK;MAAA,EAAC;MAE3G,OAAAlE,kBAAA,CAAW,IAAI4E,GAAG,CAACkC,MAAM,CAAC;IAC5B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,WAAW,EAAE,SAAAA,CAAUrE,OAAO,EAAEC,OAAO,EAAE;MACvC,IAAIC,KAAK;MAETvC,KAAK,CAAC2D,eAAe,CAACtB,OAAO,CAAC;MAC9BrC,KAAK,CAAC2D,eAAe,CAACrB,OAAO,CAAC;MAE9B,IAAID,OAAO,KAAKC,OAAO,EAAE;MAEzB,GAAG;QACDC,KAAK,GAAG5C,MAAM,CAACI,cAAc,CAAC4B,MAAM,CAAC;UACnCiC,KAAK,EAAEvB;QACT,CAAC,EAAE;UACDP,IAAI,EAAE;YACJ8B,KAAK,EAAEtB;UACT;QACF,CAAC,EAAE;UAAEJ,KAAK,EAAE;QAAK,CAAC,CAAC;MACrB,CAAC,QAAQK,KAAK,GAAG,CAAC;IACpB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEoE,WAAW,EAAE,SAAAA,CAAUC,IAAI,EAAE;MAC3B5G,KAAK,CAAC2D,eAAe,CAACiD,IAAI,CAAC;MAE3BjH,MAAM,CAACI,cAAc,CAACoB,MAAM,CAAC;QAAEyC,KAAK,EAAEgD;MAAK,CAAC,CAAC;IAC/C,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACEpG,cAAc,EAAE,SAAAA,CAAUF,QAAQ,EAAE;MAClC,IAAI,CAACA,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,CAACuG,IAAI,CAAC,CAAC,KAAKvG,QAAQ,EAAE;QAC7E,MAAM,IAAIU,KAAK,CAAC,sBAAsB,GAAGV,QAAQ,GAAG,KAAK,CAAC;MAC5D;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEwG,UAAU,EAAE,SAAAA,CAAUC,cAAc,EAAEC,aAAa,EAAE;MACnD,IAAID,cAAc,KAAKC,aAAa,EAAE;QACpC,OAAO,IAAI;MACb;MAEA,IAAID,cAAc,IAAI,IAAI,IAAIC,aAAa,IAAI,IAAI,EAAE;QACnD,OAAO,KAAK;MACd;MAEAhH,KAAK,CAACQ,cAAc,CAACuG,cAAc,CAAC;MACpC/G,KAAK,CAACQ,cAAc,CAACwG,aAAa,CAAC;MAEnC,IAAIC,YAAY,GAAG,CAACF,cAAc,CAAC;MACnC,OAAOE,YAAY,CAAC9E,MAAM,KAAK,CAAC,EAAE;QAChC,IAAM7B,QAAQ,GAAG2G,YAAY,CAACC,GAAG,CAAC,CAAC;QAEnC,IAAI5G,QAAQ,KAAK0G,aAAa,EAAE;UAC9B,OAAO,IAAI;QACb;QAEA,IAAMxE,IAAI,GAAG7C,MAAM,CAACC,KAAK,CAACyB,OAAO,CAAC;UAAET,GAAG,EAAEN;QAAS,CAAC,CAAC;;QAEpD;QACA,IAAI,CAACkC,IAAI,EAAE;QAEXyE,YAAY,GAAGA,YAAY,CAAClF,MAAM,CAACS,IAAI,CAAC1B,QAAQ,CAACkB,GAAG,CAAC,UAAAN,CAAC;UAAA,OAAIA,CAAC,CAACd,GAAG;QAAA,EAAC,CAAC;MACnE;MAEA,OAAO,KAAK;IACd,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE8C,iBAAiB,EAAE,SAAAA,CAAUnD,OAAO,EAAE;MACpCA,OAAO,GAAGA,OAAO,KAAK4G,SAAS,GAAG,CAAC,CAAC,GAAG5G,OAAO;MAE9C,IAAIA,OAAO,KAAK,IAAI,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QACnDA,OAAO,GAAG;UAAEqD,KAAK,EAAErD;QAAQ,CAAC;MAC9B;MAEAA,OAAO,CAACqD,KAAK,GAAG5D,KAAK,CAACoH,mBAAmB,CAAC7G,OAAO,CAACqD,KAAK,CAAC;MAExD,OAAOrD,OAAO;IAChB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE6G,mBAAmB,EAAE,SAAAA,CAAUC,SAAS,EAAE;MACxC;MACA,IAAIA,SAAS,IAAI,IAAI,EAAE;QACrB,OAAO,IAAI;MACb,CAAC,MAAM;QACL,OAAOA,SAAS;MAClB;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE1D,eAAe,EAAE,SAAAA,CAAU0D,SAAS,EAAE;MACpC,IAAIA,SAAS,KAAK,IAAI,EAAE;MAExB,IAAI,CAACA,SAAS,IAAI,OAAOA,SAAS,KAAK,QAAQ,IAAIA,SAAS,CAACR,IAAI,CAAC,CAAC,KAAKQ,SAAS,EAAE;QACjF,MAAM,IAAIrG,KAAK,CAAC,uBAAuB,GAAGqG,SAAS,GAAG,KAAK,CAAC;MAC9D;IACF;EACF,CAAC,CAAC;AAAA,EAAAC,IAAA,OAAAC,MAAA,E;;;;;;;;;;;;EC/kCF,IAAIC,mBAAmB;EAAClI,OAAO,CAACC,IAAI,CAAC,4BAA4B,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAAC+H,mBAAmB,GAAC/H,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAC,IAAIJ,OAAO;EAACC,OAAO,CAACC,IAAI,CAAC,+BAA+B,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACJ,OAAO,GAACI,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAC,IAAIC,kBAAkB;EAACJ,OAAO,CAACC,IAAI,CAAC,0CAA0C,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACC,kBAAkB,GAACD,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAC,IAAIgI,+BAA+B;EAACnI,OAAO,CAACC,IAAI,CAAC,uDAAuD,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACgI,+BAA+B,GAAChI,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAjf,IAAIE,MAAM;EAACL,OAAO,CAACC,IAAI,CAAC,eAAe,EAAC;IAACI,MAAM,EAAC,SAAAA,CAASF,CAAC,EAAC;MAACE,MAAM,GAACF,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAC,IAAII,KAAK;EAACP,OAAO,CAACC,IAAI,CAAC,cAAc,EAAC;IAACM,KAAK,EAAC,SAAAA,CAASJ,CAAC,EAAC;MAACI,KAAK,GAACJ,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAI/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAI,CAACE,MAAM,CAACC,KAAK,EAAE;IACjBD,MAAM,CAACC,KAAK,GAAG,IAAIC,KAAK,CAACC,UAAU,CAAC,OAAO,CAAC;EAC9C;EAEA,IAAI,CAACH,MAAM,CAACI,cAAc,EAAE;IAC1BJ,MAAM,CAACI,cAAc,GAAG,IAAIF,KAAK,CAACC,UAAU,CAAC,iBAAiB,CAAC;EACjE;;EAEA;AACA;AACA;EACA,IAAI,OAAOE,KAAK,KAAK,WAAW,EAAE;IAChCA,KAAK,GAAG,CAAC,CAAC,EAAC;EACb;EAEA,IAAIC,kCAAkC,GAAG,KAAK;;EAE9C;AACA;AACA;AACA;AACA;AACA;EACA,IAAMyH,SAAS;IAAG,SAAAC,QAAOC,GAAG,EAAEC,SAAS;MAAA,IAAAC,SAAA,EAAAC,KAAA,EAAAC,CAAA;MAAA,OAAAR,mBAAA,CAAAS,KAAA;QAAA,SAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAAP,SAAA,GAAAL,+BAAA,CACrBG,GAAG;YAAA;cAAA,KAAAG,KAAA,GAAAD,SAAA,IAAAQ,IAAA;gBAAAH,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAARL,CAAC,GAAAD,KAAA,CAAAQ,KAAA;cAAAJ,QAAA,CAAAE,IAAA;cAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACAX,SAAS,CAACG,CAAC,CAAC;YAAA;cAAA,KAAAG,QAAA,CAAAM,IAAA;gBAAAN,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAAA,OAAAF,QAAA,CAAAO,MAAA,WAAS,IAAI;YAAA;cAAAP,QAAA,CAAAE,IAAA;cAAA;YAAA;cAAA,OAAAF,QAAA,CAAAO,MAAA,WAE9B,KAAK;YAAA;YAAA;cAAA,OAAAP,QAAA,CAAAQ,IAAA;UAAA;QAAA;QAAA,OAAAT,QAAA;MAAA,uBAAAU,OAAA;IAAA;IACb,OAAAjB,OAAA;EAAA;EAEDzH,MAAM,CAACC,MAAM,CAACH,KAAK,EAAE;IACnB;AACF;AACA;AACA;AACA;AACA;AACA;IACEI,YAAY,EAAE,IAAI;IAElB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEyI,eAAe;MAAE,SAAAC,SAAgBxI,QAAQ,EAAEC,OAAO;QAAA,IAAAQ,UAAA,EAAAgI,YAAA;QAAA,OAAAvB,mBAAA,CAAAS,KAAA;UAAA,SAAAe,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAAb,IAAA,GAAAa,SAAA,CAAAZ,IAAA;cAAA;gBAChDrI,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;gBAE9BC,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;kBACEM,YAAY,EAAE;gBAChB,CAAC,EACDF,OACF,CAAC;gBAEGQ,UAAU,GAAG,IAAI;gBAAAkI,SAAA,CAAAZ,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEM7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEN;gBAAS,CAAC,CAAC;cAAA;gBAAjEyI,YAAY,GAAAE,SAAA,CAAAR,IAAA;gBAAA,KAEdM,YAAY;kBAAAE,SAAA,CAAAZ,IAAA;kBAAA;gBAAA;gBAAAY,SAAA,CAAAZ,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACR7I,MAAM,CAACC,KAAK,CAACuJ,WAAW,CAC5B;kBAAEvI,GAAG,EAAEN;gBAAS,CAAC,EACjB;kBAAEO,YAAY,EAAE;oBAAEC,QAAQ,EAAE;kBAAG;gBAAE,CACnC,CAAC;cAAA;gBAAA,OAAAmI,SAAA,CAAAP,MAAA,WACM,IAAI;cAAA;gBAAAO,SAAA,CAAAZ,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEQ7I,MAAM,CAACC,KAAK,CAACwJ,WAAW,CAAC;kBAC1CxI,GAAG,EAAEN,QAAQ;kBACbQ,QAAQ,EAAE;gBACZ,CAAC,CAAC;cAAA;gBAHFC,UAAU,GAAAkI,SAAA,CAAAR,IAAA;cAAA;gBAAA,IAMP1H,UAAU;kBAAAkI,SAAA,CAAAZ,IAAA;kBAAA;gBAAA;gBAAA,KACT9H,OAAO,CAACE,YAAY;kBAAAwI,SAAA,CAAAZ,IAAA;kBAAA;gBAAA;gBAAA,OAAAY,SAAA,CAAAP,MAAA,WAAS,IAAI;cAAA;gBAAA,MAC/B,IAAI1H,KAAK,CAAC,QAAQ,GAAGV,QAAQ,GAAG,mBAAmB,CAAC;cAAA;gBAAA,OAAA2I,SAAA,CAAAP,MAAA,WAGrD3H,UAAU;cAAA;cAAA;gBAAA,OAAAkI,SAAA,CAAAN,IAAA;YAAA;UAAA;UAAA,OAAAK,SAAA;QAAA,uBAAAJ,OAAA;MAAA;MAClB,OAAAE,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEO,eAAe;MAAE,SAAAC,SAAgBhJ,QAAQ;QAAA,IAAAV,KAAA,EAAAsB,cAAA,EAAAqI,UAAA,EAAAC,MAAA,EAAA9H,CAAA;QAAA,OAAA8F,mBAAA,CAAAS,KAAA;UAAA,SAAAwB,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAAtB,IAAA,GAAAsB,SAAA,CAAArB,IAAA;cAAA;gBAIvCrI,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;;gBAE9B;gBAAAoJ,SAAA,CAAArB,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACM7I,MAAM,CAACI,cAAc,CAAC4J,WAAW,CAAC;kBACtC,UAAU,EAAErJ;gBACd,CAAC,CAAC;cAAA;gBAAAoJ,SAAA,CAAAE,EAAA,GAIQ5J,KAAK;gBAAA0J,SAAA,CAAArB,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACL7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEN;gBAAS,CAAC,CAAC;cAAA;gBAAAoJ,SAAA,CAAAG,EAAA,GAAAH,SAAA,CAAAjB,IAAA;gBADpD7I,KAAK,GAAA8J,SAAA,CAAAE,EAAA,CAASxI,mBAAmB,CAAAkG,IAAA,CAAAoC,SAAA,CAAAE,EAAA,EAAAF,SAAA,CAAAG,EAAA;gBAAAH,SAAA,CAAAI,EAAA,GAAArC,+BAAA;gBAAAiC,SAAA,CAAArB,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAIX7I,MAAM,CAACC,KAAK,CAC/B0B,IAAI,CAAC;kBAAEV,GAAG,EAAE;oBAAEW,GAAG,EAAE3B;kBAAM;gBAAE,CAAC,CAAC,CAC7BmK,UAAU,CAAC,CAAC;cAAA;gBAAAL,SAAA,CAAAM,EAAA,GAAAN,SAAA,CAAAjB,IAAA;gBAAAc,UAAA,OAAAG,SAAA,CAAAI,EAAA,EAAAJ,SAAA,CAAAM,EAAA;cAAA;gBAAA,KAAAR,MAAA,GAAAD,UAAA,IAAAjB,IAAA;kBAAAoB,SAAA,CAAArB,IAAA;kBAAA;gBAAA;gBAFJ3G,CAAC,GAAA8H,MAAA,CAAAjB,KAAA;gBAAAmB,SAAA,CAAArB,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGJ7I,MAAM,CAACC,KAAK,CAACuJ,WAAW,CAC5B;kBACEvI,GAAG,EAAEc,CAAC,CAACd;gBACT,CAAC,EACD;kBACEgB,KAAK,EAAE;oBACLd,QAAQ,EAAE;sBACRF,GAAG,EAAEN;oBACP;kBACF;gBACF,CACF,CAAC;cAAA;gBAAAoJ,SAAA,CAAAO,EAAA,GAAAzC,mBAAA;gBAAAkC,SAAA,CAAAQ,EAAA,GAEsBlK,KAAK;gBAAA0J,SAAA,CAAArB,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACpB7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEc,CAAC,CAACd;gBAAI,CAAC,CAAC;cAAA;gBAAA8I,SAAA,CAAAS,EAAA,GAAAT,SAAA,CAAAjB,IAAA;gBAAAiB,SAAA,CAAAU,EAAA,GAAAV,SAAA,CAAAQ,EAAA,CADpBG,2BAA2B,CAAA/C,IAAA,CAAAoC,SAAA,CAAAQ,EAAA,EAAAR,SAAA,CAAAS,EAAA;gBAAAT,SAAA,CAAArB,IAAA;gBAAA,OAAAqB,SAAA,CAAAO,EAAA,CAAAzB,KAAA,CAAAlB,IAAA,CAAAoC,SAAA,CAAAO,EAAA,EAAAP,SAAA,CAAAU,EAAA;cAAA;gBAAxDlJ,cAAc,GAAAwI,SAAA,CAAAjB,IAAA;gBAAAiB,SAAA,CAAArB,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGR7I,MAAM,CAACI,cAAc,CAACoJ,WAAW,CACrC;kBACE,UAAU,EAAEzH,CAAC,CAACd;gBAChB,CAAC,EACD;kBACEkB,IAAI,EAAE;oBACJZ,cAAc,EAAE,CAACQ,CAAC,CAACd,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKwB,cAAc,GAAEc,GAAG,CAAC,UAACC,EAAE;sBAAA,OAAM;wBACtDrB,GAAG,EAAEqB;sBACP,CAAC;oBAAA,CAAC;kBACJ;gBACF,CAAC,EACD;kBAAEC,KAAK,EAAE;gBAAK,CAChB,CAAC;cAAA;gBAAAwH,SAAA,CAAArB,IAAA;gBAAA;cAAA;gBAAA,IAEIzI,KAAK,CAACuC,MAAM,GAAG,CAAC;kBAAAuH,SAAA,CAAArB,IAAA;kBAAA;gBAAA;cAAA;gBAAAqB,SAAA,CAAArB,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGnB7I,MAAM,CAACC,KAAK,CAAC+J,WAAW,CAAC;kBAAE/I,GAAG,EAAEN;gBAAS,CAAC,CAAC;cAAA;cAAA;gBAAA,OAAAoJ,SAAA,CAAAf,IAAA;YAAA;UAAA;UAAA,OAAAc,SAAA;QAAA,uBAAAb,OAAA;MAAA;MAClD,OAAAU,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEgB,eAAe;MAAE,SAAAC,SAAgBlI,OAAO,EAAEC,OAAO;QAAA,IAAAC,KAAA,EAAAC,IAAA;QAAA,OAAAgF,mBAAA,CAAAS,KAAA;UAAA,SAAAuC,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAArC,IAAA,GAAAqC,SAAA,CAAApC,IAAA;cAAA;gBAG/CrI,KAAK,CAACQ,cAAc,CAAC6B,OAAO,CAAC;gBAC7BrC,KAAK,CAACQ,cAAc,CAAC8B,OAAO,CAAC;gBAAA,MAEzBD,OAAO,KAAKC,OAAO;kBAAAmI,SAAA,CAAApC,IAAA;kBAAA;gBAAA;gBAAA,OAAAoC,SAAA,CAAA/B,MAAA;cAAA;gBAAA+B,SAAA,CAAApC,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEJ7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEyB;gBAAQ,CAAC,CAAC;cAAA;gBAAxDG,IAAI,GAAAiI,SAAA,CAAAhC,IAAA;gBAAA,IAELjG,IAAI;kBAAAiI,SAAA,CAAApC,IAAA;kBAAA;gBAAA;gBAAA,MACD,IAAIrH,KAAK,CAAC,QAAQ,GAAGqB,OAAO,GAAG,mBAAmB,CAAC;cAAA;gBAG3DG,IAAI,CAAC5B,GAAG,GAAG0B,OAAO;gBAAAmI,SAAA,CAAApC,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEZ7I,MAAM,CAACC,KAAK,CAACwJ,WAAW,CAAC5G,IAAI,CAAC;cAAA;gBAAAiI,SAAA,CAAApC,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGpB7I,MAAM,CAACI,cAAc,CAACoJ,WAAW,CAC7C;kBACE,UAAU,EAAE9G;gBACd,CAAC,EACD;kBACEP,IAAI,EAAE;oBACJ,UAAU,EAAEQ;kBACd;gBACF,CAAC,EACD;kBAAEJ,KAAK,EAAE;gBAAK,CAChB,CAAC;cAAA;gBAVDK,KAAK,GAAAkI,SAAA,CAAAhC,IAAA;cAAA;gBAAA,IAWElG,KAAK,GAAG,CAAC;kBAAAkI,SAAA,CAAApC,IAAA;kBAAA;gBAAA;cAAA;gBAAAoC,SAAA,CAAApC,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGF7I,MAAM,CAACI,cAAc,CAACoJ,WAAW,CAC7C;kBACE,oBAAoB,EAAE9G;gBACxB,CAAC,EACD;kBACEP,IAAI,EAAE;oBACJ,sBAAsB,EAAEQ;kBAC1B;gBACF,CAAC,EACD;kBAAEJ,KAAK,EAAE;gBAAK,CAChB,CAAC;cAAA;gBAVDK,KAAK,GAAAkI,SAAA,CAAAhC,IAAA;cAAA;gBAAA,IAWElG,KAAK,GAAG,CAAC;kBAAAkI,SAAA,CAAApC,IAAA;kBAAA;gBAAA;cAAA;gBAAAoC,SAAA,CAAApC,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGF7I,MAAM,CAACC,KAAK,CAACuJ,WAAW,CACpC;kBACE,cAAc,EAAE9G;gBAClB,CAAC,EACD;kBACEP,IAAI,EAAE;oBACJ,gBAAgB,EAAEQ;kBACpB;gBACF,CAAC,EACD;kBAAEJ,KAAK,EAAE;gBAAK,CAChB,CAAC;cAAA;gBAVDK,KAAK,GAAAkI,SAAA,CAAAhC,IAAA;cAAA;gBAAA,IAWElG,KAAK,GAAG,CAAC;kBAAAkI,SAAA,CAAApC,IAAA;kBAAA;gBAAA;cAAA;gBAAAoC,SAAA,CAAApC,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEZ7I,MAAM,CAACC,KAAK,CAAC+J,WAAW,CAAC;kBAAE/I,GAAG,EAAEyB;gBAAQ,CAAC,CAAC;cAAA;cAAA;gBAAA,OAAAoI,SAAA,CAAA9B,IAAA;YAAA;UAAA;UAAA,OAAA6B,SAAA;QAAA,uBAAA5B,OAAA;MAAA;MACjD,OAAA2B,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEG,qBAAqB;MAAE,SAAAC,SAAgBhI,UAAU,EAAEC,UAAU;QAAA,IAAAgI,UAAA,EAAAC,MAAA,EAAAvK,QAAA;QAAA,OAAAkH,mBAAA,CAAAS,KAAA;UAAA,SAAA6C,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAA3C,IAAA,GAAA2C,SAAA,CAAA1C,IAAA;cAAA;gBAC3D;gBACA,IAAI,CAACxF,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;gBAAAiI,UAAA,GAAAnD,+BAAA,CAElC9E,UAAU;cAAA;gBAAA,KAAAkI,MAAA,GAAAD,UAAA,IAAAtC,IAAA;kBAAAyC,SAAA,CAAA1C,IAAA;kBAAA;gBAAA;gBAAtB/H,QAAQ,GAAAuK,MAAA,CAAAtC,KAAA;gBAAAwC,SAAA,CAAA1C,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACXxI,KAAK,CAACgL,qBAAqB,CAAC1K,QAAQ,EAAEsC,UAAU,CAAC;cAAA;gBAAAmI,SAAA,CAAA1C,IAAA;gBAAA;cAAA;cAAA;gBAAA,OAAA0C,SAAA,CAAApC,IAAA;YAAA;UAAA;UAAA,OAAAmC,SAAA;QAAA,uBAAAlC,OAAA;MAAA;MAE1D,OAAA+B,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACEK,qBAAqB;MAAE,SAAAC,SAAgB3K,QAAQ,EAAEsC,UAAU;QAAA,IAAAJ,IAAA,EAAAD,KAAA;QAAA,OAAAiF,mBAAA,CAAAS,KAAA;UAAA,SAAAiD,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAA/C,IAAA,GAAA+C,SAAA,CAAA9C,IAAA;cAAA;gBACzDrI,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;gBAC9BN,KAAK,CAACQ,cAAc,CAACoC,UAAU,CAAC;;gBAEhC;gBAAAuI,SAAA,CAAA9C,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACmB7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEN;gBAAS,CAAC,CAAC;cAAA;gBAAzDkC,IAAI,GAAA2I,SAAA,CAAA1C,IAAA;gBAAA,IAELjG,IAAI;kBAAA2I,SAAA,CAAA9C,IAAA;kBAAA;gBAAA;gBAAA,MACD,IAAIrH,KAAK,CAAC,QAAQ,GAAGV,QAAQ,GAAG,mBAAmB,CAAC;cAAA;gBAAA6K,SAAA,CAAA9C,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAIjDxI,KAAK,CAACqK,2BAA2B,CAAC7H,IAAI,CAAC;cAAA;gBAAA,KAAA2I,SAAA,CAAA1C,IAAA,CAAEzF,QAAQ,CAACJ,UAAU;kBAAAuI,SAAA,CAAA9C,IAAA;kBAAA;gBAAA;gBAAA,MAC/D,IAAIrH,KAAK,CACb,SAAS,GAAGV,QAAQ,GAAG,SAAS,GAAGsC,UAAU,GAAG,uBAClD,CAAC;cAAA;gBAAAuI,SAAA,CAAA9C,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGiB7I,MAAM,CAACC,KAAK,CAACuJ,WAAW,CAC1C;kBACEvI,GAAG,EAAEgC,UAAU;kBACf,cAAc,EAAE;oBACdK,GAAG,EAAET,IAAI,CAAC5B;kBACZ;gBACF,CAAC,EACD;kBACEsC,KAAK,EAAE;oBACLpC,QAAQ,EAAE;sBACRF,GAAG,EAAE4B,IAAI,CAAC5B;oBACZ;kBACF;gBACF,CACF,CAAC;cAAA;gBAdK2B,KAAK,GAAA4I,SAAA,CAAA1C,IAAA;gBAAA,IAkBNlG,KAAK;kBAAA4I,SAAA,CAAA9C,IAAA;kBAAA;gBAAA;gBAAA,OAAA8C,SAAA,CAAAzC,MAAA;cAAA;gBAAAyC,SAAA,CAAAvB,EAAA,GAAApC,mBAAA;gBAAA2D,SAAA,CAAAtB,EAAA,GAEJlK,MAAM,CAACI,cAAc;gBAAAoL,SAAA,CAAArB,EAAA,GACzB;kBACE,oBAAoB,EAAElH;gBACxB,CAAC;gBAAAuI,SAAA,CAAAnB,EAAA,IAKOxH,IAAI,CAAC5B,GAAG;gBAAAuK,SAAA,CAAAlB,EAAA,GAAAvK,kBAAA;gBAAAyL,SAAA,CAAA9C,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACExI,KAAK,CAACqK,2BAA2B,CAAC7H,IAAI,CAAC;cAAA;gBAAA2I,SAAA,CAAAjB,EAAA,GAAAiB,SAAA,CAAA1C,IAAA;gBAAA0C,SAAA,CAAAhB,EAAA,OAAAgB,SAAA,CAAAlB,EAAA,EAAAkB,SAAA,CAAAjB,EAAA;gBAAAiB,SAAA,CAAAf,EAAA,GAAAe,SAAA,CAAAnB,EAAA,CAAAjI,MAAA,CAAAuF,IAAA,CAAA6D,SAAA,CAAAnB,EAAA,EAAAmB,SAAA,CAAAhB,EAAA,EACjDnI,GAAG,CAAC,UAACN,CAAC;kBAAA,OAAM;oBAAEd,GAAG,EAAEc;kBAAE,CAAC;gBAAA,CAAC;gBAAAyJ,SAAA,CAAAC,EAAA;kBAHzBjI,KAAK,EAAAgI,SAAA,CAAAf;gBAAA;gBAAAe,SAAA,CAAAE,EAAA;kBADPnK,cAAc,EAAAiK,SAAA,CAAAC;gBAAA;gBAAAD,SAAA,CAAAG,GAAA;kBADhBpI,KAAK,EAAAiI,SAAA,CAAAE;gBAAA;gBAAAF,SAAA,CAAAI,GAAA,GASP;kBAAErJ,KAAK,EAAE;gBAAK,CAAC;gBAAAiJ,SAAA,CAAAK,GAAA,GAAAL,SAAA,CAAAtB,EAAA,CAdWV,WAAW,CAAA7B,IAAA,CAAA6D,SAAA,CAAAtB,EAAA,EAAAsB,SAAA,CAAArB,EAAA,EAAAqB,SAAA,CAAAG,GAAA,EAAAH,SAAA,CAAAI,GAAA;gBAAAJ,SAAA,CAAA9C,IAAA;gBAAA,OAAA8C,SAAA,CAAAvB,EAAA,CAAApB,KAAA,CAAAlB,IAAA,CAAA6D,SAAA,CAAAvB,EAAA,EAAAuB,SAAA,CAAAK,GAAA;cAAA;cAAA;gBAAA,OAAAL,SAAA,CAAAxC,IAAA;YAAA;UAAA;UAAA,OAAAuC,SAAA;QAAA,uBAAAtC,OAAA;MAAA;MAgBxC,OAAAqC,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEQ,0BAA0B;MAAE,SAAAC,SAAgB/I,UAAU,EAAEC,UAAU;QAAA,IAAA+I,UAAA,EAAAC,MAAA,EAAAtL,QAAA;QAAA,OAAAkH,mBAAA,CAAAS,KAAA;UAAA,SAAA4D,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAA1D,IAAA,GAAA0D,SAAA,CAAAzD,IAAA;cAAA;gBAChE;gBACA,IAAI,CAACxF,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;gBAAAgJ,UAAA,GAAAlE,+BAAA,CAElC9E,UAAU;cAAA;gBAAA,KAAAiJ,MAAA,GAAAD,UAAA,IAAArD,IAAA;kBAAAwD,SAAA,CAAAzD,IAAA;kBAAA;gBAAA;gBAAtB/H,QAAQ,GAAAsL,MAAA,CAAArD,KAAA;gBAAAuD,SAAA,CAAAzD,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACXxI,KAAK,CAAC+L,0BAA0B,CAACzL,QAAQ,EAAEsC,UAAU,CAAC;cAAA;gBAAAkJ,SAAA,CAAAzD,IAAA;gBAAA;cAAA;cAAA;gBAAA,OAAAyD,SAAA,CAAAnD,IAAA;YAAA;UAAA;UAAA,OAAAkD,SAAA;QAAA,uBAAAjD,OAAA;MAAA;MAE/D,OAAA8C,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACEK,0BAA0B;MAAE,SAAAC,SAAgB1L,QAAQ,EAAEsC,UAAU;QAAA,IAAAJ,IAAA,EAAAD,KAAA,EAAA3C,KAAA,EAAAqM,UAAA,EAAAC,MAAA,EAAAxK,CAAA,EAAAR,cAAA;QAAA,OAAAsG,mBAAA,CAAAS,KAAA;UAAA,SAAAkE,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAAhE,IAAA,GAAAgE,SAAA,CAAA/D,IAAA;cAAA;gBAC9DrI,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;gBAC9BN,KAAK,CAACQ,cAAc,CAACoC,UAAU,CAAC;;gBAEhC;gBACA;gBAAAwJ,SAAA,CAAA/D,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACmB7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAC1C;kBAAEtI,GAAG,EAAEN;gBAAS,CAAC,EACjB;kBAAEgD,MAAM,EAAE;oBAAE1C,GAAG,EAAE;kBAAE;gBAAE,CACvB,CAAC;cAAA;gBAHK4B,IAAI,GAAA4J,SAAA,CAAA3D,IAAA;gBAAA,IAKLjG,IAAI;kBAAA4J,SAAA,CAAA/D,IAAA;kBAAA;gBAAA;gBAAA,MACD,IAAIrH,KAAK,CAAC,QAAQ,GAAGV,QAAQ,GAAG,mBAAmB,CAAC;cAAA;gBAAA8L,SAAA,CAAA/D,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGxC7I,MAAM,CAACC,KAAK,CAACuJ,WAAW,CAC1C;kBACEvI,GAAG,EAAEgC;gBACP,CAAC,EACD;kBACEhB,KAAK,EAAE;oBACLd,QAAQ,EAAE;sBACRF,GAAG,EAAE4B,IAAI,CAAC5B;oBACZ;kBACF;gBACF,CACF,CAAC;cAAA;gBAXK2B,KAAK,GAAA6J,SAAA,CAAA3D,IAAA;gBAAA,IAeNlG,KAAK;kBAAA6J,SAAA,CAAA/D,IAAA;kBAAA;gBAAA;gBAAA,OAAA+D,SAAA,CAAA1D,MAAA;cAAA;gBAAA0D,SAAA,CAAAxC,EAAA;gBAAAwC,SAAA,CAAAvC,EAAA,GAAAnK,kBAAA;gBAAA0M,SAAA,CAAAtC,EAAA,GAAAtC,mBAAA;gBAAA4E,SAAA,CAAApC,EAAA,GAIEhK,KAAK;gBAAAoM,SAAA,CAAA/D,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACP7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEgC;gBAAW,CAAC,CAAC;cAAA;gBAAAwJ,SAAA,CAAAnC,EAAA,GAAAmC,SAAA,CAAA3D,IAAA;gBAAA2D,SAAA,CAAAlC,EAAA,GAAAkC,SAAA,CAAApC,EAAA,CADtCqC,wBAAwB,CAAA/E,IAAA,CAAA8E,SAAA,CAAApC,EAAA,EAAAoC,SAAA,CAAAnC,EAAA;gBAAAmC,SAAA,CAAA/D,IAAA;gBAAA,OAAA+D,SAAA,CAAAtC,EAAA,CAAAtB,KAAA,CAAAlB,IAAA,CAAA8E,SAAA,CAAAtC,EAAA,EAAAsC,SAAA,CAAAlC,EAAA;cAAA;gBAAAkC,SAAA,CAAAjC,EAAA,GAAAiC,SAAA,CAAA3D,IAAA;gBAAA2D,SAAA,CAAAhC,EAAA,OAAAgC,SAAA,CAAAvC,EAAA,EAAAuC,SAAA,CAAAjC,EAAA;gBAAAiC,SAAA,CAAAhB,EAAA,IAGxCxI,UAAU;gBAJNhD,KAAK,GAAAwM,SAAA,CAAAxC,EAAA,CAAA7H,MAAA,CAAAuF,IAAA,CAAA8E,SAAA,CAAAxC,EAAA,EAAAwC,SAAA,CAAAhC,EAAA,EAAAgC,SAAA,CAAAhB,EAAA;gBAAAgB,SAAA,CAAAf,EAAA,GAAA5D,+BAAA;gBAAA2E,SAAA,CAAA/D,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAOW7I,MAAM,CAACC,KAAK,CAC/B0B,IAAI,CAAC;kBAAEV,GAAG,EAAE;oBAAEW,GAAG,EAAE3B;kBAAM;gBAAE,CAAC,CAAC,CAC7BmK,UAAU,CAAC,CAAC;cAAA;gBAAAqC,SAAA,CAAAd,GAAA,GAAAc,SAAA,CAAA3D,IAAA;gBAAAwD,UAAA,OAAAG,SAAA,CAAAf,EAAA,EAAAe,SAAA,CAAAd,GAAA;cAAA;gBAAA,KAAAY,MAAA,GAAAD,UAAA,IAAA3D,IAAA;kBAAA8D,SAAA,CAAA/D,IAAA;kBAAA;gBAAA;gBAFJ3G,CAAC,GAAAwK,MAAA,CAAA3D,KAAA;gBAAA6D,SAAA,CAAAb,GAAA,GAAA/D,mBAAA;gBAAA4E,SAAA,CAAAZ,GAAA,GAGmBxL,KAAK;gBAAAoM,SAAA,CAAA/D,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAC1B7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEc,CAAC,CAACd;gBAAI,CAAC,CAAC;cAAA;gBAAAwL,SAAA,CAAAE,GAAA,GAAAF,SAAA,CAAA3D,IAAA;gBAAA2D,SAAA,CAAAG,GAAA,GAAAH,SAAA,CAAAZ,GAAA,CADdnB,2BAA2B,CAAA/C,IAAA,CAAA8E,SAAA,CAAAZ,GAAA,EAAAY,SAAA,CAAAE,GAAA;gBAAAF,SAAA,CAAA/D,IAAA;gBAAA,OAAA+D,SAAA,CAAAb,GAAA,CAAA/C,KAAA,CAAAlB,IAAA,CAAA8E,SAAA,CAAAb,GAAA,EAAAa,SAAA,CAAAG,GAAA;cAAA;gBAAxDrL,cAAc,GAAAkL,SAAA,CAAA3D,IAAA;gBAAA2D,SAAA,CAAA/D,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGd7I,MAAM,CAACI,cAAc,CAACoJ,WAAW,CACrC;kBACE,UAAU,EAAEzH,CAAC,CAACd,GAAG;kBACjB,oBAAoB,EAAE4B,IAAI,CAAC5B;gBAC7B,CAAC,EACD;kBACEkB,IAAI,EAAE;oBACJZ,cAAc,EAAE,CAACQ,CAAC,CAACd,GAAG,EAAAmB,MAAA,CAAArC,kBAAA,CAAKwB,cAAc,GAAEc,GAAG,CAAC,UAACC,EAAE;sBAAA,OAAM;wBACtDrB,GAAG,EAAEqB;sBACP,CAAC;oBAAA,CAAC;kBACJ;gBACF,CAAC,EACD;kBAAEC,KAAK,EAAE;gBAAK,CAChB,CAAC;cAAA;gBAAAkK,SAAA,CAAA/D,IAAA;gBAAA;cAAA;cAAA;gBAAA,OAAA+D,SAAA,CAAAzD,IAAA;YAAA;UAAA;UAAA,OAAAwD,SAAA;QAAA,uBAAAvD,OAAA;MAAA;MAEJ,OAAAoD,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEQ,oBAAoB;MAAE,SAAAC,SAAgBjJ,KAAK,EAAE5D,KAAK,EAAEW,OAAO;QAAA,IAAAkD,EAAA,EAAAiJ,UAAA,EAAAC,MAAA,EAAA7I,IAAA,EAAA8I,UAAA,EAAAC,MAAA,EAAArK,IAAA;QAAA,OAAAgF,mBAAA,CAAAS,KAAA;UAAA,SAAA6E,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAA3E,IAAA,GAAA2E,SAAA,CAAA1E,IAAA;cAAA;gBAAA,IAGpD7E,KAAK;kBAAAuJ,SAAA,CAAA1E,IAAA;kBAAA;gBAAA;gBAAA,MAAQ,IAAIrH,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAAA,IAChDpB,KAAK;kBAAAmN,SAAA,CAAA1E,IAAA;kBAAA;gBAAA;gBAAA,MAAQ,IAAIrH,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAErDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;gBAE1C;gBACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;gBAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;kBACE0D,QAAQ,EAAE;gBACZ,CAAC,EACDtD,OACF,CAAC;gBAAAmM,UAAA,GAAAjF,+BAAA,CAEkBjE,KAAK;cAAA;gBAAA,KAAAmJ,MAAA,GAAAD,UAAA,IAAApE,IAAA;kBAAAyE,SAAA,CAAA1E,IAAA;kBAAA;gBAAA;gBAAbvE,IAAI,GAAA6I,MAAA,CAAApE,KAAA;gBACb,IAAIlJ,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;kBAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;gBACf,CAAC,MAAM;kBACL6C,EAAE,GAAGK,IAAI;gBACX;gBAAC8I,UAAA,GAAAnF,+BAAA,CAEkB7H,KAAK;cAAA;gBAAA,KAAAiN,MAAA,GAAAD,UAAA,IAAAtE,IAAA;kBAAAyE,SAAA,CAAA1E,IAAA;kBAAA;gBAAA;gBAAb7F,IAAI,GAAAqK,MAAA,CAAAtE,KAAA;gBAAAwE,SAAA,CAAA1E,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACPxI,KAAK,CAACgN,mBAAmB,CAACvJ,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;cAAA;gBAAAwM,SAAA,CAAA1E,IAAA;gBAAA;cAAA;gBAAA0E,SAAA,CAAA1E,IAAA;gBAAA;cAAA;cAAA;gBAAA,OAAA0E,SAAA,CAAApE,IAAA;YAAA;UAAA;UAAA,OAAAmE,SAAA;QAAA,uBAAAlE,OAAA;MAAA;MAGvD,OAAA6D,QAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEQ,iBAAiB;MAAE,SAAAC,UAAgB1J,KAAK,EAAE5D,KAAK,EAAEW,OAAO;QAAA,IAAAkD,EAAA,EAAA0J,UAAA,EAAAC,MAAA,EAAAtJ,IAAA,EAAAI,QAAA,EAAAmJ,UAAA,EAAAC,MAAA,EAAA9K,IAAA;QAAA,OAAAgF,mBAAA,CAAAS,KAAA;UAAA,SAAAsF,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAApF,IAAA,GAAAoF,UAAA,CAAAnF,IAAA;cAAA;gBAAA,IAGjD7E,KAAK;kBAAAgK,UAAA,CAAAnF,IAAA;kBAAA;gBAAA;gBAAA,MAAQ,IAAIrH,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAAA,IAChDpB,KAAK;kBAAA4N,UAAA,CAAAnF,IAAA;kBAAA;gBAAA;gBAAA,MAAQ,IAAIrH,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAErDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;gBAE1C;gBACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;gBAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;kBACE0D,QAAQ,EAAE,KAAK;kBACfI,QAAQ,EAAE;gBACZ,CAAC,EACD1D,OACF,CAAC;gBAAA4M,UAAA,GAAA1F,+BAAA,CAEkBjE,KAAK;cAAA;gBAAA,KAAA4J,MAAA,GAAAD,UAAA,IAAA7E,IAAA;kBAAAkF,UAAA,CAAAnF,IAAA;kBAAA;gBAAA;gBAAbvE,IAAI,GAAAsJ,MAAA,CAAA7E,KAAA;gBACb,IAAIlJ,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;kBAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;gBACf,CAAC,MAAM;kBACL6C,EAAE,GAAGK,IAAI;gBACX;gBACA;gBACMI,QAAQ,GAAG;kBAAE,UAAU,EAAET;gBAAG,CAAC;gBACnC,IAAI,CAAClD,OAAO,CAAC0D,QAAQ,EAAE;kBACrBC,QAAQ,CAACN,KAAK,GAAGrD,OAAO,CAACqD,KAAK;gBAChC;gBAAC4J,UAAA,CAAAnF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEK7I,MAAM,CAACI,cAAc,CAAC4J,WAAW,CAACzF,QAAQ,CAAC;cAAA;gBAAAmJ,UAAA,GAAA5F,+BAAA,CAG9B7H,KAAK;cAAA;gBAAA,KAAA0N,MAAA,GAAAD,UAAA,IAAA/E,IAAA;kBAAAkF,UAAA,CAAAnF,IAAA;kBAAA;gBAAA;gBAAb7F,IAAI,GAAA8K,MAAA,CAAA/E,KAAA;gBAAAiF,UAAA,CAAAnF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACPxI,KAAK,CAAC+D,cAAc,CAACN,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;cAAA;gBAAAiN,UAAA,CAAAnF,IAAA;gBAAA;cAAA;gBAAAmF,UAAA,CAAAnF,IAAA;gBAAA;cAAA;cAAA;gBAAA,OAAAmF,UAAA,CAAA7E,IAAA;YAAA;UAAA;UAAA,OAAA4E,UAAA;QAAA,uBAAA3E,OAAA;MAAA;MAGlD,OAAAsE,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEF,mBAAmB;MAAE,SAAAS,UAAgBtJ,MAAM,EAAE7D,QAAQ,EAAEC,OAAO;QAAA,IAAAiC,IAAA,EAAAkL,kBAAA,EAAA3M,UAAA,EAAAqD,GAAA;QAAA,OAAAoD,mBAAA,CAAAS,KAAA;UAAA,SAAA0F,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAxF,IAAA,GAAAwF,UAAA,CAAAvF,IAAA;cAAA;gBAC5DrI,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;gBAC9BN,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;gBAAA,IAE/BO,MAAM;kBAAAyJ,UAAA,CAAAvF,IAAA;kBAAA;gBAAA;gBAAA,OAAAuF,UAAA,CAAAlF,MAAA;cAAA;gBAAAkF,UAAA,CAAAvF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAIQ7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAC1C;kBAAEtI,GAAG,EAAEN;gBAAS,CAAC,EACjB;kBAAEgD,MAAM,EAAE;oBAAExC,QAAQ,EAAE;kBAAE;gBAAE,CAC5B,CAAC;cAAA;gBAHK0B,IAAI,GAAAoL,UAAA,CAAAnF,IAAA;gBAAA,IAKLjG,IAAI;kBAAAoL,UAAA,CAAAvF,IAAA;kBAAA;gBAAA;gBAAA,KACH9H,OAAO,CAACsD,QAAQ;kBAAA+J,UAAA,CAAAvF,IAAA;kBAAA;gBAAA;gBAAA,OAAAuF,UAAA,CAAAlF,MAAA,WACX,EAAE;cAAA;gBAAA,MAEH,IAAI1H,KAAK,CAAC,QAAQ,GAAGV,QAAQ,GAAG,mBAAmB,CAAC;cAAA;gBAAAsN,UAAA,CAAAvF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAoB7B7I,MAAM,CAACI,cAAc,CAACmJ,YAAY,CAAC;kBAClE,UAAU,EAAE/E,MAAM;kBAClB,UAAU,EAAE7D,QAAQ;kBACpBsD,KAAK,EAAErD,OAAO,CAACqD;gBACjB,CAAC,CAAC;cAAA;gBAJI8J,kBAAkB,GAAAE,UAAA,CAAAnF,IAAA;gBAAA,KAQpBiF,kBAAkB;kBAAAE,UAAA,CAAAvF,IAAA;kBAAA;gBAAA;gBAAAuF,UAAA,CAAAvF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACd7I,MAAM,CAACI,cAAc,CAACoJ,WAAW,CAACuE,kBAAkB,CAAC9M,GAAG,EAAE;kBAC9DkB,IAAI,EAAE;oBACJgC,IAAI,EAAE;sBAAElD,GAAG,EAAEuD;oBAAO,CAAC;oBACrB3B,IAAI,EAAE;sBAAE5B,GAAG,EAAEN;oBAAS,CAAC;oBACvBsD,KAAK,EAAErD,OAAO,CAACqD;kBACjB;gBACF,CAAC,CAAC;cAAA;gBAAAgK,UAAA,CAAAvF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEU7I,MAAM,CAACI,cAAc,CAACmJ,YAAY,CAACwE,kBAAkB,CAAC9M,GAAG,CAAC;cAAA;gBAAtEwD,GAAG,GAAAwJ,UAAA,CAAAnF,IAAA;gBAAAmF,UAAA,CAAAvF,IAAA;gBAAA;cAAA;gBAAAuF,UAAA,CAAAvF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEgB7I,MAAM,CAACI,cAAc,CAACqJ,WAAW,CAAC;kBACnDtF,IAAI,EAAE;oBAAElD,GAAG,EAAEuD;kBAAO,CAAC;kBACrB3B,IAAI,EAAE;oBAAE5B,GAAG,EAAEN;kBAAS,CAAC;kBACvBsD,KAAK,EAAErD,OAAO,CAACqD;gBACjB,CAAC,CAAC;cAAA;gBAJF7C,UAAU,GAAA6M,UAAA,CAAAnF,IAAA;cAAA;gBAAA,KAOR1H,UAAU;kBAAA6M,UAAA,CAAAvF,IAAA;kBAAA;gBAAA;gBAAAuF,UAAA,CAAAhE,EAAA,GAAApC,mBAAA;gBAAAoG,UAAA,CAAA/D,EAAA,GACNlK,MAAM,CAACI,cAAc;gBAAA6N,UAAA,CAAA9D,EAAA,GACzB;kBAAElJ,GAAG,EAAEG;gBAAW,CAAC;gBAAA6M,UAAA,CAAA5D,EAAA,IAIb1J,QAAQ;gBAAAsN,UAAA,CAAA3D,EAAA,GAAAvK,kBAAA;gBAAAkO,UAAA,CAAAvF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACExI,KAAK,CAACqK,2BAA2B,CAAC7H,IAAI,CAAC;cAAA;gBAAAoL,UAAA,CAAA1D,EAAA,GAAA0D,UAAA,CAAAnF,IAAA;gBAAAmF,UAAA,CAAAzD,EAAA,OAAAyD,UAAA,CAAA3D,EAAA,EAAA2D,UAAA,CAAA1D,EAAA;gBAAA0D,UAAA,CAAAxD,EAAA,GAAAwD,UAAA,CAAA5D,EAAA,CAAAjI,MAAA,CAAAuF,IAAA,CAAAsG,UAAA,CAAA5D,EAAA,EAAA4D,UAAA,CAAAzD,EAAA,EACjDnI,GAAG,CAAC,UAACN,CAAC;kBAAA,OAAM;oBAAEd,GAAG,EAAEc;kBAAE,CAAC;gBAAA,CAAC;gBAAAkM,UAAA,CAAAxC,EAAA;kBAHzBlK,cAAc,EAAA0M,UAAA,CAAAxD;gBAAA;gBAAAwD,UAAA,CAAAvC,EAAA;kBADhBvJ,IAAI,EAAA8L,UAAA,CAAAxC;gBAAA;gBAAAwC,UAAA,CAAAtC,GAAA,GAAAsC,UAAA,CAAA/D,EAAA,CAHoBV,WAAW,CAAA7B,IAAA,CAAAsG,UAAA,CAAA/D,EAAA,EAAA+D,UAAA,CAAA9D,EAAA,EAAA8D,UAAA,CAAAvC,EAAA;gBAAAuC,UAAA,CAAAvF,IAAA;gBAAA,OAAAuF,UAAA,CAAAhE,EAAA,CAAApB,KAAA,CAAAlB,IAAA,CAAAsG,UAAA,CAAAhE,EAAA,EAAAgE,UAAA,CAAAtC,GAAA;cAAA;gBAAAsC,UAAA,CAAAvF,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAY3B7I,MAAM,CAACI,cAAc,CAACmJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEG;gBAAW,CAAC,CAAC;cAAA;gBAAnEqD,GAAG,GAAAwJ,UAAA,CAAAnF,IAAA;cAAA;gBAELrE,GAAG,CAACrD,UAAU,GAAGA,UAAU,EAAC;gBAAA,OAAA6M,UAAA,CAAAlF,MAAA,WAErBtE,GAAG;cAAA;cAAA;gBAAA,OAAAwJ,UAAA,CAAAjF,IAAA;YAAA;UAAA;UAAA,OAAAgF,UAAA;QAAA,uBAAA/E,OAAA;MAAA;MACX,OAAA6E,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEpB,wBAAwB;MAAE,SAAAwB,UAAgBrL,IAAI;QAAA,IAAA6B,WAAA,EAAAyJ,WAAA,EAAAC,OAAA,EAAAzN,QAAA,EAAA0N,WAAA,EAAAC,OAAA,EAAA1J,UAAA;QAAA,OAAAiD,mBAAA,CAAAS,KAAA;UAAA,SAAAiG,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAA/F,IAAA,GAAA+F,UAAA,CAAA9F,IAAA;cAAA;gBAAA,IACvC7F,IAAI;kBAAA2L,UAAA,CAAA9F,IAAA;kBAAA;gBAAA;gBAAA,OAAA8F,UAAA,CAAAzF,MAAA,WACA,EAAE;cAAA;gBAGLrE,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC9B,IAAI,CAAC5B,GAAG,CAAC,CAAC;gBAAAkN,WAAA,GAAArG,+BAAA,CAEhBpD,WAAW;cAAA;gBAAA,KAAA0J,OAAA,GAAAD,WAAA,IAAAxF,IAAA;kBAAA6F,UAAA,CAAA9F,IAAA;kBAAA;gBAAA;gBAAvB/H,QAAQ,GAAAyN,OAAA,CAAAxF,KAAA;gBAAA4F,UAAA,CAAAvE,EAAA,GAAAnC,+BAAA;gBAAA0G,UAAA,CAAA9F,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACc7I,MAAM,CAACC,KAAK,CACxC0B,IAAI,CAAC;kBAAE,cAAc,EAAEhB;gBAAS,CAAC,CAAC,CAClCyJ,UAAU,CAAC,CAAC;cAAA;gBAAAoE,UAAA,CAAAtE,EAAA,GAAAsE,UAAA,CAAA1F,IAAA;gBAAAuF,WAAA,OAAAG,UAAA,CAAAvE,EAAA,EAAAuE,UAAA,CAAAtE,EAAA;cAAA;gBAAA,KAAAoE,OAAA,GAAAD,WAAA,IAAA1F,IAAA;kBAAA6F,UAAA,CAAA9F,IAAA;kBAAA;gBAAA;gBAFJ9D,UAAU,GAAA0J,OAAA,CAAA1F,KAAA;gBAGnBlE,WAAW,CAACG,GAAG,CAACD,UAAU,CAAC3D,GAAG,CAAC;cAAA;gBAAAuN,UAAA,CAAA9F,IAAA;gBAAA;cAAA;gBAAA8F,UAAA,CAAA9F,IAAA;gBAAA;cAAA;gBAInChE,WAAW,CAACI,MAAM,CAACjC,IAAI,CAAC5B,GAAG,CAAC;gBAAA,OAAAuN,UAAA,CAAAzF,MAAA,WAAAhJ,kBAAA,CAEjB2E,WAAW;cAAA;cAAA;gBAAA,OAAA8J,UAAA,CAAAxF,IAAA;YAAA;UAAA;UAAA,OAAAuF,UAAA;QAAA,uBAAAtF,OAAA;MAAA;MACvB,OAAAiF,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACExD,2BAA2B;MAAE,SAAA+D,UAAgB5L,IAAI;QAAA,IAAAtB,cAAA,EAAAwD,WAAA,EAAA2J,WAAA,EAAAC,OAAA,EAAA5M,CAAA,EAAA9B,KAAA,EAAA2O,WAAA,EAAAC,OAAA,EAAAvM,EAAA;QAAA,OAAAuF,mBAAA,CAAAS,KAAA;UAAA,SAAAwG,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAtG,IAAA,GAAAsG,UAAA,CAAArG,IAAA;cAAA;gBACzCnH,cAAc,GAAG,IAAIoD,GAAG,CAAC,CAAC;gBAC1BI,WAAW,GAAG,IAAIJ,GAAG,CAAC,CAAC9B,IAAI,CAAC,CAAC;gBAAA6L,WAAA,GAAA5G,+BAAA,CAEnB/C,WAAW;cAAA;gBAAA,KAAA4J,OAAA,GAAAD,WAAA,IAAA/F,IAAA;kBAAAoG,UAAA,CAAArG,IAAA;kBAAA;gBAAA;gBAAhB3G,CAAC,GAAA4M,OAAA,CAAA/F,KAAA;gBAAAmG,UAAA,CAAArG,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CACU7I,MAAM,CAACC,KAAK,CAC7B0B,IAAI,CACH;kBAAEV,GAAG,EAAE;oBAAEW,GAAG,EAAEG,CAAC,CAACZ,QAAQ,CAACkB,GAAG,CAAC,UAACN,CAAC;sBAAA,OAAKA,CAAC,CAACd,GAAG;oBAAA;kBAAE;gBAAE,CAAC,EAC9C;kBAAE0C,MAAM,EAAE;oBAAExC,QAAQ,EAAE;kBAAE;gBAAE,CAC5B,CAAC,CACAiJ,UAAU,CAAC,CAAC;cAAA;gBALTnK,KAAK,GAAA8O,UAAA,CAAAjG,IAAA;gBAOX,KAAA8F,WAAA,GAAA9G,+BAAA,CAAiB7H,KAAK,KAAA4O,OAAA,GAAAD,WAAA,IAAAjG,IAAA,GAAE;kBAAbrG,EAAE,GAAAuM,OAAA,CAAAjG,KAAA;kBACXrH,cAAc,CAACsD,GAAG,CAACvC,EAAE,CAACrB,GAAG,CAAC;kBAC1B8D,WAAW,CAACF,GAAG,CAACvC,EAAE,CAAC;gBACrB;cAAC;gBAAAyM,UAAA,CAAArG,IAAA;gBAAA;cAAA;gBAAA,OAAAqG,UAAA,CAAAhG,MAAA,WAAAhJ,kBAAA,CAGQwB,cAAc;cAAA;cAAA;gBAAA,OAAAwN,UAAA,CAAA/F,IAAA;YAAA;UAAA;UAAA,OAAA8F,UAAA;QAAA,uBAAA7F,OAAA;MAAA;MAC1B,OAAAwF,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEO,yBAAyB;MAAE,SAAAC,UAAgBpL,KAAK,EAAE5D,KAAK,EAAEW,OAAO;QAAA,IAAAsO,WAAA,EAAAC,OAAA,EAAAhL,IAAA,EAAAiL,WAAA,EAAAC,OAAA,EAAAxM,IAAA,EAAAiB,EAAA;QAAA,OAAA+D,mBAAA,CAAAS,KAAA;UAAA,SAAAgH,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAA9G,IAAA,GAAA8G,UAAA,CAAA7G,IAAA;cAAA;gBAAA,IACzD7E,KAAK;kBAAA0L,UAAA,CAAA7G,IAAA;kBAAA;gBAAA;gBAAA,MAAQ,IAAIrH,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAAA,IAChDpB,KAAK;kBAAAsP,UAAA,CAAA7G,IAAA;kBAAA;gBAAA;gBAAA,MAAQ,IAAIrH,KAAK,CAAC,wBAAwB,CAAC;cAAA;gBAErDT,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;gBAE1C;gBACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAACU,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAC1C,IAAI,CAACX,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;gBAAAiL,WAAA,GAAApH,+BAAA,CAEjBjE,KAAK;cAAA;gBAAA,KAAAsL,OAAA,GAAAD,WAAA,IAAAvG,IAAA;kBAAA4G,UAAA,CAAA7G,IAAA;kBAAA;gBAAA;gBAAbvE,IAAI,GAAAgL,OAAA,CAAAvG,KAAA;gBAAA,IACRzE,IAAI;kBAAAoL,UAAA,CAAA7G,IAAA;kBAAA;gBAAA;gBAAA,OAAA6G,UAAA,CAAAxG,MAAA;cAAA;gBAAAqG,WAAA,GAAAtH,+BAAA,CAEU7H,KAAK;cAAA;gBAAA,KAAAoP,OAAA,GAAAD,WAAA,IAAAzG,IAAA;kBAAA4G,UAAA,CAAA7G,IAAA;kBAAA;gBAAA;gBAAb7F,IAAI,GAAAwM,OAAA,CAAAzG,KAAA;gBACT9E,EAAE;gBACN,IAAIpE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;kBAC5BL,EAAE,GAAGK,IAAI,CAAClD,GAAG;gBACf,CAAC,MAAM;kBACL6C,EAAE,GAAGK,IAAI;gBACX;gBAACoL,UAAA,CAAA7G,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEKxI,KAAK,CAACmP,wBAAwB,CAAC1L,EAAE,EAAEjB,IAAI,EAAEjC,OAAO,CAAC;cAAA;gBAAA2O,UAAA,CAAA7G,IAAA;gBAAA;cAAA;gBAAA6G,UAAA,CAAA7G,IAAA;gBAAA;cAAA;cAAA;gBAAA,OAAA6G,UAAA,CAAAvG,IAAA;YAAA;UAAA;UAAA,OAAAsG,UAAA;QAAA,uBAAArG,OAAA;MAAA;MAG5D,OAAAgG,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEO,wBAAwB;MAAE,SAAAC,UAAgBjL,MAAM,EAAE7D,QAAQ,EAAEC,OAAO;QAAA,IAAA2D,QAAA;QAAA,OAAAsD,mBAAA,CAAAS,KAAA;UAAA,SAAAoH,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAlH,IAAA,GAAAkH,UAAA,CAAAjH,IAAA;cAAA;gBACjErI,KAAK,CAACQ,cAAc,CAACF,QAAQ,CAAC;gBAC9BN,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;gBAAA,IAE/BO,MAAM;kBAAAmL,UAAA,CAAAjH,IAAA;kBAAA;gBAAA;gBAAA,OAAAiH,UAAA,CAAA5G,MAAA;cAAA;gBAELxE,QAAQ,GAAG;kBACf,UAAU,EAAEC,MAAM;kBAClB,UAAU,EAAE7D;gBACd,CAAC;gBAED,IAAI,CAACC,OAAO,CAAC0D,QAAQ,EAAE;kBACrBC,QAAQ,CAACN,KAAK,GAAGrD,OAAO,CAACqD,KAAK;gBAChC;gBAAC0L,UAAA,CAAAjH,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEK7I,MAAM,CAACI,cAAc,CAAC4J,WAAW,CAACzF,QAAQ,CAAC;cAAA;cAAA;gBAAA,OAAAoL,UAAA,CAAA3G,IAAA;YAAA;UAAA;UAAA,OAAA0G,UAAA;QAAA,uBAAAzG,OAAA;MAAA;MAClD,OAAAwG,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEG,iBAAiB;MAAE,SAAAC,UAAgB1L,IAAI,EAAElE,KAAK,EAAEW,OAAO;QAAA,IAAAkD,EAAA,EAAAS,QAAA,EAAAE,GAAA;QAAA,OAAAoD,mBAAA,CAAAS,KAAA;UAAA,SAAAwH,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAtH,IAAA,GAAAsH,UAAA,CAAArH,IAAA;cAAA;gBAGrD9H,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;;gBAE1C;gBACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAE1CA,KAAK,GAAGA,KAAK,CAACkF,MAAM,CAAC,UAACpD,CAAC;kBAAA,OAAKA,CAAC,IAAI,IAAI;gBAAA,EAAC;gBAAA,IAEjC9B,KAAK,CAACuC,MAAM;kBAAAuN,UAAA,CAAArH,IAAA;kBAAA;gBAAA;gBAAA,OAAAqH,UAAA,CAAAhH,MAAA,WAAS,KAAK;cAAA;gBAE/B1I,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;gBAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;kBACE8D,QAAQ,EAAE;gBACZ,CAAC,EACD1D,OACF,CAAC;gBAED,IAAIuD,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;kBACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;gBACf,CAAC,MAAM;kBACL6C,EAAE,GAAGK,IAAI;gBACX;gBAAC,IAEIL,EAAE;kBAAAiM,UAAA,CAAArH,IAAA;kBAAA;gBAAA;gBAAA,OAAAqH,UAAA,CAAAhH,MAAA,WAAS,KAAK;cAAA;gBAAA,MACjB,OAAOjF,EAAE,KAAK,QAAQ;kBAAAiM,UAAA,CAAArH,IAAA;kBAAA;gBAAA;gBAAA,OAAAqH,UAAA,CAAAhH,MAAA,WAAS,KAAK;cAAA;gBAElCxE,QAAQ,GAAG;kBACf,UAAU,EAAET;gBACd,CAAC;gBAED,IAAI,CAAClD,OAAO,CAAC0D,QAAQ,EAAE;kBACrBC,QAAQ,CAACN,KAAK,GAAG;oBAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK,EAAE,IAAI;kBAAE,CAAC;gBACjD;gBAAC8L,UAAA,CAAArH,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEiBd,SAAS,CAAC9H,KAAK;kBAAE,SAAA+P,UAAOrP,QAAQ;oBAAA,IAAAsP,GAAA;oBAAA,OAAApI,mBAAA,CAAAS,KAAA;sBAAA,SAAA4H,WAAAC,UAAA;wBAAA,kBAAAA,UAAA,CAAA1H,IAAA,GAAA0H,UAAA,CAAAzH,IAAA;0BAAA;4BAChDnE,QAAQ,CAAC,oBAAoB,CAAC,GAAG5D,QAAQ;4BAAAwP,UAAA,CAAAzH,IAAA;4BAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEhC7I,MAAM,CAACI,cAAc,CACzBuB,IAAI,CAAC4C,QAAQ,EAAE;8BAAEc,KAAK,EAAE;4BAAE,CAAC,CAAC,CAC5B+K,UAAU,CAAC,CAAC;0BAAA;4BAAAD,UAAA,CAAAlG,EAAA,GAAAkG,UAAA,CAAArH,IAAA;4BAHXmH,GAAG,GAAAE,UAAA,CAAAlG,EAAA,GAGY,CAAC;4BAAA,OAAAkG,UAAA,CAAApH,MAAA,WACfkH,GAAG;0BAAA;0BAAA;4BAAA,OAAAE,UAAA,CAAAnH,IAAA;wBAAA;sBAAA;sBAAA,OAAAkH,UAAA;oBAAA,uBAAAjH,OAAA;kBAAA;kBACX,OAAA+G,SAAA;gBAAA,IAAC;cAAA;gBAPIvL,GAAG,GAAAsL,UAAA,CAAAjH,IAAA;gBAAA,OAAAiH,UAAA,CAAAhH,MAAA,WASFtE,GAAG;cAAA;cAAA;gBAAA,OAAAsL,UAAA,CAAA/G,IAAA;YAAA;UAAA;UAAA,OAAA8G,UAAA;QAAA,uBAAA7G,OAAA;MAAA;MACX,OAAA4G,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEQ,oBAAoB;MAAE,SAAAC,UAAgBnM,IAAI,EAAEvD,OAAO;QAAA,IAAAkD,EAAA,EAAAS,QAAA,EAAAY,MAAA,EAAAlF,KAAA;QAAA,OAAA4H,mBAAA,CAAAS,KAAA;UAAA,SAAAiI,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAA/H,IAAA,GAAA+H,UAAA,CAAA9H,IAAA;cAAA;gBAGjD9H,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;gBAE1CP,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;gBAEpCrD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;kBACtB+E,WAAW,EAAE,KAAK;kBAClBC,YAAY,EAAE,KAAK;kBACnBlB,QAAQ,EAAE,KAAK;kBACfmB,UAAU,EAAE;gBACd,CAAC,EAAE7E,OAAO,CAAC;gBAEX,IAAIuD,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;kBACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;gBACf,CAAC,MAAM;kBACL6C,EAAE,GAAGK,IAAI;gBACX;gBAAC,IAEIL,EAAE;kBAAA0M,UAAA,CAAA9H,IAAA;kBAAA;gBAAA;gBAAA,OAAA8H,UAAA,CAAAzH,MAAA,WAAS,EAAE;cAAA;gBAEZxE,QAAQ,GAAG;kBACf,UAAU,EAAET;gBACd,CAAC;gBAEKqB,MAAM,GAAG;kBACbxB,MAAM,EAAE;oBAAE,oBAAoB,EAAE;kBAAE;gBACpC,CAAC;gBAED,IAAI,CAAC/C,OAAO,CAAC0D,QAAQ,EAAE;kBACrBC,QAAQ,CAACN,KAAK,GAAG;oBAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK;kBAAE,CAAC;kBAEzC,IAAI,CAACrD,OAAO,CAAC6E,UAAU,EAAE;oBACvBlB,QAAQ,CAACN,KAAK,CAACrC,GAAG,CAAC8D,IAAI,CAAC,IAAI,CAAC;kBAC/B;gBACF;gBAEA,IAAI9E,OAAO,CAAC4E,YAAY,EAAE;kBACxB,OAAOL,MAAM,CAACxB,MAAM,CAAC,oBAAoB,CAAC;kBAC1CwB,MAAM,CAACxB,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;gBAC/B;gBAEA,IAAI/C,OAAO,CAAC2E,WAAW,EAAE;kBACvB,OAAOJ,MAAM,CAACxB,MAAM;gBACtB;gBAAC6M,UAAA,CAAA9H,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEmB7I,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAEY,MAAM,CAAC,CAACiF,UAAU,CAAC,CAAC;cAAA;gBAAvEnK,KAAK,GAAAuQ,UAAA,CAAA1H,IAAA;gBAAA,KAEPlI,OAAO,CAAC2E,WAAW;kBAAAiL,UAAA,CAAA9H,IAAA;kBAAA;gBAAA;gBAAA,OAAA8H,UAAA,CAAAzH,MAAA,WACd9I,KAAK;cAAA;gBAAA,OAAAuQ,UAAA,CAAAzH,MAAA,WAAAhJ,kBAAA,CAIT,IAAI4E,GAAG,CACR1E,KAAK,CAAC0F,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO,EAAK;kBAC7B,IAAIA,OAAO,CAACtE,cAAc,EAAE;oBAC1B,OAAOqE,GAAG,CAACxD,MAAM,CAACyD,OAAO,CAACtE,cAAc,CAACc,GAAG,CAAC,UAACN,CAAC;sBAAA,OAAKA,CAAC,CAACd,GAAG;oBAAA,EAAC,CAAC;kBAC7D,CAAC,MAAM,IAAI4E,OAAO,CAAChD,IAAI,EAAE;oBACvB+C,GAAG,CAACF,IAAI,CAACG,OAAO,CAAChD,IAAI,CAAC5B,GAAG,CAAC;kBAC5B;kBACA,OAAO2E,GAAG;gBACZ,CAAC,EAAE,EAAE,CACP,CAAC;cAAA;cAAA;gBAAA,OAAA4K,UAAA,CAAAxH,IAAA;YAAA;UAAA;UAAA,OAAAuH,UAAA;QAAA,uBAAAtH,OAAA;MAAA;MAEJ,OAAAqH,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACExK,WAAW,EAAE,SAAAA,CAAUC,YAAY,EAAE;MACnCA,YAAY,GAAGA,YAAY,IAAI;QAAEC,IAAI,EAAE;UAAE/E,GAAG,EAAE;QAAE;MAAE,CAAC;MAEnD,OAAOjB,MAAM,CAACC,KAAK,CAAC0B,IAAI,CAAC,CAAC,CAAC,EAAEoE,YAAY,CAAC;IAC5C,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE0K,mBAAmB;MAAE,SAAAC,UAAgBzQ,KAAK,EAAEW,OAAO,EAAEmF,YAAY;QAAA,IAAAG,GAAA;QAAA,OAAA2B,mBAAA,CAAAS,KAAA;UAAA,SAAAqI,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAnI,IAAA,GAAAmI,UAAA,CAAAlI,IAAA;cAAA;gBAAAkI,UAAA,CAAAlI,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEvDxI,KAAK,CAAC8F,yBAAyB,CAAClG,KAAK,EAAEW,OAAO,CAAC,CAACwJ,UAAU,CAAC,CAAC;cAAA;gBAD9DlE,GAAG,GAAA0K,UAAA,CAAA9H,IAAA,CAEPzG,GAAG,CAAC,UAAC+D,CAAC;kBAAA,OAAKA,CAAC,CAACjC,IAAI,CAAClD,GAAG;gBAAA;gBAAA,OAAA2P,UAAA,CAAA7H,MAAA,WAEhB/I,MAAM,CAAC6D,KAAK,CAAClC,IAAI,CACtB;kBAAEV,GAAG,EAAE;oBAAEW,GAAG,EAAEsE;kBAAI;gBAAE,CAAC,EACpBtF,OAAO,IAAIA,OAAO,CAACmF,YAAY,IAAKA,YAAY,IAAI,CAAC,CACxD,CAAC;cAAA;cAAA;gBAAA,OAAA6K,UAAA,CAAA5H,IAAA;YAAA;UAAA;UAAA,OAAA2H,UAAA;QAAA,uBAAA1H,OAAA;MAAA;MACF,OAAAyH,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAEEvK,yBAAyB,EAAE,SAAAA,CAAUlG,KAAK,EAAEW,OAAO,EAAE;MACnDA,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACE8D,QAAQ,EAAE,KAAK;QACfyB,YAAY,EAAE,CAAC;MACjB,CAAC,EACDnF,OACF,CAAC;MAED,OAAOP,KAAK,CAACgG,qBAAqB,CAACpG,KAAK,EAAEW,OAAO,EAAEA,OAAO,CAACmF,YAAY,CAAC;IAC1E,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEM,qBAAqB,EAAE,SAAAA,CAAUpG,KAAK,EAAEW,OAAO,EAAEuE,MAAM,EAAE;MACvDvE,OAAO,GAAGP,KAAK,CAAC0D,iBAAiB,CAACnD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACE8D,QAAQ,EAAE,KAAK;QACfmB,UAAU,EAAE;MACd,CAAC,EACD7E,OACF,CAAC;;MAED;MACA,IAAI,CAACsC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CI,KAAK,CAAC2D,eAAe,CAACpD,OAAO,CAACqD,KAAK,CAAC;MAEpCkB,MAAM,GAAG5E,MAAM,CAACC,MAAM,CACpB;QACEmD,MAAM,EAAE;UAAE,UAAU,EAAE;QAAE;MAC1B,CAAC,EACDwB,MACF,CAAC;MAED,IAAMZ,QAAQ,GAAG;QACf,oBAAoB,EAAE;UAAE3C,GAAG,EAAE3B;QAAM;MACrC,CAAC;MAED,IAAI,CAACW,OAAO,CAAC0D,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAErC,GAAG,EAAE,CAAChB,OAAO,CAACqD,KAAK;QAAE,CAAC;QAEzC,IAAI,CAACrD,OAAO,CAAC6E,UAAU,EAAE;UACvBlB,QAAQ,CAACN,KAAK,CAACrC,GAAG,CAAC8D,IAAI,CAAC,IAAI,CAAC;QAC/B;MACF;MAEA,OAAO1F,MAAM,CAACI,cAAc,CAACuB,IAAI,CAAC4C,QAAQ,EAAEY,MAAM,CAAC;IACrD,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE0L,qBAAqB;MAAE,SAAAC,UAAA;QAAA,IAAAvK,MAAA;QAAA,IAAAwK,OAAA,GAAAnK,SAAA;QAAA,OAAAiB,mBAAA,CAAAS,KAAA;UAAA,SAAA0I,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAxI,IAAA,GAAAwI,UAAA,CAAAvI,IAAA;cAAA;gBACrB,IAAI,CAACpI,kCAAkC,EAAE;kBACvCA,kCAAkC,GAAG,IAAI;kBACzCkG,OAAO,IACLA,OAAO,CAACC,IAAI,CACV,qEACF,CAAC;gBACL;gBAACwK,UAAA,CAAAvI,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAEY,CAAAtC,MAAA,GAAAlG,KAAK,EAACqG,gBAAgB,CAAAC,KAAA,CAAAJ,MAAA,EAAAwK,OAAQ,CAAC;cAAA;gBAAA,OAAAE,UAAA,CAAAlI,MAAA,WAAAkI,UAAA,CAAAnI,IAAA;cAAA;cAAA;gBAAA,OAAAmI,UAAA,CAAAjI,IAAA;YAAA;UAAA;UAAA,OAAAgI,UAAA;QAAA,uBAAA/H,OAAA;MAAA;MAC7C,OAAA6H,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEI,qBAAqB;MAAE,SAAAC,UAAgBhN,IAAI,EAAElE,KAAK;QAAA,IAAA6D,EAAA,EAAAS,QAAA,EAAAsC,MAAA;QAAA,OAAAgB,mBAAA,CAAAS,KAAA;UAAA,SAAA8I,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAA5I,IAAA,GAAA4I,UAAA,CAAA3I,IAAA;cAAA;gBAGhD,IAAIzI,KAAK,IAAI,CAACiD,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;gBAEnD,IAAIkE,IAAI,IAAIzE,OAAA,CAAOyE,IAAI,MAAK,QAAQ,EAAE;kBACpCL,EAAE,GAAGK,IAAI,CAAClD,GAAG;gBACf,CAAC,MAAM;kBACL6C,EAAE,GAAGK,IAAI;gBACX;gBAAC,IAEIL,EAAE;kBAAAuN,UAAA,CAAA3I,IAAA;kBAAA;gBAAA;gBAAA,OAAA2I,UAAA,CAAAtI,MAAA,WAAS,EAAE;cAAA;gBAEZxE,QAAQ,GAAG;kBACf,UAAU,EAAET,EAAE;kBACdG,KAAK,EAAE;oBAAEX,GAAG,EAAE;kBAAK;gBACrB,CAAC;gBAED,IAAIrD,KAAK,EAAE;kBACTsE,QAAQ,CAAC,oBAAoB,CAAC,GAAG;oBAAE3C,GAAG,EAAE3B;kBAAM,CAAC;gBACjD;gBAACoR,UAAA,CAAA3I,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGO7I,MAAM,CAACI,cAAc,CACxBuB,IAAI,CAAC4C,QAAQ,EAAE;kBAAEZ,MAAM,EAAE;oBAAEM,KAAK,EAAE;kBAAE;gBAAE,CAAC,CAAC,CACxCmG,UAAU,CAAC,CAAC;cAAA;gBAHXvD,MAAM,GAAAwK,UAAA,CAAAvI,IAAA,CAIVzG,GAAG,CAAC,UAACyE,GAAG;kBAAA,OAAKA,GAAG,CAAC7C,KAAK;gBAAA;gBAAA,OAAAoN,UAAA,CAAAtI,MAAA,WAAAhJ,kBAAA,CAEb,IAAI4E,GAAG,CAACkC,MAAM,CAAC;cAAA;cAAA;gBAAA,OAAAwK,UAAA,CAAArI,IAAA;YAAA;UAAA;UAAA,OAAAoI,UAAA;QAAA,uBAAAnI,OAAA;MAAA;MAC3B,OAAAkI,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEG,gBAAgB;MAAE,SAAAC,UAAgB7O,OAAO,EAAEC,OAAO;QAAA,IAAAC,KAAA;QAAA,OAAAiF,mBAAA,CAAAS,KAAA;UAAA,SAAAkJ,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAhJ,IAAA,GAAAgJ,UAAA,CAAA/I,IAAA;cAAA;gBAGhDrI,KAAK,CAAC2D,eAAe,CAACtB,OAAO,CAAC;gBAC9BrC,KAAK,CAAC2D,eAAe,CAACrB,OAAO,CAAC;gBAAA,MAE1BD,OAAO,KAAKC,OAAO;kBAAA8O,UAAA,CAAA/I,IAAA;kBAAA;gBAAA;gBAAA,OAAA+I,UAAA,CAAA1I,MAAA;cAAA;gBAAA0I,UAAA,CAAA/I,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGP7I,MAAM,CAACI,cAAc,CAACoJ,WAAW,CAC7C;kBACEvF,KAAK,EAAEvB;gBACT,CAAC,EACD;kBACEP,IAAI,EAAE;oBACJ8B,KAAK,EAAEtB;kBACT;gBACF,CAAC,EACD;kBAAEJ,KAAK,EAAE;gBAAK,CAChB,CAAC;cAAA;gBAVDK,KAAK,GAAA6O,UAAA,CAAA3I,IAAA;cAAA;gBAAA,IAWElG,KAAK,GAAG,CAAC;kBAAA6O,UAAA,CAAA/I,IAAA;kBAAA;gBAAA;cAAA;cAAA;gBAAA,OAAA+I,UAAA,CAAAzI,IAAA;YAAA;UAAA;UAAA,OAAAwI,UAAA;QAAA,uBAAAvI,OAAA;MAAA;MACnB,OAAAsI,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEG,gBAAgB;MAAE,SAAAC,UAAgB1K,IAAI;QAAA,OAAAY,mBAAA,CAAAS,KAAA;UAAA,SAAAsJ,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAApJ,IAAA,GAAAoJ,UAAA,CAAAnJ,IAAA;cAAA;gBACpCrI,KAAK,CAAC2D,eAAe,CAACiD,IAAI,CAAC;gBAAA4K,UAAA,CAAAnJ,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAErB7I,MAAM,CAACI,cAAc,CAAC4J,WAAW,CAAC;kBAAE/F,KAAK,EAAEgD;gBAAK,CAAC,CAAC;cAAA;cAAA;gBAAA,OAAA4K,UAAA,CAAA7I,IAAA;YAAA;UAAA;UAAA,OAAA4I,UAAA;QAAA,uBAAA3I,OAAA;MAAA;MACzD,OAAA0I,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE9Q,cAAc,EAAE,SAAAA,CAAUF,QAAQ,EAAE;MAClC,IACE,CAACA,QAAQ,IACT,OAAOA,QAAQ,KAAK,QAAQ,IAC5BA,QAAQ,CAACuG,IAAI,CAAC,CAAC,KAAKvG,QAAQ,EAC5B;QACA,MAAM,IAAIU,KAAK,CAAC,qBAAqB,GAAGV,QAAQ,GAAG,IAAI,CAAC;MAC1D;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEmR,eAAe;MAAE,SAAAC,UAAgB3K,cAAc,EAAEC,aAAa;QAAA,IAAAC,YAAA,EAAA3G,QAAA,EAAAkC,IAAA;QAAA,OAAAgF,mBAAA,CAAAS,KAAA;UAAA,SAAA0J,WAAAC,UAAA;YAAA,kBAAAA,UAAA,CAAAxJ,IAAA,GAAAwJ,UAAA,CAAAvJ,IAAA;cAAA;gBAAA,MACxDtB,cAAc,KAAKC,aAAa;kBAAA4K,UAAA,CAAAvJ,IAAA;kBAAA;gBAAA;gBAAA,OAAAuJ,UAAA,CAAAlJ,MAAA,WAC3B,IAAI;cAAA;gBAAA,MAGT3B,cAAc,IAAI,IAAI,IAAIC,aAAa,IAAI,IAAI;kBAAA4K,UAAA,CAAAvJ,IAAA;kBAAA;gBAAA;gBAAA,OAAAuJ,UAAA,CAAAlJ,MAAA,WAC1C,KAAK;cAAA;gBAGd1I,KAAK,CAACQ,cAAc,CAACuG,cAAc,CAAC;gBACpC/G,KAAK,CAACQ,cAAc,CAACwG,aAAa,CAAC;gBAE/BC,YAAY,GAAG,CAACF,cAAc,CAAC;cAAA;gBAAA,MAC5BE,YAAY,CAAC9E,MAAM,KAAK,CAAC;kBAAAyP,UAAA,CAAAvJ,IAAA;kBAAA;gBAAA;gBACxB/H,QAAQ,GAAG2G,YAAY,CAACC,GAAG,CAAC,CAAC;gBAAA,MAE/B5G,QAAQ,KAAK0G,aAAa;kBAAA4K,UAAA,CAAAvJ,IAAA;kBAAA;gBAAA;gBAAA,OAAAuJ,UAAA,CAAAlJ,MAAA,WACrB,IAAI;cAAA;gBAAAkJ,UAAA,CAAAvJ,IAAA;gBAAA,OAAAb,mBAAA,CAAAgB,KAAA,CAGM7I,MAAM,CAACC,KAAK,CAACsJ,YAAY,CAAC;kBAAEtI,GAAG,EAAEN;gBAAS,CAAC,CAAC;cAAA;gBAAzDkC,IAAI,GAAAoP,UAAA,CAAAnJ,IAAA;gBAAA,IAGLjG,IAAI;kBAAAoP,UAAA,CAAAvJ,IAAA;kBAAA;gBAAA;gBAAA,OAAAuJ,UAAA,CAAAlJ,MAAA;cAAA;gBAETzB,YAAY,GAAGA,YAAY,CAAClF,MAAM,CAACS,IAAI,CAAC1B,QAAQ,CAACkB,GAAG,CAAC,UAACN,CAAC;kBAAA,OAAKA,CAAC,CAACd,GAAG;gBAAA,EAAC,CAAC;gBAAAgR,UAAA,CAAAvJ,IAAA;gBAAA;cAAA;gBAAA,OAAAuJ,UAAA,CAAAlJ,MAAA,WAG9D,KAAK;cAAA;cAAA;gBAAA,OAAAkJ,UAAA,CAAAjJ,IAAA;YAAA;UAAA;UAAA,OAAAgJ,UAAA;QAAA,uBAAA/I,OAAA;MAAA;MACb,OAAA8I,SAAA;IAAA;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEhO,iBAAiB,EAAE,SAAAA,CAAUnD,OAAO,EAAE;MACpCA,OAAO,GAAGA,OAAO,KAAK4G,SAAS,GAAG,CAAC,CAAC,GAAG5G,OAAO;MAE9C,IAAIA,OAAO,KAAK,IAAI,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QACnDA,OAAO,GAAG;UAAEqD,KAAK,EAAErD;QAAQ,CAAC;MAC9B;MAEAA,OAAO,CAACqD,KAAK,GAAG5D,KAAK,CAACoH,mBAAmB,CAAC7G,OAAO,CAACqD,KAAK,CAAC;MAExD,OAAOrD,OAAO;IAChB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE6G,mBAAmB,EAAE,SAAAA,CAAUC,SAAS,EAAE;MACxC;MACA,IAAIA,SAAS,IAAI,IAAI,EAAE;QACrB,OAAO,IAAI;MACb,CAAC,MAAM;QACL,OAAOA,SAAS;MAClB;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE1D,eAAe,EAAE,SAAAA,CAAU0D,SAAS,EAAE;MACpC,IAAIA,SAAS,KAAK,IAAI,EAAE;MAExB,IACE,CAACA,SAAS,IACV,OAAOA,SAAS,KAAK,QAAQ,IAC7BA,SAAS,CAACR,IAAI,CAAC,CAAC,KAAKQ,SAAS,EAC9B;QACA,MAAM,IAAIrG,KAAK,CAAC,sBAAsB,GAAGqG,SAAS,GAAG,IAAI,CAAC;MAC5D;IACF;EACF,CAAC,CAAC;AAAA,EAAAC,IAAA,OAAAC,MAAA,E;;;;;;;;;;;AC3yCF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvH,KAAK,CAAC6R,KAAK,GAAG,KAAK;AAEnB,IAAI;EACF,IAAIC,YAAY,EAAE;IAChB,IAAMC,IAAI,GAAGD,YAAY,CAACE,OAAO,CAAC,aAAa,CAAC;IAEhD,IAAI,OAAOD,IAAI,KAAK,WAAW,EAAE;MAC/B/R,KAAK,CAAC6R,KAAK,GAAG,CAAC,CAACE,IAAI;IACtB;EACF;AACF,CAAC,CAAC,OAAOE,EAAE,EAAE;EACX;EACA;AAAA,C;;;;;;;;;;;;ECvBF,IAAIC,cAAc;EAAC5S,OAAO,CAACC,IAAI,CAAC,sCAAsC,EAAC;IAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;MAACyS,cAAc,GAACzS,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAjH;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAO,KAAK,CAACmS,UAAU,GAAG;IAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,QAAQ,EAAE,SAAAA,CAAU5P,IAAI,EAAEoB,KAAK,EAAE;MAC/B,IAAME,IAAI,GAAGnE,MAAM,CAACmE,IAAI,CAAC,CAAC;MAC1B,IAAMuO,KAAK,GAAG,CAAC7P,IAAI,IAAI,EAAE,EAAE8P,OAAO,CAAC,GAAG,CAAC;MACvC,IAAI1S,KAAK;MAET,IAAI,CAACkE,IAAI,EAAE,OAAO,KAAK;MACvB,IAAI,CAACyO,KAAK,CAACC,IAAI,CAAChQ,IAAI,EAAEiQ,MAAM,CAAC,EAAE,OAAO,KAAK;MAE3C,IAAIJ,KAAK,KAAK,CAAC,CAAC,EAAE;QAChBzS,KAAK,GAAG4C,IAAI,CAACkQ,KAAK,CAAC,GAAG,CAAC,CAACpN,MAAM,CAAC,UAAUqN,IAAI,EAAEjR,CAAC,EAAE;UAChD,IAAI,CAACA,CAAC,EAAE;YACN,OAAOiR,IAAI;UACb;UACAA,IAAI,CAACtN,IAAI,CAAC3D,CAAC,CAAC;UACZ,OAAOiR,IAAI;QACb,CAAC,EAAE,EAAE,CAAC;MACR,CAAC,MAAM;QACL/S,KAAK,GAAG,CAAC4C,IAAI,CAAC;MAChB;MAEA,IAAI+P,KAAK,CAACC,IAAI,CAAC5O,KAAK,EAAE6O,MAAM,CAAC,EAAE;QAC7B,OAAOzS,KAAK,CAAC6E,YAAY,CAACf,IAAI,EAAElE,KAAK,EAAEgE,KAAK,CAAC;MAC/C;MAEA,OAAO5D,KAAK,CAAC6E,YAAY,CAACf,IAAI,EAAElE,KAAK,CAAC;IACxC;EACF,CAAC;;EAED;EACA;EACA;;EAEA,IAAII,KAAK,CAAC6R,KAAK,IAAI1L,OAAO,CAACyM,GAAG,EAAE;IAC9BzM,OAAO,CAACyM,GAAG,CAAC,uBAAuB,EAAE5S,KAAK,CAAC6R,KAAK,CAAC;EACnD;EAEA,IAAI,OAAOgB,OAAO,CAACC,KAAK,KAAK,WAAW,IACpC,OAAOD,OAAO,CAACC,KAAK,CAACC,KAAK,KAAK,WAAW,IAC1C,OAAOF,OAAO,CAACC,KAAK,CAACC,KAAK,CAACC,cAAc,KAAK,UAAU,EAAE;IAC5D9S,MAAM,CAAC+S,OAAO,CAACjT,KAAK,CAACmS,UAAU,CAAC,CAAC1Q,OAAO,CAAC,UAAAyR,IAAA,EAAkB;MAAA,IAAAC,KAAA,GAAAjB,cAAA,CAAAgB,IAAA;QAAhBtM,IAAI,GAAAuM,KAAA;QAAEC,IAAI,GAAAD,KAAA;MACnD,IAAInT,KAAK,CAAC6R,KAAK,IAAI1L,OAAO,CAACyM,GAAG,EAAE;QAC9BzM,OAAO,CAACyM,GAAG,CAAC,qCAAqC,GAAGhM,IAAI,GAAG,IAAI,CAAC;MAClE;MACAiM,OAAO,CAACC,KAAK,CAACC,KAAK,CAACC,cAAc,CAACpM,IAAI,EAAEwM,IAAI,CAAC;IAChD,CAAC,CAAC;EACJ;AAAC,EAAA9L,IAAA,OAAAC,MAAA,E;;;;;;;;;;;ACxFD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA8L,OAAO,CAACC,OAAO,CAAC,YAAY;EAC1BtT,KAAK,CAACuT,YAAY,GAAG5T,MAAM,CAAC6T,SAAS,CAAC,QAAQ,CAAC;AACjD,CAAC,CAAC,C","file":"/packages/alanning_roles.js","sourcesContent":["/* global Meteor, Roles, Mongo */\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n *  - `_id`: role name\n *  - `children`: list of subdocuments:\n *    - `_id`\n *\n * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n *\n * Roles can have multiple parents and can be children (subroles) of multiple roles.\n *\n * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n *\n * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n * It's documents consist of\n *  - `_id`: Internal MongoDB id\n *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n *  - `user`: A user object, usually only contains the `_id` property\n *  - `scope`: scope name\n *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n *\n * @module Roles\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Mongo.Collection('roles')\n}\n\nif (!Meteor.roleAssignment) {\n  Meteor.roleAssignment = new Mongo.Collection('role-assignment')\n}\n\n/**\n * @class Roles\n */\nif (typeof Roles === 'undefined') {\n  Roles = {} // eslint-disable-line no-global-assign\n}\n\nlet getGroupsForUserDeprecationWarning = false\n\nObject.assign(Roles, {\n\n  /**\n   * Used as a global group (now scope) name. Not used anymore.\n   *\n   * @property GLOBAL_GROUP\n   * @static\n   * @deprecated\n   */\n  GLOBAL_GROUP: null,\n\n  /**\n   * Create a new role.\n   *\n   * @method createRole\n   * @param {String} roleName Name of role.\n   * @param {Object} [options] Options:\n   *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n   * @return {String} ID of the new role or null.\n   * @static\n   */\n  createRole: function (roleName, options) {\n    Roles._checkRoleName(roleName)\n\n    options = Object.assign({\n      unlessExists: false\n    }, options)\n\n    const result = Meteor.roles.upsert({ _id: roleName }, { $setOnInsert: { children: [] } })\n\n    if (!result.insertedId) {\n      if (options.unlessExists) return null\n      throw new Error('Role \\'' + roleName + '\\' already exists.')\n    }\n\n    return result.insertedId\n  },\n\n  /**\n   * Delete an existing role.\n   *\n   * If the role is set for any user, it is automatically unset.\n   *\n   * @method deleteRole\n   * @param {String} roleName Name of role.\n   * @static\n   */\n  deleteRole: function (roleName) {\n    let roles\n    let inheritedRoles\n\n    Roles._checkRoleName(roleName)\n\n    // Remove all assignments\n    Meteor.roleAssignment.remove({\n      'role._id': roleName\n    })\n\n    do {\n      // For all roles who have it as a dependency ...\n      roles = Roles._getParentRoleNames(Meteor.roles.findOne({ _id: roleName }))\n\n      Meteor.roles.find({ _id: { $in: roles } }).fetch().forEach(r => {\n        Meteor.roles.update({\n          _id: r._id\n        }, {\n          $pull: {\n            children: {\n              _id: roleName\n            }\n          }\n        })\n\n        inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({ _id: r._id }))\n        Meteor.roleAssignment.update({\n          'role._id': r._id\n        }, {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({ _id: r2 }))\n          }\n        }, { multi: true })\n      })\n    } while (roles.length > 0)\n\n    // And finally remove the role itself\n    Meteor.roles.remove({ _id: roleName })\n  },\n\n  /**\n   * Rename an existing role.\n   *\n   * @method renameRole\n   * @param {String} oldName Old name of a role.\n   * @param {String} newName New name of a role.\n   * @static\n   */\n  renameRole: function (oldName, newName) {\n    let count\n\n    Roles._checkRoleName(oldName)\n    Roles._checkRoleName(newName)\n\n    if (oldName === newName) return\n\n    const role = Meteor.roles.findOne({ _id: oldName })\n\n    if (!role) {\n      throw new Error('Role \\'' + oldName + '\\' does not exist.')\n    }\n\n    role._id = newName\n\n    Meteor.roles.insert(role)\n\n    do {\n      count = Meteor.roleAssignment.update({\n        'role._id': oldName\n      }, {\n        $set: {\n          'role._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    do {\n      count = Meteor.roleAssignment.update({\n        'inheritedRoles._id': oldName\n      }, {\n        $set: {\n          'inheritedRoles.$._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    do {\n      count = Meteor.roles.update({\n        'children._id': oldName\n      }, {\n        $set: {\n          'children.$._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    Meteor.roles.remove({ _id: oldName })\n  },\n\n  /**\n   * Add role parent to roles.\n   *\n   * Previous parents are kept (role can have multiple parents). For users which have the\n   * parent role set, new subroles are added automatically.\n   *\n   * @method addRolesToParent\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @static\n   */\n  addRolesToParent: function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    rolesNames.forEach(function (roleName) {\n      Roles._addRoleToParent(roleName, parentName)\n    })\n  },\n\n  /**\n   * @method _addRoleToParent\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @private\n   * @static\n   */\n  _addRoleToParent: function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // query to get role's children\n    const role = Meteor.roles.findOne({ _id: roleName })\n\n    if (!role) {\n      throw new Error('Role \\'' + roleName + '\\' does not exist.')\n    }\n\n    // detect cycles\n    if (Roles._getInheritedRoleNames(role).includes(parentName)) {\n      throw new Error('Roles \\'' + roleName + '\\' and \\'' + parentName + '\\' would form a cycle.')\n    }\n\n    const count = Meteor.roles.update({\n      _id: parentName,\n      'children._id': {\n        $ne: role._id\n      }\n    }, {\n      $push: {\n        children: {\n          _id: role._id\n        }\n      }\n    })\n\n    // if there was no change, parent role might not exist, or role is\n    // already a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    Meteor.roleAssignment.update({\n      'inheritedRoles._id': parentName\n    }, {\n      $push: {\n        inheritedRoles: { $each: [role._id, ...Roles._getInheritedRoleNames(role)].map(r => ({ _id: r })) }\n      }\n    }, { multi: true })\n  },\n\n  /**\n   * Remove role parent from roles.\n   *\n   * Other parents are kept (role can have multiple parents). For users which have the\n   * parent role set, removed subrole is removed automatically.\n   *\n   * @method removeRolesFromParent\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @static\n   */\n  removeRolesFromParent: function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    rolesNames.forEach(function (roleName) {\n      Roles._removeRoleFromParent(roleName, parentName)\n    })\n  },\n\n  /**\n   * @method _removeRoleFromParent\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @private\n   * @static\n   */\n  _removeRoleFromParent: function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // check for role existence\n    // this would not really be needed, but we are trying to match addRolesToParent\n    const role = Meteor.roles.findOne({ _id: roleName }, { fields: { _id: 1 } })\n\n    if (!role) {\n      throw new Error('Role \\'' + roleName + '\\' does not exist.')\n    }\n\n    const count = Meteor.roles.update({\n      _id: parentName\n    }, {\n      $pull: {\n        children: {\n          _id: role._id\n        }\n      }\n    })\n\n    // if there was no change, parent role might not exist, or role was\n    // already not a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    // For all roles who have had it as a dependency ...\n    const roles = [...Roles._getParentRoleNames(Meteor.roles.findOne({ _id: parentName })), parentName]\n\n    Meteor.roles.find({ _id: { $in: roles } }).fetch().forEach(r => {\n      const inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({ _id: r._id }))\n      Meteor.roleAssignment.update({\n        'role._id': r._id,\n        'inheritedRoles._id': role._id\n      }, {\n        $set: {\n          inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({ _id: r2 }))\n        }\n      }, { multi: true })\n    })\n  },\n\n  /**\n   * Add users to roles.\n   *\n   * Adds roles to existing roles for each user.\n   *\n   * @example\n   *     Roles.addUsersToRoles(userId, 'admin')\n   *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method addUsersToRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  addUsersToRoles: function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      ifExists: false\n    }, options)\n\n    users.forEach(function (user) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n\n      roles.forEach(function (role) {\n        Roles._addUserToRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Set users' roles.\n   *\n   * Replaces all existing roles with a new set of roles.\n   *\n   * @example\n   *     Roles.setUserRoles(userId, 'admin')\n   *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.setUserRoles([user1, user2], ['user','editor'])\n   *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method setUserRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  setUserRoles: function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      ifExists: false,\n      anyScope: false\n    }, options)\n\n    users.forEach(function (user) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n      // we first clear all roles for the user\n      const selector = { 'user._id': id }\n      if (!options.anyScope) {\n        selector.scope = options.scope\n      }\n\n      Meteor.roleAssignment.remove(selector)\n\n      // and then add all\n      roles.forEach(function (role) {\n        Roles._addUserToRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Add one user to one role.\n   *\n   * @method _addUserToRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @private\n   * @static\n   */\n  _addUserToRole: function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) {\n      return\n    }\n\n    const role = Meteor.roles.findOne({ _id: roleName }, { fields: { children: 1 } })\n\n    if (!role) {\n      if (options.ifExists) {\n        return []\n      } else {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.')\n      }\n    }\n\n    // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n    const res = Meteor.roleAssignment.upsert({\n      'user._id': userId,\n      'role._id': roleName,\n      scope: options.scope\n    }, {\n      $setOnInsert: {\n        user: { _id: userId },\n        role: { _id: roleName },\n        scope: options.scope\n      }\n    })\n\n    if (res.insertedId) {\n      Meteor.roleAssignment.update({ _id: res.insertedId }, {\n        $set: {\n          inheritedRoles: [roleName, ...Roles._getInheritedRoleNames(role)].map(r => ({ _id: r }))\n        }\n      })\n    }\n\n    return res\n  },\n\n  /**\n   * Returns an array of role names the given role name is a child of.\n   *\n   * @example\n   *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getParentRoleNames\n   * @param {object} role The role object\n   * @private\n   * @static\n   */\n  _getParentRoleNames: function (role) {\n    if (!role) {\n      return []\n    }\n\n    const parentRoles = new Set([role._id])\n\n    parentRoles.forEach(roleName => {\n      Meteor.roles.find({ 'children._id': roleName }).fetch().forEach(parentRole => {\n        parentRoles.add(parentRole._id)\n      })\n    })\n\n    parentRoles.delete(role._id)\n\n    return [...parentRoles]\n  },\n\n  /**\n   * Returns an array of role names the given role name is a parent of.\n   *\n   * @example\n   *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getInheritedRoleNames\n   * @param {object} role The role object\n   * @private\n   * @static\n   */\n  _getInheritedRoleNames: function (role) {\n    const inheritedRoles = new Set()\n    const nestedRoles = new Set([role])\n\n    nestedRoles.forEach(r => {\n      const roles = Meteor.roles.find({ _id: { $in: r.children.map(r => r._id) } }, { fields: { children: 1 } }).fetch()\n\n      roles.forEach(r2 => {\n        inheritedRoles.add(r2._id)\n        nestedRoles.add(r2)\n      })\n    })\n\n    return [...inheritedRoles]\n  },\n\n  /**\n   * Remove users from assigned roles.\n   *\n   * @example\n   *     Roles.removeUsersFromRoles(userId, 'admin')\n   *     Roles.removeUsersFromRoles([userId, user2], ['editor'])\n   *     Roles.removeUsersFromRoles(userId, ['user'], 'group1')\n   *\n   * @method removeUsersFromRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  removeUsersFromRoles: function (users, roles, options) {\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    users.forEach(function (user) {\n      if (!user) return\n\n      roles.forEach(function (role) {\n        let id\n        if (typeof user === 'object') {\n          id = user._id\n        } else {\n          id = user\n        }\n\n        Roles._removeUserFromRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Remove one user from one role.\n   *\n   * @method _removeUserFromRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @private\n   * @static\n   */\n  _removeUserFromRole: function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) return\n\n    const selector = {\n      'user._id': userId,\n      'role._id': roleName\n    }\n\n    if (!options.anyScope) {\n      selector.scope = options.scope\n    }\n\n    Meteor.roleAssignment.remove(selector)\n  },\n\n  /**\n   * Check if user has specified roles.\n   *\n   * @example\n   *     // global roles\n   *     Roles.userIsInRole(user, 'admin')\n   *     Roles.userIsInRole(user, ['admin','editor'])\n   *     Roles.userIsInRole(userId, 'admin')\n   *     Roles.userIsInRole(userId, ['admin','editor'])\n   *\n   *     // scope roles (global roles are still checked)\n   *     Roles.userIsInRole(user, 'admin', 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], {scope: 'group1'})\n   *\n   * @method userIsInRole\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n   *                             will return `true` if user is in _any_ role.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope; if supplied, limits check to just that scope\n   *     the user's global roles will always be checked whether scope is specified or not\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Boolean} `true` if user is in _any_ of the target roles\n   * @static\n   */\n  userIsInRole: function (user, roles, options) {\n    let id\n    options = Roles._normalizeOptions(options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    roles = roles.filter(r => r != null)\n\n    if (!roles.length) return false\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      anyScope: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return false\n    if (typeof id !== 'string') return false\n\n    const selector = { 'user._id': id }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope, null] }\n    }\n\n    return roles.some((roleName) => {\n      selector['inheritedRoles._id'] = roleName\n\n      return Meteor.roleAssignment.find(selector, { limit: 1 }).count() > 0\n    })\n  },\n\n  /**\n   * Retrieve user's roles.\n   *\n   * @method getRolesForUser\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n   *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n   *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n   *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n   *     result strongly dependent on the internal data structure of this plugin.\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Array} Array of user's roles, unsorted.\n   * @static\n   */\n  getRolesForUser: function (user, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      fullObjects: false,\n      onlyAssigned: false,\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = { 'user._id': id }\n    const filter = { fields: { 'inheritedRoles._id': 1 } }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    if (options.onlyAssigned) {\n      delete filter.fields['inheritedRoles._id']\n      filter.fields['role._id'] = 1\n    }\n\n    if (options.fullObjects) {\n      delete filter.fields\n    }\n\n    const roles = Meteor.roleAssignment.find(selector, filter).fetch()\n\n    if (options.fullObjects) {\n      return roles\n    }\n\n    return [...new Set(roles.reduce((rev, current) => {\n      if (current.inheritedRoles) {\n        return rev.concat(current.inheritedRoles.map(r => r._id))\n      } else if (current.role) {\n        rev.push(current.role._id)\n      }\n      return rev\n    }, []))]\n  },\n\n  /**\n   * Retrieve cursor of all existing roles.\n   *\n   * @method getAllRoles\n   * @param {Object} queryOptions Options which are passed directly\n   *                                through to `Meteor.roles.find(query, options)`.\n   * @return {Cursor} Cursor of existing roles.\n   * @static\n   */\n  getAllRoles: function (queryOptions) {\n    queryOptions = queryOptions || { sort: { _id: 1 } }\n\n    return Meteor.roles.find({}, queryOptions)\n  },\n\n  /**\n   * Retrieve all users who are in target role.\n   *\n   * Options:\n   *\n   * @method getUsersInRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.users.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.users.find(query, options)`\n   * @return {Cursor} Cursor of users in roles.\n   * @static\n   */\n  getUsersInRole: function (roles, options, queryOptions) {\n    const ids = Roles.getUserAssignmentsForRole(roles, options).fetch().map(a => a.user._id)\n\n    return Meteor.users.find({ _id: { $in: ids } }, ((options && options.queryOptions) || queryOptions) || {})\n  },\n\n  /**\n   * Retrieve all assignments of a user which are for the target role.\n   *\n   * Options:\n   *\n   * @method getUserAssignmentsForRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.roleAssignment.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Cursor} Cursor of user assignments for roles.\n   * @static\n   */\n  getUserAssignmentsForRole: function (roles, options) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign({\n      anyScope: false,\n      queryOptions: {}\n    }, options)\n\n    return Roles._getUsersInRoleCursor(roles, options, options.queryOptions)\n  },\n\n  /**\n   * @method _getUsersInRoleCursor\n   * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n   *                             returned which have at least one of the roles\n   *                             assigned but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [filter] Options which are passed directly\n   *                                through to `Meteor.roleAssignment.find(query, options)`\n   * @return {Object} Cursor to the assignment documents\n   * @private\n   * @static\n   */\n  _getUsersInRoleCursor: function (roles, options, filter) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign({\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    filter = Object.assign({\n      fields: { 'user._id': 1 }\n    }, filter)\n\n    const selector = { 'inheritedRoles._id': { $in: roles } }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    return Meteor.roleAssignment.find(selector, filter)\n  },\n\n  /**\n   * Deprecated. Use `getScopesForUser` instead.\n   *\n   * @method getGroupsForUser\n   * @static\n   * @deprecated\n   */\n  getGroupsForUser: function (...args) {\n    if (!getGroupsForUserDeprecationWarning) {\n      getGroupsForUserDeprecationWarning = true\n      console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.')\n    }\n\n    return Roles.getScopesForUser(...args)\n  },\n\n  /**\n   * Retrieve users scopes, if any.\n   *\n   * @method getScopesForUser\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} [roles] Name of roles to restrict scopes to.\n   *\n   * @return {Array} Array of user's scopes, unsorted.\n   * @static\n   */\n  getScopesForUser: function (user, roles) {\n    let id\n\n    if (roles && !Array.isArray(roles)) roles = [roles]\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id,\n      scope: { $ne: null }\n    }\n\n    if (roles) {\n      selector['inheritedRoles._id'] = { $in: roles }\n    }\n\n    const scopes = Meteor.roleAssignment.find(selector, { fields: { scope: 1 } }).fetch().map(obi => obi.scope)\n\n    return [...new Set(scopes)]\n  },\n\n  /**\n   * Rename a scope.\n   *\n   * Roles assigned with a given scope are changed to be under the new scope.\n   *\n   * @method renameScope\n   * @param {String} oldName Old name of a scope.\n   * @param {String} newName New name of a scope.\n   * @static\n   */\n  renameScope: function (oldName, newName) {\n    let count\n\n    Roles._checkScopeName(oldName)\n    Roles._checkScopeName(newName)\n\n    if (oldName === newName) return\n\n    do {\n      count = Meteor.roleAssignment.update({\n        scope: oldName\n      }, {\n        $set: {\n          scope: newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n  },\n\n  /**\n   * Remove a scope.\n   *\n   * Roles assigned with a given scope are removed.\n   *\n   * @method removeScope\n   * @param {String} name The name of a scope.\n   * @static\n   */\n  removeScope: function (name) {\n    Roles._checkScopeName(name)\n\n    Meteor.roleAssignment.remove({ scope: name })\n  },\n\n  /**\n   * Throw an exception if `roleName` is an invalid role name.\n   *\n   * @method _checkRoleName\n   * @param {String} roleName A role name to match against.\n   * @private\n   * @static\n   */\n  _checkRoleName: function (roleName) {\n    if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n      throw new Error('Invalid role name \\'' + roleName + '\\'.')\n    }\n  },\n\n  /**\n   * Find out if a role is an ancestor of another role.\n   *\n   * WARNING: If you check this on the client, please make sure all roles are published.\n   *\n   * @method isParentOf\n   * @param {String} parentRoleName The role you want to research.\n   * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n   * @static\n   */\n  isParentOf: function (parentRoleName, childRoleName) {\n    if (parentRoleName === childRoleName) {\n      return true\n    }\n\n    if (parentRoleName == null || childRoleName == null) {\n      return false\n    }\n\n    Roles._checkRoleName(parentRoleName)\n    Roles._checkRoleName(childRoleName)\n\n    let rolesToCheck = [parentRoleName]\n    while (rolesToCheck.length !== 0) {\n      const roleName = rolesToCheck.pop()\n\n      if (roleName === childRoleName) {\n        return true\n      }\n\n      const role = Meteor.roles.findOne({ _id: roleName })\n\n      // This should not happen, but this is a problem to address at some other time.\n      if (!role) continue\n\n      rolesToCheck = rolesToCheck.concat(role.children.map(r => r._id))\n    }\n\n    return false\n  },\n\n  /**\n   * Normalize options.\n   *\n   * @method _normalizeOptions\n   * @param {Object} options Options to normalize.\n   * @return {Object} Normalized options.\n   * @private\n   * @static\n   */\n  _normalizeOptions: function (options) {\n    options = options === undefined ? {} : options\n\n    if (options === null || typeof options === 'string') {\n      options = { scope: options }\n    }\n\n    options.scope = Roles._normalizeScopeName(options.scope)\n\n    return options\n  },\n\n  /**\n   * Normalize scope name.\n   *\n   * @method _normalizeScopeName\n   * @param {String} scopeName A scope name to normalize.\n   * @return {String} Normalized scope name.\n   * @private\n   * @static\n   */\n  _normalizeScopeName: function (scopeName) {\n    // map undefined and null to null\n    if (scopeName == null) {\n      return null\n    } else {\n      return scopeName\n    }\n  },\n\n  /**\n   * Throw an exception if `scopeName` is an invalid scope name.\n   *\n   * @method _checkRoleName\n   * @param {String} scopeName A scope name to match against.\n   * @private\n   * @static\n   */\n  _checkScopeName: function (scopeName) {\n    if (scopeName === null) return\n\n    if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n      throw new Error('Invalid scope name \\'' + scopeName + '\\'.')\n    }\n  }\n})\n","/* global Roles */\nimport { Meteor } from 'meteor/meteor'\nimport { Mongo } from 'meteor/mongo'\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n *  - `_id`: role name\n *  - `children`: list of subdocuments:\n *    - `_id`\n *\n * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n *\n * Roles can have multiple parents and can be children (subroles) of multiple roles.\n *\n * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n *\n * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n * It's documents consist of\n *  - `_id`: Internal MongoDB id\n *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n *  - `user`: A user object, usually only contains the `_id` property\n *  - `scope`: scope name\n *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n *\n * @module Roles\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Mongo.Collection('roles')\n}\n\nif (!Meteor.roleAssignment) {\n  Meteor.roleAssignment = new Mongo.Collection('role-assignment')\n}\n\n/**\n * @class Roles\n */\nif (typeof Roles === 'undefined') {\n  Roles = {} // eslint-disable-line no-global-assign\n}\n\nlet getGroupsForUserDeprecationWarning = false\n\n/**\n * Helper, resolves async some\n * @param {*} arr\n * @param {*} predicate\n * @returns {Promise<Boolean>}\n */\nconst asyncSome = async (arr, predicate) => {\n  for (const e of arr) {\n    if (await predicate(e)) return true\n  }\n  return false\n}\n\nObject.assign(Roles, {\n  /**\n   * Used as a global group (now scope) name. Not used anymore.\n   *\n   * @property GLOBAL_GROUP\n   * @static\n   * @deprecated\n   */\n  GLOBAL_GROUP: null,\n\n  /**\n   * Create a new role.\n   *\n   * @method createRoleAsync\n   * @param {String} roleName Name of role.\n   * @param {Object} [options] Options:\n   *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n   * @return {Promise<String>} ID of the new role or null.\n   * @static\n   */\n  createRoleAsync: async function (roleName, options) {\n    Roles._checkRoleName(roleName)\n\n    options = Object.assign(\n      {\n        unlessExists: false\n      },\n      options\n    )\n\n    let insertedId = null\n\n    const existingRole = await Meteor.roles.findOneAsync({ _id: roleName })\n\n    if (existingRole) {\n      await Meteor.roles.updateAsync(\n        { _id: roleName },\n        { $setOnInsert: { children: [] } }\n      )\n      return null\n    } else {\n      insertedId = await Meteor.roles.insertAsync({\n        _id: roleName,\n        children: []\n      })\n    }\n\n    if (!insertedId) {\n      if (options.unlessExists) return null\n      throw new Error(\"Role '\" + roleName + \"' already exists.\")\n    }\n\n    return insertedId\n  },\n\n  /**\n   * Delete an existing role.\n   *\n   * If the role is set for any user, it is automatically unset.\n   *\n   * @method deleteRoleAsync\n   * @param {String} roleName Name of role.\n   * @returns {Promise}\n   * @static\n   */\n  deleteRoleAsync: async function (roleName) {\n    let roles\n    let inheritedRoles\n\n    Roles._checkRoleName(roleName)\n\n    // Remove all assignments\n    await Meteor.roleAssignment.removeAsync({\n      'role._id': roleName\n    })\n\n    do {\n      // For all roles who have it as a dependency ...\n      roles = Roles._getParentRoleNames(\n        await Meteor.roles.findOneAsync({ _id: roleName })\n      )\n\n      for (const r of await Meteor.roles\n        .find({ _id: { $in: roles } })\n        .fetchAsync()) {\n        await Meteor.roles.updateAsync(\n          {\n            _id: r._id\n          },\n          {\n            $pull: {\n              children: {\n                _id: roleName\n              }\n            }\n          }\n        )\n\n        inheritedRoles = await Roles._getInheritedRoleNamesAsync(\n          await Meteor.roles.findOneAsync({ _id: r._id })\n        )\n        await Meteor.roleAssignment.updateAsync(\n          {\n            'role._id': r._id\n          },\n          {\n            $set: {\n              inheritedRoles: [r._id, ...inheritedRoles].map((r2) => ({\n                _id: r2\n              }))\n            }\n          },\n          { multi: true }\n        )\n      }\n    } while (roles.length > 0)\n\n    // And finally remove the role itself\n    await Meteor.roles.removeAsync({ _id: roleName })\n  },\n\n  /**\n   * Rename an existing role.\n   *\n   * @method renameRoleAsync\n   * @param {String} oldName Old name of a role.\n   * @param {String} newName New name of a role.\n   * @returns {Promise}\n   * @static\n   */\n  renameRoleAsync: async function (oldName, newName) {\n    let count\n\n    Roles._checkRoleName(oldName)\n    Roles._checkRoleName(newName)\n\n    if (oldName === newName) return\n\n    const role = await Meteor.roles.findOneAsync({ _id: oldName })\n\n    if (!role) {\n      throw new Error(\"Role '\" + oldName + \"' does not exist.\")\n    }\n\n    role._id = newName\n\n    await Meteor.roles.insertAsync(role)\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          'role._id': oldName\n        },\n        {\n          $set: {\n            'role._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          'inheritedRoles._id': oldName\n        },\n        {\n          $set: {\n            'inheritedRoles.$._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    do {\n      count = await Meteor.roles.updateAsync(\n        {\n          'children._id': oldName\n        },\n        {\n          $set: {\n            'children.$._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    await Meteor.roles.removeAsync({ _id: oldName })\n  },\n\n  /**\n   * Add role parent to roles.\n   *\n   * Previous parents are kept (role can have multiple parents). For users which have the\n   * parent role set, new subroles are added automatically.\n   *\n   * @method addRolesToParentAsync\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @static\n   */\n  addRolesToParentAsync: async function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    for (const roleName of rolesNames) {\n      await Roles._addRoleToParentAsync(roleName, parentName)\n    }\n  },\n\n  /**\n   * @method _addRoleToParentAsync\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _addRoleToParentAsync: async function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // query to get role's children\n    const role = await Meteor.roles.findOneAsync({ _id: roleName })\n\n    if (!role) {\n      throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n    }\n\n    // detect cycles\n    if ((await Roles._getInheritedRoleNamesAsync(role)).includes(parentName)) {\n      throw new Error(\n        \"Roles '\" + roleName + \"' and '\" + parentName + \"' would form a cycle.\"\n      )\n    }\n\n    const count = await Meteor.roles.updateAsync(\n      {\n        _id: parentName,\n        'children._id': {\n          $ne: role._id\n        }\n      },\n      {\n        $push: {\n          children: {\n            _id: role._id\n          }\n        }\n      }\n    )\n\n    // if there was no change, parent role might not exist, or role is\n    // already a sub-role; in any case we do not have anything more to do\n    if (!count) return\n\n    await Meteor.roleAssignment.updateAsync(\n      {\n        'inheritedRoles._id': parentName\n      },\n      {\n        $push: {\n          inheritedRoles: {\n            $each: [\n              role._id,\n              ...(await Roles._getInheritedRoleNamesAsync(role))\n            ].map((r) => ({ _id: r }))\n          }\n        }\n      },\n      { multi: true }\n    )\n  },\n\n  /**\n   * Remove role parent from roles.\n   *\n   * Other parents are kept (role can have multiple parents). For users which have the\n   * parent role set, removed subrole is removed automatically.\n   *\n   * @method removeRolesFromParentAsync\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @static\n   */\n  removeRolesFromParentAsync: async function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    for (const roleName of rolesNames) {\n      await Roles._removeRoleFromParentAsync(roleName, parentName)\n    }\n  },\n\n  /**\n   * @method _removeRoleFromParentAsync\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _removeRoleFromParentAsync: async function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // check for role existence\n    // this would not really be needed, but we are trying to match addRolesToParent\n    const role = await Meteor.roles.findOneAsync(\n      { _id: roleName },\n      { fields: { _id: 1 } }\n    )\n\n    if (!role) {\n      throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n    }\n\n    const count = await Meteor.roles.updateAsync(\n      {\n        _id: parentName\n      },\n      {\n        $pull: {\n          children: {\n            _id: role._id\n          }\n        }\n      }\n    )\n\n    // if there was no change, parent role might not exist, or role was\n    // already not a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    // For all roles who have had it as a dependency ...\n    const roles = [\n      ...(await Roles._getParentRoleNamesAsync(\n        await Meteor.roles.findOneAsync({ _id: parentName })\n      )),\n      parentName\n    ]\n\n    for (const r of await Meteor.roles\n      .find({ _id: { $in: roles } })\n      .fetchAsync()) {\n      const inheritedRoles = await Roles._getInheritedRoleNamesAsync(\n        await Meteor.roles.findOneAsync({ _id: r._id })\n      )\n      await Meteor.roleAssignment.updateAsync(\n        {\n          'role._id': r._id,\n          'inheritedRoles._id': role._id\n        },\n        {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map((r2) => ({\n              _id: r2\n            }))\n          }\n        },\n        { multi: true }\n      )\n    }\n  },\n\n  /**\n   * Add users to roles.\n   *\n   * Adds roles to existing roles for each user.\n   *\n   * @example\n   *     Roles.addUsersToRolesAsync(userId, 'admin')\n   *     Roles.addUsersToRolesAsync(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRolesAsync([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method addUsersToRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  addUsersToRolesAsync: async function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        ifExists: false\n      },\n      options\n    )\n\n    for (const user of users) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n\n      for (const role of roles) {\n        await Roles._addUserToRoleAsync(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Set users' roles.\n   *\n   * Replaces all existing roles with a new set of roles.\n   *\n   * @example\n   *     await Roles.setUserRolesAsync(userId, 'admin')\n   *     await Roles.setUserRolesAsync(userId, ['view-secrets'], 'example.com')\n   *     await Roles.setUserRolesAsync([user1, user2], ['user','editor'])\n   *     await Roles.setUserRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method setUserRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  setUserRolesAsync: async function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        ifExists: false,\n        anyScope: false\n      },\n      options\n    )\n\n    for (const user of users) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n      // we first clear all roles for the user\n      const selector = { 'user._id': id }\n      if (!options.anyScope) {\n        selector.scope = options.scope\n      }\n\n      await Meteor.roleAssignment.removeAsync(selector)\n\n      // and then add all\n      for (const role of roles) {\n        await Roles._addUserToRole(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Add one user to one role.\n   *\n   * @method _addUserToRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _addUserToRoleAsync: async function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) {\n      return\n    }\n\n    const role = await Meteor.roles.findOneAsync(\n      { _id: roleName },\n      { fields: { children: 1 } }\n    )\n\n    if (!role) {\n      if (options.ifExists) {\n        return []\n      } else {\n        throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n      }\n    }\n\n    // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n    // TODO revisit this\n    /* const res = await Meteor.roleAssignment.upsertAsync(\n      {\n        \"user._id\": userId,\n        \"role._id\": roleName,\n        scope: options.scope,\n      },\n      {\n        $setOnInsert: {\n          user: { _id: userId },\n          role: { _id: roleName },\n          scope: options.scope,\n        },\n      }\n    ); */\n    const existingAssignment = await Meteor.roleAssignment.findOneAsync({\n      'user._id': userId,\n      'role._id': roleName,\n      scope: options.scope\n    })\n\n    let insertedId\n    let res\n    if (existingAssignment) {\n      await Meteor.roleAssignment.updateAsync(existingAssignment._id, {\n        $set: {\n          user: { _id: userId },\n          role: { _id: roleName },\n          scope: options.scope\n        }\n      })\n\n      res = await Meteor.roleAssignment.findOneAsync(existingAssignment._id)\n    } else {\n      insertedId = await Meteor.roleAssignment.insertAsync({\n        user: { _id: userId },\n        role: { _id: roleName },\n        scope: options.scope\n      })\n    }\n\n    if (insertedId) {\n      await Meteor.roleAssignment.updateAsync(\n        { _id: insertedId },\n        {\n          $set: {\n            inheritedRoles: [\n              roleName,\n              ...(await Roles._getInheritedRoleNamesAsync(role))\n            ].map((r) => ({ _id: r }))\n          }\n        }\n      )\n\n      res = await Meteor.roleAssignment.findOneAsync({ _id: insertedId })\n    }\n    res.insertedId = insertedId // For backward compatibility\n\n    return res\n  },\n\n  /**\n   * Returns an array of role names the given role name is a child of.\n   *\n   * @example\n   *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getParentRoleNames\n   * @param {object} role The role object\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _getParentRoleNamesAsync: async function (role) {\n    if (!role) {\n      return []\n    }\n\n    const parentRoles = new Set([role._id])\n\n    for (const roleName of parentRoles) {\n      for (const parentRole of await Meteor.roles\n        .find({ 'children._id': roleName })\n        .fetchAsync()) {\n        parentRoles.add(parentRole._id)\n      }\n    }\n\n    parentRoles.delete(role._id)\n\n    return [...parentRoles]\n  },\n\n  /**\n   * Returns an array of role names the given role name is a parent of.\n   *\n   * @example\n   *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getInheritedRoleNames\n   * @param {object} role The role object\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _getInheritedRoleNamesAsync: async function (role) {\n    const inheritedRoles = new Set()\n    const nestedRoles = new Set([role])\n\n    for (const r of nestedRoles) {\n      const roles = await Meteor.roles\n        .find(\n          { _id: { $in: r.children.map((r) => r._id) } },\n          { fields: { children: 1 } }\n        )\n        .fetchAsync()\n\n      for (const r2 of roles) {\n        inheritedRoles.add(r2._id)\n        nestedRoles.add(r2)\n      }\n    }\n\n    return [...inheritedRoles]\n  },\n\n  /**\n   * Remove users from assigned roles.\n   *\n   * @example\n   *     await Roles.removeUsersFromRolesAsync(userId, 'admin')\n   *     await Roles.removeUsersFromRolesAsync([userId, user2], ['editor'])\n   *     await Roles.removeUsersFromRolesAsync(userId, ['user'], 'group1')\n   *\n   * @method removeUsersFromRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  removeUsersFromRolesAsync: async function (users, roles, options) {\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    for (const user of users) {\n      if (!user) return\n\n      for (const role of roles) {\n        let id\n        if (typeof user === 'object') {\n          id = user._id\n        } else {\n          id = user\n        }\n\n        await Roles._removeUserFromRoleAsync(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Remove one user from one role.\n   *\n   * @method _removeUserFromRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _removeUserFromRoleAsync: async function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) return\n\n    const selector = {\n      'user._id': userId,\n      'role._id': roleName\n    }\n\n    if (!options.anyScope) {\n      selector.scope = options.scope\n    }\n\n    await Meteor.roleAssignment.removeAsync(selector)\n  },\n\n  /**\n   * Check if user has specified roles.\n   *\n   * @example\n   *     // global roles\n   *     await Roles.userIsInRoleAsync(user, 'admin')\n   *     await Roles.userIsInRoleAsync(user, ['admin','editor'])\n   *     await Roles.userIsInRoleAsync(userId, 'admin')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'])\n   *\n   *     // scope roles (global roles are still checked)\n   *     await Roles.userIsInRoleAsync(user, 'admin', 'group1')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], 'group1')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], {scope: 'group1'})\n   *\n   * @method userIsInRoleAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n   *                             will return `true` if user is in _any_ role.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope; if supplied, limits check to just that scope\n   *     the user's global roles will always be checked whether scope is specified or not\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Promise<Boolean>} `true` if user is in _any_ of the target roles\n   * @static\n   */\n  userIsInRoleAsync: async function (user, roles, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    roles = roles.filter((r) => r != null)\n\n    if (!roles.length) return false\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        anyScope: false\n      },\n      options\n    )\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return false\n    if (typeof id !== 'string') return false\n\n    const selector = {\n      'user._id': id\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope, null] }\n    }\n\n    const res = await asyncSome(roles, async (roleName) => {\n      selector['inheritedRoles._id'] = roleName\n      const out =\n        (await Meteor.roleAssignment\n          .find(selector, { limit: 1 })\n          .countAsync()) > 0\n      return out\n    })\n\n    return res\n  },\n\n  /**\n   * Retrieve user's roles.\n   *\n   * @method getRolesForUserAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n   *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n   *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n   *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n   *     result strongly dependent on the internal data structure of this plugin.\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Promise<Array>} Array of user's roles, unsorted.\n   * @static\n   */\n  getRolesForUserAsync: async function (user, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      fullObjects: false,\n      onlyAssigned: false,\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id\n    }\n\n    const filter = {\n      fields: { 'inheritedRoles._id': 1 }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    if (options.onlyAssigned) {\n      delete filter.fields['inheritedRoles._id']\n      filter.fields['role._id'] = 1\n    }\n\n    if (options.fullObjects) {\n      delete filter.fields\n    }\n\n    const roles = await Meteor.roleAssignment.find(selector, filter).fetchAsync()\n\n    if (options.fullObjects) {\n      return roles\n    }\n\n    return [\n      ...new Set(\n        roles.reduce((rev, current) => {\n          if (current.inheritedRoles) {\n            return rev.concat(current.inheritedRoles.map((r) => r._id))\n          } else if (current.role) {\n            rev.push(current.role._id)\n          }\n          return rev\n        }, [])\n      )\n    ]\n  },\n\n  /**\n   * Retrieve cursor of all existing roles.\n   *\n   * @method getAllRoles\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.roles.find(query, options)`.\n   * @return {Cursor} Cursor of existing roles.\n   * @static\n   */\n  getAllRoles: function (queryOptions) {\n    queryOptions = queryOptions || { sort: { _id: 1 } }\n\n    return Meteor.roles.find({}, queryOptions)\n  },\n\n  /**\n   * Retrieve all users who are in target role.\n   *\n   * Options:\n   *\n   * @method getUsersInRoleAsync\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.users.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.users.find(query, options)`\n   * @return {Promise<Cursor>} Cursor of users in roles.\n   * @static\n   */\n  getUsersInRoleAsync: async function (roles, options, queryOptions) {\n    const ids = (\n      await Roles.getUserAssignmentsForRole(roles, options).fetchAsync()\n    ).map((a) => a.user._id)\n\n    return Meteor.users.find(\n      { _id: { $in: ids } },\n      (options && options.queryOptions) || queryOptions || {}\n    )\n  },\n\n  /**\n   * Retrieve all assignments of a user which are for the target role.\n   *\n   * Options:\n   *\n   * @method getUserAssignmentsForRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.roleAssignment.find(query, options)`\n\n   * Alternatively, it can be a scope name string.\n   * @return {Cursor} Cursor of user assignments for roles.\n   * @static\n   */\n  getUserAssignmentsForRole: function (roles, options) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign(\n      {\n        anyScope: false,\n        queryOptions: {}\n      },\n      options\n    )\n\n    return Roles._getUsersInRoleCursor(roles, options, options.queryOptions)\n  },\n\n  /**\n   * @method _getUsersInRoleCursor\n   * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n   *                             returned which have at least one of the roles\n   *                             assigned but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [filter] Options which are passed directly\n   *                                through to `Meteor.roleAssignment.find(query, options)`\n   * @return {Object} Cursor to the assignment documents\n   * @private\n   * @static\n   */\n  _getUsersInRoleCursor: function (roles, options, filter) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign(\n      {\n        anyScope: false,\n        onlyScoped: false\n      },\n      options\n    )\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    filter = Object.assign(\n      {\n        fields: { 'user._id': 1 }\n      },\n      filter\n    )\n\n    const selector = {\n      'inheritedRoles._id': { $in: roles }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    return Meteor.roleAssignment.find(selector, filter)\n  },\n\n  /**\n   * Deprecated. Use `getScopesForUser` instead.\n   *\n   * @method getGroupsForUserAsync\n   * @returns {Promise<Array>}\n   * @static\n   * @deprecated\n   */\n  getGroupsForUserAsync: async function (...args) {\n    if (!getGroupsForUserDeprecationWarning) {\n      getGroupsForUserDeprecationWarning = true\n      console &&\n        console.warn(\n          'getGroupsForUser has been deprecated. Use getScopesForUser instead.'\n        )\n    }\n\n    return await Roles.getScopesForUser(...args)\n  },\n\n  /**\n   * Retrieve users scopes, if any.\n   *\n   * @method getScopesForUserAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} [roles] Name of roles to restrict scopes to.\n   *\n   * @return {Promise<Array>} Array of user's scopes, unsorted.\n   * @static\n   */\n  getScopesForUserAsync: async function (user, roles) {\n    let id\n\n    if (roles && !Array.isArray(roles)) roles = [roles]\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id,\n      scope: { $ne: null }\n    }\n\n    if (roles) {\n      selector['inheritedRoles._id'] = { $in: roles }\n    }\n\n    const scopes = (\n      await Meteor.roleAssignment\n        .find(selector, { fields: { scope: 1 } })\n        .fetchAsync()\n    ).map((obi) => obi.scope)\n\n    return [...new Set(scopes)]\n  },\n\n  /**\n   * Rename a scope.\n   *\n   * Roles assigned with a given scope are changed to be under the new scope.\n   *\n   * @method renameScopeAsync\n   * @param {String} oldName Old name of a scope.\n   * @param {String} newName New name of a scope.\n   * @returns {Promise}\n   * @static\n   */\n  renameScopeAsync: async function (oldName, newName) {\n    let count\n\n    Roles._checkScopeName(oldName)\n    Roles._checkScopeName(newName)\n\n    if (oldName === newName) return\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          scope: oldName\n        },\n        {\n          $set: {\n            scope: newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n  },\n\n  /**\n   * Remove a scope.\n   *\n   * Roles assigned with a given scope are removed.\n   *\n   * @method removeScopeAsync\n   * @param {String} name The name of a scope.\n   * @returns {Promise}\n   * @static\n   */\n  removeScopeAsync: async function (name) {\n    Roles._checkScopeName(name)\n\n    await Meteor.roleAssignment.removeAsync({ scope: name })\n  },\n\n  /**\n   * Throw an exception if `roleName` is an invalid role name.\n   *\n   * @method _checkRoleName\n   * @param {String} roleName A role name to match against.\n   * @private\n   * @static\n   */\n  _checkRoleName: function (roleName) {\n    if (\n      !roleName ||\n      typeof roleName !== 'string' ||\n      roleName.trim() !== roleName\n    ) {\n      throw new Error(\"Invalid role name '\" + roleName + \"'.\")\n    }\n  },\n\n  /**\n   * Find out if a role is an ancestor of another role.\n   *\n   * WARNING: If you check this on the client, please make sure all roles are published.\n   *\n   * @method isParentOfAsync\n   * @param {String} parentRoleName The role you want to research.\n   * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n   * @returns {Promise}\n   * @static\n   */\n  isParentOfAsync: async function (parentRoleName, childRoleName) {\n    if (parentRoleName === childRoleName) {\n      return true\n    }\n\n    if (parentRoleName == null || childRoleName == null) {\n      return false\n    }\n\n    Roles._checkRoleName(parentRoleName)\n    Roles._checkRoleName(childRoleName)\n\n    let rolesToCheck = [parentRoleName]\n    while (rolesToCheck.length !== 0) {\n      const roleName = rolesToCheck.pop()\n\n      if (roleName === childRoleName) {\n        return true\n      }\n\n      const role = await Meteor.roles.findOneAsync({ _id: roleName })\n\n      // This should not happen, but this is a problem to address at some other time.\n      if (!role) continue\n\n      rolesToCheck = rolesToCheck.concat(role.children.map((r) => r._id))\n    }\n\n    return false\n  },\n\n  /**\n   * Normalize options.\n   *\n   * @method _normalizeOptions\n   * @param {Object} options Options to normalize.\n   * @return {Object} Normalized options.\n   * @private\n   * @static\n   */\n  _normalizeOptions: function (options) {\n    options = options === undefined ? {} : options\n\n    if (options === null || typeof options === 'string') {\n      options = { scope: options }\n    }\n\n    options.scope = Roles._normalizeScopeName(options.scope)\n\n    return options\n  },\n\n  /**\n   * Normalize scope name.\n   *\n   * @method _normalizeScopeName\n   * @param {String} scopeName A scope name to normalize.\n   * @return {String} Normalized scope name.\n   * @private\n   * @static\n   */\n  _normalizeScopeName: function (scopeName) {\n    // map undefined and null to null\n    if (scopeName == null) {\n      return null\n    } else {\n      return scopeName\n    }\n  },\n\n  /**\n   * Throw an exception if `scopeName` is an invalid scope name.\n   *\n   * @method _checkRoleName\n   * @param {String} scopeName A scope name to match against.\n   * @private\n   * @static\n   */\n  _checkScopeName: function (scopeName) {\n    if (scopeName === null) return\n\n    if (\n      !scopeName ||\n      typeof scopeName !== 'string' ||\n      scopeName.trim() !== scopeName\n    ) {\n      throw new Error(\"Invalid scope name '\" + scopeName + \"'.\")\n    }\n  }\n})\n","/* global Roles, localStorage */\n\n// //////////////////////////////////////////////////////////\n// Debugging helpers\n//\n// Run this in your browser console to turn on debugging\n// for this package:\n//\n//   localstorage.setItem('Roles.debug', true)\n//\n\nRoles.debug = false\n\ntry {\n  if (localStorage) {\n    const temp = localStorage.getItem('Roles.debug')\n\n    if (typeof temp !== 'undefined') {\n      Roles.debug = !!temp\n    }\n  }\n} catch (ex) {\n  // ignore: accessing localStorage when its disabled throws\n  // https://github.com/meteor/meteor/issues/5759\n}\n","/* global Meteor, Roles, Match, Package */\n\n/**\n * Convenience functions for use on client.\n *\n * NOTE: You must restrict user actions on the server-side; any\n * client-side checks are strictly for convenience and must not be\n * trusted.\n *\n * @module UIHelpers\n */\n\n// //////////////////////////////////////////////////////////\n// UI helpers\n//\n// Use a semi-private variable rather than declaring UI\n// helpers directly so that we can unit test the helpers.\n// XXX For some reason, the UI helpers are not registered\n// before the tests run.\n//\nRoles._uiHelpers = {\n\n  /**\n   * UI helper to check if current user is in at least one\n   * of the target roles.  For use in client-side templates.\n   *\n   * @example\n   *     {{#if isInRole 'admin'}}\n   *     {{/if}}\n   *\n   *     {{#if isInRole 'editor,user'}}\n   *     {{/if}}\n   *\n   *     {{#if isInRole 'editor,user' 'scope1'}}\n   *     {{/if}}\n   *\n   * @method isInRole\n   * @param {String} role Name of role or comma-seperated list of roles.\n   * @param {String} [scope] Optional, name of scope to check.\n   * @return {Boolean} `true` if current user is in at least one of the target roles.\n   * @static\n   * @for UIHelpers\n   */\n  isInRole: function (role, scope) {\n    const user = Meteor.user()\n    const comma = (role || '').indexOf(',')\n    let roles\n\n    if (!user) return false\n    if (!Match.test(role, String)) return false\n\n    if (comma !== -1) {\n      roles = role.split(',').reduce(function (memo, r) {\n        if (!r) {\n          return memo\n        }\n        memo.push(r)\n        return memo\n      }, [])\n    } else {\n      roles = [role]\n    }\n\n    if (Match.test(scope, String)) {\n      return Roles.userIsInRole(user, roles, scope)\n    }\n\n    return Roles.userIsInRole(user, roles)\n  }\n}\n\n// //////////////////////////////////////////////////////////\n// Register UI helpers\n//\n\nif (Roles.debug && console.log) {\n  console.log('[roles] Roles.debug =', Roles.debug)\n}\n\nif (typeof Package.blaze !== 'undefined' &&\n    typeof Package.blaze.Blaze !== 'undefined' &&\n    typeof Package.blaze.Blaze.registerHelper === 'function') {\n  Object.entries(Roles._uiHelpers).forEach(([name, func]) => {\n    if (Roles.debug && console.log) {\n      console.log('[roles] registering Blaze helper \\'' + name + '\\'')\n    }\n    Package.blaze.Blaze.registerHelper(name, func)\n  })\n}\n","/* global Meteor, Roles, Tracker */\n\n/**\n * Subscription handle for the collection of all existing roles.\n *\n * @example\n *\n *     Roles.subscription.ready(); // true if roles have been loaded\n *\n * @property subscription\n * @type Object\n * @for Roles\n * @static\n */\n\nTracker.autorun(function () {\n  Roles.subscription = Meteor.subscribe('_roles')\n})\n"]}}]