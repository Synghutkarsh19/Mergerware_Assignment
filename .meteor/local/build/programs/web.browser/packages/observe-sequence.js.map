{"version":3,"sources":["meteor://ðŸ’»app/packages/observe-sequence/observe_sequence.js"],"names":["isObject","value","type","has","obj","path","thisPath","Array","isArray","length","i","key","_has","Object","hasOwnProperty","call","warn","ObserveSequence","_suppressWarnings","console","apply","arguments","_loggedWarnings","arr","isIterable","object","iter","Symbol","iterator","idStringify","MongoID","idParse","observe","sequenceFunc","callbacks","lastSeq","activeObserveHandle","lastSeqArray","computation","Tracker","autorun","seq","nonreactive","seqArray","fetch","map","doc","_id","item","stop","seqChangedToEmpty","seqChangedToArray","isStoreCursor","result","seqChangedToCursor","array","from","badSequenceError","diffArray","ellipsis","longStr","maxLength","substr","arrayToDebugStr","out","sep","toDebugStr","toString","JSON","stringify","constructor","name","sequenceGotValue","sequence","e","Error","isFunction","func","cursor","diffFn","Package","DiffSequence","diffQueryOrderedChanges","oldIdObjects","newIdObjects","posOld","posNew","posCur","lengthCur","forEach","push","addedBefore","id","before","position","entries","_ref","pos","addedAt","movedBefore","oldPosition","newPosition","_ref2","elCurPosition","movedTo","removed","prevPosition","_ref3","removedAt","_ref4","idString","newItem","oldItem","changedAt","idsUsed","index","undefined","Random","initial","observeHandle","document","atIndex","newDocument","oldDocument","fromIndex","toIndex"],"mappings":"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","file":"/packages/observe-sequence.js","sourcesContent":["const isObject = function (value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\nconst has = (obj, path) => {\n  const thisPath = Array.isArray(path) ? path : [path];\n  const length = thisPath.length;\n  for (let i = 0; i < length; i++) {\n    const key = thisPath[i];\n    const _has = obj != null && Object.hasOwnProperty.call(obj, key);\n    if (!_has) return false;\n    obj = obj[key];\n  }\n  return !!length;\n};\n\nconst warn = function () {\n  if (ObserveSequence._suppressWarnings) {\n    ObserveSequence._suppressWarnings--;\n  } else {\n    if (typeof console !== 'undefined' && console.warn)\n      console.warn.apply(console, arguments);\n\n    ObserveSequence._loggedWarnings++;\n  }\n};\n\n// isArray returns true for arrays of these types:\n// standard arrays: instanceof Array === true, _.isArray(arr) === true\n// vm generated arrays: instanceOf Array === false, _.isArray(arr) === true\n// subclassed arrays: instanceof Array === true, _.isArray(arr) === false\n// see specific tests\nfunction isArray(arr) {\n  return arr instanceof Array || Array.isArray(arr);\n}\n\n// isIterable returns trues for objects implementing iterable protocol,\n// except strings, as {{#each 'string'}} doesn't make much sense.\n// Requires ES6+ and does not work in IE (but degrades gracefully).\n// Does not support the `length` + index protocol also supported by Array.from\nfunction isIterable (object) {\n  const iter = typeof Symbol != 'undefined' && Symbol.iterator;\n  return iter\n    && object instanceof Object // note: returns false for strings\n    && typeof object[iter] == 'function'; // implements iterable protocol\n}\n\nconst idStringify = MongoID.idStringify;\nconst idParse = MongoID.idParse;\n\nObserveSequence = {\n  _suppressWarnings: 0,\n  _loggedWarnings: 0,\n\n  // A mechanism similar to cursor.observe which receives a reactive\n  // function returning a sequence type and firing appropriate callbacks\n  // when the value changes.\n  //\n  // @param sequenceFunc {Function} a reactive function returning a\n  //     sequence type. The currently supported sequence types are:\n  //     Array, Cursor, and null.\n  //\n  // @param callbacks {Object} similar to a specific subset of\n  //     callbacks passed to `cursor.observe`\n  //     (http://docs.meteor.com/#observe), with minor variations to\n  //     support the fact that not all sequences contain objects with\n  //     _id fields.  Specifically:\n  //\n  //     * addedAt(id, item, atIndex, beforeId)\n  //     * changedAt(id, newItem, oldItem, atIndex)\n  //     * removedAt(id, oldItem, atIndex)\n  //     * movedTo(id, item, fromIndex, toIndex, beforeId)\n  //\n  // @returns {Object(stop: Function)} call 'stop' on the return value\n  //     to stop observing this sequence function.\n  //\n  // We don't make any assumptions about our ability to compare sequence\n  // elements (ie, we don't assume EJSON.equals works; maybe there is extra\n  // state/random methods on the objects) so unlike cursor.observe, we may\n  // sometimes call changedAt() when nothing actually changed.\n  // XXX consider if we *can* make the stronger assumption and avoid\n  //     no-op changedAt calls (in some cases?)\n  //\n  // XXX currently only supports the callbacks used by our\n  // implementation of {{#each}}, but this can be expanded.\n  //\n  // XXX #each doesn't use the indices (though we'll eventually need\n  // a way to get them when we support `@index`), but calling\n  // `cursor.observe` causes the index to be calculated on every\n  // callback using a linear scan (unless you turn it off by passing\n  // `_no_indices`).  Any way to avoid calculating indices on a pure\n  // cursor observe like we used to?\n  observe: function (sequenceFunc, callbacks) {\n    var lastSeq = null;\n    var activeObserveHandle = null;\n\n    // 'lastSeqArray' contains the previous value of the sequence\n    // we're observing. It is an array of objects with '_id' and\n    // 'item' fields.  'item' is the element in the array, or the\n    // document in the cursor.\n    //\n    // '_id' is whichever of the following is relevant, unless it has\n    // already appeared -- in which case it's randomly generated.\n    //\n    // * if 'item' is an object:\n    //   * an '_id' field, if present\n    //   * otherwise, the index in the array\n    //\n    // * if 'item' is a number or string, use that value\n    //\n    // XXX this can be generalized by allowing {{#each}} to accept a\n    // general 'key' argument which could be a function, a dotted\n    // field name, or the special @index value.\n    var lastSeqArray = []; // elements are objects of form {_id, item}\n    var computation = Tracker.autorun(function () {\n      var seq = sequenceFunc();\n\n      Tracker.nonreactive(function () {\n        var seqArray; // same structure as `lastSeqArray` above.\n\n        if (activeObserveHandle) {\n          // If we were previously observing a cursor, replace lastSeqArray with\n          // more up-to-date information.  Then stop the old observe.\n          lastSeqArray = lastSeq.fetch().map(function (doc) {\n            return {_id: doc._id, item: doc};\n          });\n          activeObserveHandle.stop();\n          activeObserveHandle = null;\n        }\n\n        if (!seq) {\n          seqArray = seqChangedToEmpty(lastSeqArray, callbacks);\n        } else if (isArray(seq)) {\n          seqArray = seqChangedToArray(lastSeqArray, seq, callbacks);\n        } else if (isStoreCursor(seq)) {\n          var result /* [seqArray, activeObserveHandle] */ =\n                seqChangedToCursor(lastSeqArray, seq, callbacks);\n          seqArray = result[0];\n          activeObserveHandle = result[1];\n        } else if (isIterable(seq)) {\n          const array = Array.from(seq);\n          seqArray = seqChangedToArray(lastSeqArray, array, callbacks);\n        } else {\n          throw badSequenceError(seq);\n        }\n\n        diffArray(lastSeqArray, seqArray, callbacks);\n        lastSeq = seq;\n        lastSeqArray = seqArray;\n      });\n    });\n\n    return {\n      stop: function () {\n        computation.stop();\n        if (activeObserveHandle)\n          activeObserveHandle.stop();\n      }\n    };\n  },\n\n  // Fetch the items of `seq` into an array, where `seq` is of one of the\n  // sequence types accepted by `observe`.  If `seq` is a cursor, a\n  // dependency is established.\n  fetch: function (seq) {\n    if (!seq) {\n      return [];\n    } else if (isArray(seq)) {\n      return seq;\n    } else if (isStoreCursor(seq)) {\n      return seq.fetch();\n    } else if (isIterable(seq)) {\n      return Array.from(seq);\n    } else {\n      throw badSequenceError(seq);\n    }\n  }\n};\n\nfunction ellipsis(longStr, maxLength) {\n  if(!maxLength) maxLength = 100;\n  if(longStr.length < maxLength) return longStr;\n  return longStr.substr(0, maxLength-1) + 'â€¦';\n}\n\nfunction arrayToDebugStr(value, maxLength) {\n  var out = '', sep = '';\n  for(var i = 0; i < value.length; i++) {\n    var item = value[i];\n    out += sep + toDebugStr(item, maxLength);\n    if(out.length > maxLength) return out;\n    sep = ', ';\n  }\n  return out;\n}\n\nfunction toDebugStr(value, maxLength) {\n  if(!maxLength) maxLength = 150;\n  const type = typeof value;\n  switch(type) {\n    case 'undefined':\n      return type;\n    case 'number':\n      return value.toString();\n    case 'string':\n      return JSON.stringify(value); // add quotes\n    case 'object':\n      if(value === null) {\n        return 'null';\n      } else if(Array.isArray(value)) {\n        return 'Array [' + arrayToDebugStr(value, maxLength) + ']';\n      } else if(Symbol.iterator in value) { // Map and Set are not handled by JSON.stringify\n        return value.constructor.name\n          + ' [' + arrayToDebugStr(Array.from(value), maxLength)\n          + ']'; // Array.from doesn't work in IE, but neither do iterators so it's unreachable\n      } else { // use JSON.stringify (sometimes toString can be better but we don't know)\n        return value.constructor.name + ' '\n             + ellipsis(JSON.stringify(value), maxLength);\n      }\n    default:\n      return type + ': ' + value.toString();\n  }\n}\n\nfunction sequenceGotValue(sequence) {\n  try {\n    return ' Got ' + toDebugStr(sequence);\n  } catch(e) {\n    return ''\n  }\n}\n\nconst badSequenceError = function (sequence) {\n  return new Error(\"{{#each}} currently only accepts \" +\n                   \"arrays, cursors, iterables or falsey values.\" +\n                   sequenceGotValue(sequence));\n};\n\nconst isFunction = (func) => {\n  return typeof func === \"function\";\n}\n\nconst isStoreCursor = function (cursor) {\n  return cursor && isObject(cursor) &&\n    isFunction(cursor.observe) && isFunction(cursor.fetch);\n};\n\n// Calculates the differences between `lastSeqArray` and\n// `seqArray` and calls appropriate functions from `callbacks`.\n// Reuses Minimongo's diff algorithm implementation.\nconst diffArray = function (lastSeqArray, seqArray, callbacks) {\n  var diffFn = Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n  var oldIdObjects = [];\n  var newIdObjects = [];\n  var posOld = {}; // maps from idStringify'd ids\n  var posNew = {}; // ditto\n  var posCur = {};\n  var lengthCur = lastSeqArray.length;\n\n  seqArray.forEach(function (doc, i) {\n    newIdObjects.push({_id: doc._id});\n    posNew[idStringify(doc._id)] = i;\n  });\n  lastSeqArray.forEach(function (doc, i) {\n    oldIdObjects.push({_id: doc._id});\n    posOld[idStringify(doc._id)] = i;\n    posCur[idStringify(doc._id)] = i;\n  });\n\n  // Arrays can contain arbitrary objects. We don't diff the\n  // objects. Instead we always fire 'changedAt' callback on every\n  // object. The consumer of `observe-sequence` should deal with\n  // it appropriately.\n  diffFn(oldIdObjects, newIdObjects, {\n    addedBefore: function (id, doc, before) {\n      var position = before ? posCur[idStringify(before)] : lengthCur;\n\n      if (before) {\n        // If not adding at the end, we need to update indexes.\n        // XXX this can still be improved greatly!\n        Object.entries(posCur).forEach(function ([id, pos]) {\n          if (pos >= position)\n            posCur[id]++;\n        });\n      }\n\n      lengthCur++;\n      posCur[idStringify(id)] = position;\n\n      callbacks.addedAt(\n        id,\n        seqArray[posNew[idStringify(id)]].item,\n        position,\n        before);\n    },\n    movedBefore: function (id, before) {\n      if (id === before)\n        return;\n\n      var oldPosition = posCur[idStringify(id)];\n      var newPosition = before ? posCur[idStringify(before)] : lengthCur;\n\n      // Moving the item forward. The new element is losing one position as it\n      // was removed from the old position before being inserted at the new\n      // position.\n      // Ex.:   0  *1*  2   3   4\n      //        0   2   3  *1*  4\n      // The original issued callback is \"1\" before \"4\".\n      // The position of \"1\" is 1, the position of \"4\" is 4.\n      // The generated move is (1) -> (3)\n      if (newPosition > oldPosition) {\n        newPosition--;\n      }\n\n      // Fix up the positions of elements between the old and the new positions\n      // of the moved element.\n      //\n      // There are two cases:\n      //   1. The element is moved forward. Then all the positions in between\n      //   are moved back.\n      //   2. The element is moved back. Then the positions in between *and* the\n      //   element that is currently standing on the moved element's future\n      //   position are moved forward.\n      Object.entries(posCur).forEach(function ([id, elCurPosition]) {\n        if (oldPosition < elCurPosition && elCurPosition < newPosition)\n          posCur[id]--;\n        else if (newPosition <= elCurPosition && elCurPosition < oldPosition)\n          posCur[id]++;\n      });\n\n      // Finally, update the position of the moved element.\n      posCur[idStringify(id)] = newPosition;\n\n      callbacks.movedTo(\n        id,\n        seqArray[posNew[idStringify(id)]].item,\n        oldPosition,\n        newPosition,\n        before);\n    },\n    removed: function (id) {\n      var prevPosition = posCur[idStringify(id)];\n\n      Object.entries(posCur).forEach(function ([id, pos]) {\n        if (pos >= prevPosition)\n          posCur[id]--;\n      });\n\n      delete posCur[idStringify(id)];\n      lengthCur--;\n\n      callbacks.removedAt(\n        id,\n        lastSeqArray[posOld[idStringify(id)]].item,\n        prevPosition);\n    }\n  });\n  \n  Object.entries(posNew).forEach(function ([idString, pos]) {\n\n    var id = idParse(idString);\n    \n    if (has(posOld, idString)) {\n      // specifically for primitive types, compare equality before\n      // firing the 'changedAt' callback. otherwise, always fire it\n      // because doing a deep EJSON comparison is not guaranteed to\n      // work (an array can contain arbitrary objects, and 'transform'\n      // can be used on cursors). also, deep diffing is not\n      // necessarily the most efficient (if only a specific subfield\n      // of the object is later accessed).\n      var newItem = seqArray[pos].item;\n      var oldItem = lastSeqArray[posOld[idString]].item;\n\n      if (typeof newItem === 'object' || newItem !== oldItem)\n          callbacks.changedAt(id, newItem, oldItem, pos);\n      }\n  });\n};\n\nseqChangedToEmpty = function (lastSeqArray, callbacks) {\n  return [];\n};\n\nseqChangedToArray = function (lastSeqArray, array, callbacks) {\n  var idsUsed = {};\n  var seqArray = array.map(function (item, index) {\n    var id;\n    if (typeof item === 'string') {\n      // ensure not empty, since other layers (eg DomRange) assume this as well\n      id = \"-\" + item;\n    } else if (typeof item === 'number' ||\n               typeof item === 'boolean' ||\n               item === undefined ||\n               item === null) {\n      id = item;\n    } else if (typeof item === 'object') {\n      id = (item && ('_id' in item)) ? item._id : index;\n    } else {\n      throw new Error(\"{{#each}} doesn't support arrays with \" +\n                      \"elements of type \" + typeof item);\n    }\n\n    var idString = idStringify(id);\n    if (idsUsed[idString]) {\n      if (item && typeof item === 'object' && '_id' in item)\n        warn(\"duplicate id \" + id + \" in\", array);\n      id = Random.id();\n    } else {\n      idsUsed[idString] = true;\n    }\n\n    return { _id: id, item: item };\n  });\n\n  return seqArray;\n};\n\nseqChangedToCursor = function (lastSeqArray, cursor, callbacks) {\n  var initial = true; // are we observing initial data from cursor?\n  var seqArray = [];\n\n  var observeHandle = cursor.observe({\n    addedAt: function (document, atIndex, before) {\n      if (initial) {\n        // keep track of initial data so that we can diff once\n        // we exit `observe`.\n        if (before !== null)\n          throw new Error(\"Expected initial data from observe in order\");\n        seqArray.push({ _id: document._id, item: document });\n      } else {\n        callbacks.addedAt(document._id, document, atIndex, before);\n      }\n    },\n    changedAt: function (newDocument, oldDocument, atIndex) {\n      callbacks.changedAt(newDocument._id, newDocument, oldDocument,\n                          atIndex);\n    },\n    removedAt: function (oldDocument, atIndex) {\n      callbacks.removedAt(oldDocument._id, oldDocument, atIndex);\n    },\n    movedTo: function (document, fromIndex, toIndex, before) {\n      callbacks.movedTo(\n        document._id, document, fromIndex, toIndex, before);\n    }\n  });\n  initial = false;\n\n  return [seqArray, observeHandle];\n};\n"]}